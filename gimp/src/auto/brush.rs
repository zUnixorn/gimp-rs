// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,BrushGeneratedShape,Resource};
use glib::{translate::*};

glib::wrapper! {
    #[doc(alias = "GimpBrush")]
    pub struct Brush(Object<ffi::GimpBrush, ffi::GimpBrushClass>) @extends Resource;

    match fn {
        type_ => || ffi::gimp_brush_get_type(),
    }
}

impl Brush {
    #[doc(alias = "gimp_brush_new")]
    pub fn new(name: &str) -> Brush {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_brush_new(name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_brush_get_angle")]
    #[doc(alias = "get_angle")]
    pub fn angle(&self) -> Option<f64> {
        unsafe {
            let mut angle = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_get_angle(self.to_glib_none().0, angle.as_mut_ptr()));
            if ret { Some(angle.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_get_aspect_ratio")]
    #[doc(alias = "get_aspect_ratio")]
    pub fn aspect_ratio(&self) -> Option<f64> {
        unsafe {
            let mut aspect_ratio = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_get_aspect_ratio(self.to_glib_none().0, aspect_ratio.as_mut_ptr()));
            if ret { Some(aspect_ratio.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_get_buffer")]
    #[doc(alias = "get_buffer")]
    pub fn buffer(&self, max_width: i32, max_height: i32, format: &babl::Object) -> Option<gegl::Buffer> {
        unsafe {
            from_glib_full(ffi::gimp_brush_get_buffer(self.to_glib_none().0, max_width, max_height, format.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_brush_get_hardness")]
    #[doc(alias = "get_hardness")]
    pub fn hardness(&self) -> Option<f64> {
        unsafe {
            let mut hardness = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_get_hardness(self.to_glib_none().0, hardness.as_mut_ptr()));
            if ret { Some(hardness.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_get_info")]
    #[doc(alias = "get_info")]
    pub fn info(&self) -> Option<(i32, i32, i32, i32)> {
        unsafe {
            let mut width = std::mem::MaybeUninit::uninit();
            let mut height = std::mem::MaybeUninit::uninit();
            let mut mask_bpp = std::mem::MaybeUninit::uninit();
            let mut color_bpp = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_get_info(self.to_glib_none().0, width.as_mut_ptr(), height.as_mut_ptr(), mask_bpp.as_mut_ptr(), color_bpp.as_mut_ptr()));
            if ret { Some((width.assume_init(), height.assume_init(), mask_bpp.assume_init(), color_bpp.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_get_mask")]
    #[doc(alias = "get_mask")]
    pub fn mask(&self, max_width: i32, max_height: i32, format: &babl::Object) -> Option<gegl::Buffer> {
        unsafe {
            from_glib_full(ffi::gimp_brush_get_mask(self.to_glib_none().0, max_width, max_height, format.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_brush_get_radius")]
    #[doc(alias = "get_radius")]
    pub fn radius(&self) -> Option<f64> {
        unsafe {
            let mut radius = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_get_radius(self.to_glib_none().0, radius.as_mut_ptr()));
            if ret { Some(radius.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_get_shape")]
    #[doc(alias = "get_shape")]
    pub fn shape(&self) -> Option<BrushGeneratedShape> {
        unsafe {
            let mut shape = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_get_shape(self.to_glib_none().0, shape.as_mut_ptr()));
            if ret { Some(from_glib(shape.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_get_spacing")]
    #[doc(alias = "get_spacing")]
    pub fn spacing(&self) -> i32 {
        unsafe {
            ffi::gimp_brush_get_spacing(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_brush_get_spikes")]
    #[doc(alias = "get_spikes")]
    pub fn spikes(&self) -> Option<i32> {
        unsafe {
            let mut spikes = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_get_spikes(self.to_glib_none().0, spikes.as_mut_ptr()));
            if ret { Some(spikes.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_is_generated")]
    pub fn is_generated(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_brush_is_generated(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_brush_set_angle")]
    pub fn set_angle(&self, angle_in: f64) -> Option<f64> {
        unsafe {
            let mut angle_out = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_set_angle(self.to_glib_none().0, angle_in, angle_out.as_mut_ptr()));
            if ret { Some(angle_out.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_set_aspect_ratio")]
    pub fn set_aspect_ratio(&self, aspect_ratio_in: f64) -> Option<f64> {
        unsafe {
            let mut aspect_ratio_out = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_set_aspect_ratio(self.to_glib_none().0, aspect_ratio_in, aspect_ratio_out.as_mut_ptr()));
            if ret { Some(aspect_ratio_out.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_set_hardness")]
    pub fn set_hardness(&self, hardness_in: f64) -> Option<f64> {
        unsafe {
            let mut hardness_out = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_set_hardness(self.to_glib_none().0, hardness_in, hardness_out.as_mut_ptr()));
            if ret { Some(hardness_out.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_set_radius")]
    pub fn set_radius(&self, radius_in: f64) -> Option<f64> {
        unsafe {
            let mut radius_out = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_set_radius(self.to_glib_none().0, radius_in, radius_out.as_mut_ptr()));
            if ret { Some(radius_out.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_set_shape")]
    pub fn set_shape(&self, shape_in: BrushGeneratedShape) -> Option<BrushGeneratedShape> {
        unsafe {
            let mut shape_out = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_set_shape(self.to_glib_none().0, shape_in.into_glib(), shape_out.as_mut_ptr()));
            if ret { Some(from_glib(shape_out.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_set_spacing")]
    pub fn set_spacing(&self, spacing: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_brush_set_spacing(self.to_glib_none().0, spacing))
        }
    }

    #[doc(alias = "gimp_brush_set_spikes")]
    pub fn set_spikes(&self, spikes_in: i32) -> Option<i32> {
        unsafe {
            let mut spikes_out = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_brush_set_spikes(self.to_glib_none().0, spikes_in, spikes_out.as_mut_ptr()));
            if ret { Some(spikes_out.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_brush_get_by_name")]
    #[doc(alias = "get_by_name")]
    pub fn by_name(name: &str) -> Option<Brush> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_brush_get_by_name(name.to_glib_none().0))
        }
    }
}
