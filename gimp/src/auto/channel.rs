// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,ChannelOps,ChannelType,Drawable,Image,Item};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "GimpChannel")]
    pub struct Channel(Object<ffi::GimpChannel, ffi::GimpChannelClass>) @extends Drawable, Item;

    match fn {
        type_ => || ffi::gimp_channel_get_type(),
    }
}

impl Channel {
        pub const NONE: Option<&'static Channel> = None;
    

    #[doc(alias = "gimp_channel_new")]
    pub fn new(image: &Image, name: &str, width: i32, height: i32, opacity: f64, color: &impl IsA<gegl::Color>) -> Channel {
        skip_assert_initialized!();
        unsafe {
            from_glib_none(ffi::gimp_channel_new(image.to_glib_none().0, name.to_glib_none().0, width, height, opacity, color.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_channel_new_from_component")]
    #[doc(alias = "new_from_component")]
    pub fn from_component(image: &Image, component: ChannelType, name: &str) -> Channel {
        skip_assert_initialized!();
        unsafe {
            from_glib_none(ffi::gimp_channel_new_from_component(image.to_glib_none().0, component.into_glib(), name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_channel_get_by_id")]
    #[doc(alias = "get_by_id")]
    pub fn by_id(channel_id: i32) -> Option<Channel> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_channel_get_by_id(channel_id))
        }
    }
}

pub trait ChannelExt: IsA<Channel> + 'static {
    #[doc(alias = "gimp_channel_combine_masks")]
    fn combine_masks(&self, channel2: &impl IsA<Channel>, operation: ChannelOps, offx: i32, offy: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_channel_combine_masks(self.as_ref().to_glib_none().0, channel2.as_ref().to_glib_none().0, operation.into_glib(), offx, offy))
        }
    }

    #[doc(alias = "gimp_channel_copy")]
#[must_use]
    fn copy(&self) -> Option<Channel> {
        unsafe {
            from_glib_none(ffi::gimp_channel_copy(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_channel_get_color")]
    #[doc(alias = "get_color")]
    fn color(&self) -> Option<gegl::Color> {
        unsafe {
            from_glib_full(ffi::gimp_channel_get_color(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_channel_get_opacity")]
    #[doc(alias = "get_opacity")]
    fn opacity(&self) -> f64 {
        unsafe {
            ffi::gimp_channel_get_opacity(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_channel_get_show_masked")]
    #[doc(alias = "get_show_masked")]
    fn shows_masked(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_channel_get_show_masked(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_channel_set_color")]
    fn set_color(&self, color: &impl IsA<gegl::Color>) -> bool {
        unsafe {
            from_glib(ffi::gimp_channel_set_color(self.as_ref().to_glib_none().0, color.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_channel_set_opacity")]
    fn set_opacity(&self, opacity: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_channel_set_opacity(self.as_ref().to_glib_none().0, opacity))
        }
    }

    #[doc(alias = "gimp_channel_set_show_masked")]
    fn set_show_masked(&self, show_masked: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_channel_set_show_masked(self.as_ref().to_glib_none().0, show_masked.into_glib()))
        }
    }
}

impl<O: IsA<Channel>> ChannelExt for O {}
