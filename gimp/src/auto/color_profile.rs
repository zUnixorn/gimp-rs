// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    /// Definitions and Functions relating to LCMS.
    #[doc(alias = "GimpColorProfile")]
    pub struct ColorProfile(Object<ffi::GimpColorProfile, ffi::GimpColorProfileClass>);

    match fn {
        type_ => || ffi::gimp_color_profile_get_type(),
    }
}

impl ColorProfile {
    /// This function creates a grayscale [`ColorProfile`][crate::ColorProfile] with the
    /// D50 ICC profile illuminant as the profile white point and the
    /// LAB companding curve as the TRC.
    ///
    /// # Returns
    ///
    /// a gray profile with the D50 ICC profile illuminant
    /// as the profile white point and the LAB companding curve as the TRC.
    /// as the TRC.
    #[doc(alias = "gimp_color_profile_new_d50_gray_lab_trc")]
    pub fn new_d50_gray_lab_trc() -> ColorProfile {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_d50_gray_lab_trc())
        }
    }

    #[doc(alias = "gimp_color_profile_new_d65_gray_linear")]
    pub fn new_d65_gray_linear() -> ColorProfile {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_d65_gray_linear())
        }
    }

    /// This function creates a grayscale [`ColorProfile`][crate::ColorProfile] with an
    /// sRGB TRC. See [`new_rgb_srgb()`][Self::new_rgb_srgb()].
    ///
    /// # Returns
    ///
    /// the sRGB-gamma grayscale [`ColorProfile`][crate::ColorProfile].
    #[doc(alias = "gimp_color_profile_new_d65_gray_srgb_trc")]
    pub fn new_d65_gray_srgb_trc() -> ColorProfile {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_d65_gray_srgb_trc())
        }
    }

    /// This function opens an ICC color profile from `file`.
    /// ## `file`
    /// a [`gio::File`][crate::gio::File]
    ///
    /// # Returns
    ///
    /// the [`ColorProfile`][crate::ColorProfile], or [`None`]. On error, [`None`] is
    ///  returned and `error` is set.
    #[doc(alias = "gimp_color_profile_new_from_file")]
    #[doc(alias = "new_from_file")]
    pub fn from_file(file: &impl IsA<gio::File>) -> Result<Option<ColorProfile>, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::gimp_color_profile_new_from_file(file.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    /// This function opens an ICC color profile from memory. On error,
    /// [`None`] is returned and `error` is set.
    /// ## `data`
    /// The memory containing an ICC profile
    ///
    /// # Returns
    ///
    /// the [`ColorProfile`][crate::ColorProfile], or [`None`].
    #[doc(alias = "gimp_color_profile_new_from_icc_profile")]
    #[doc(alias = "new_from_icc_profile")]
    pub fn from_icc_profile(data: &[u8]) -> Result<Option<ColorProfile>, glib::Error> {
        assert_initialized_main_thread!();
        let length = data.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::gimp_color_profile_new_from_icc_profile(data.to_glib_none().0, length, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    //#[doc(alias = "gimp_color_profile_new_from_lcms_profile")]
    //#[doc(alias = "new_from_lcms_profile")]
    //pub fn from_lcms_profile(lcms_profile: /*Unimplemented*/Option<Basic: Pointer>) -> Result<Option<ColorProfile>, glib::Error> {
    //    unsafe { TODO: call ffi:gimp_color_profile_new_from_lcms_profile() }
    //}

    /// This function creates a profile compatible with AbobeRGB (1998).
    ///
    /// # Returns
    ///
    /// the AdobeRGB-compatible [`ColorProfile`][crate::ColorProfile].
    #[doc(alias = "gimp_color_profile_new_rgb_adobe")]
    pub fn new_rgb_adobe() -> ColorProfile {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_rgb_adobe())
        }
    }

    /// This function is a replacement for cmsCreate_sRGBProfile() and
    /// returns an sRGB profile that is functionally the same as the
    /// ArgyllCMS sRGB.icm profile. "Functionally the same" means it has
    /// the same red, green, and blue colorants and the V4 "chad"
    /// equivalent of the ArgyllCMS V2 white point. The profile TRC is also
    /// functionally equivalent to the ArgyllCMS sRGB.icm TRC and is the
    /// same as the LCMS sRGB built-in profile TRC.
    ///
    /// The actual primaries in the sRGB specification are
    /// red xy: {0.6400, 0.3300, 1.0}
    /// green xy: {0.3000, 0.6000, 1.0}
    /// blue xy: {0.1500, 0.0600, 1.0}
    ///
    /// The sRGB primaries given below are "pre-quantized" to compensate
    /// for hexadecimal quantization during the profile-making process.
    /// Unless the profile-making code compensates for this quantization,
    /// the resulting profile's red, green, and blue colorants will deviate
    /// slightly from the correct XYZ values.
    ///
    /// LCMS2 doesn't compensate for hexadecimal quantization. The
    /// "pre-quantized" primaries below were back-calculated from the
    /// ArgyllCMS sRGB.icm profile. The resulting sRGB profile's colorants
    /// exactly matches the ArgyllCMS sRGB.icm profile colorants.
    ///
    /// # Returns
    ///
    /// the sRGB [`ColorProfile`][crate::ColorProfile].
    #[doc(alias = "gimp_color_profile_new_rgb_srgb")]
    pub fn new_rgb_srgb() -> ColorProfile {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_rgb_srgb())
        }
    }

    /// This function creates a profile for babl_model("RGB"). Please
    /// somebody write something smarter here.
    ///
    /// # Returns
    ///
    /// the linear RGB [`ColorProfile`][crate::ColorProfile].
    #[doc(alias = "gimp_color_profile_new_rgb_srgb_linear")]
    pub fn new_rgb_srgb_linear() -> ColorProfile {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_rgb_srgb_linear())
        }
    }

    ///
    /// # Returns
    ///
    /// a string containing `self`'s copyright. The
    ///  returned value belongs to `self` and must not be
    ///  modified or freed.
    #[doc(alias = "gimp_color_profile_get_copyright")]
    #[doc(alias = "get_copyright")]
    pub fn copyright(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gimp_color_profile_get_copyright(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// a string containing `self`'s description. The
    ///  returned value belongs to `self` and must not be
    ///  modified or freed.
    #[doc(alias = "gimp_color_profile_get_description")]
    #[doc(alias = "get_description")]
    pub fn description(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gimp_color_profile_get_description(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_color_profile_get_format")]
    //#[doc(alias = "get_format")]
    //pub fn format(&self, format: /*Ignored*/&babl::Object, intent: ColorRenderingIntent) -> Result</*Ignored*/babl::Object, glib::Error> {
    //    unsafe { TODO: call ffi:gimp_color_profile_get_format() }
    //}

    /// This function returns `self` as ICC profile data. The returned
    /// memory belongs to `self` and must not be modified or freed.
    ///
    /// # Returns
    ///
    /// a pointer to the IIC profile data.
    #[doc(alias = "gimp_color_profile_get_icc_profile")]
    #[doc(alias = "get_icc_profile")]
    pub fn icc_profile(&self) -> Vec<u8> {
        unsafe {
            let mut length = std::mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_none_num(ffi::gimp_color_profile_get_icc_profile(self.to_glib_none().0, length.as_mut_ptr()), length.assume_init() as _);
            ret
        }
    }

    /// This function returns a string containing `self`'s "title", a
    /// string that can be used to label the profile in a user interface.
    ///
    /// Unlike [`description()`][Self::description()], this function always
    /// returns a string (as a fallback, it returns "(unnamed profile)").
    ///
    /// # Returns
    ///
    /// the `self`'s label. The returned value belongs to
    ///  `self` and must not be modified or freed.
    #[doc(alias = "gimp_color_profile_get_label")]
    #[doc(alias = "get_label")]
    pub fn label(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gimp_color_profile_get_label(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_color_profile_get_lcms_profile")]
    //#[doc(alias = "get_lcms_profile")]
    //pub fn lcms_profile(&self) -> /*Unimplemented*/Option<Basic: Pointer> {
    //    unsafe { TODO: call ffi:gimp_color_profile_get_lcms_profile() }
    //}

    ///
    /// # Returns
    ///
    /// a string containing `self`'s manufacturer. The
    ///  returned value belongs to `self` and must not be
    ///  modified or freed.
    #[doc(alias = "gimp_color_profile_get_manufacturer")]
    #[doc(alias = "get_manufacturer")]
    pub fn manufacturer(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gimp_color_profile_get_manufacturer(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// a string containing `self`'s model. The returned
    ///  value belongs to `self` and must not be modified or
    ///  freed.
    #[doc(alias = "gimp_color_profile_get_model")]
    #[doc(alias = "get_model")]
    pub fn model(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gimp_color_profile_get_model(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_color_profile_get_space")]
    //#[doc(alias = "get_space")]
    //pub fn space(&self, intent: ColorRenderingIntent) -> Result</*Ignored*/babl::Object, glib::Error> {
    //    unsafe { TODO: call ffi:gimp_color_profile_get_space() }
    //}

    /// This function return a string containing a multi-line summary of
    /// `self`'s description, model, manufacturer and copyright, to be
    /// used as detailed information about the profile in a user
    /// interface.
    ///
    /// # Returns
    ///
    /// the `self`'s summary. The returned value belongs to
    ///  `self` and must not be modified or freed.
    #[doc(alias = "gimp_color_profile_get_summary")]
    #[doc(alias = "get_summary")]
    pub fn summary(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gimp_color_profile_get_summary(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the profile's color space is CMYK, [`false`]
    /// otherwise.
    #[doc(alias = "gimp_color_profile_is_cmyk")]
    pub fn is_cmyk(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_color_profile_is_cmyk(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_color_profile_is_equal")]
    pub fn is_equal(&self, profile2: &ColorProfile) -> bool {
        unsafe {
            from_glib(ffi::gimp_color_profile_is_equal(self.to_glib_none().0, profile2.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the profile's color space is grayscale, [`false`]
    /// otherwise.
    #[doc(alias = "gimp_color_profile_is_gray")]
    pub fn is_gray(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_color_profile_is_gray(self.to_glib_none().0))
        }
    }

    /// This function determines is the ICC profile represented by a GimpColorProfile
    /// is a linear RGB profile or not, some profiles that are LUTs though linear
    /// will also return FALSE;
    ///
    /// # Returns
    ///
    /// [`true`] if the profile is a matrix shaping profile with linear
    /// TRCs, [`false`] otherwise.
    #[doc(alias = "gimp_color_profile_is_linear")]
    pub fn is_linear(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_color_profile_is_linear(self.to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// [`true`] if the profile's color space is RGB, [`false`]
    /// otherwise.
    #[doc(alias = "gimp_color_profile_is_rgb")]
    pub fn is_rgb(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_color_profile_is_rgb(self.to_glib_none().0))
        }
    }

    /// This function creates a new RGB [`ColorProfile`][crate::ColorProfile] with a linear TRC
    /// and `self`'s RGB chromacities and whitepoint.
    ///
    /// # Returns
    ///
    /// the new [`ColorProfile`][crate::ColorProfile], or [`None`] if
    ///  `self` is not an RGB profile or not matrix-based.
    #[doc(alias = "gimp_color_profile_new_linear_from_color_profile")]
#[must_use]
    pub fn new_linear_from_color_profile(&self) -> Option<ColorProfile> {
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_linear_from_color_profile(self.to_glib_none().0))
        }
    }

    /// This function creates a new RGB [`ColorProfile`][crate::ColorProfile] with a sRGB gamma
    /// TRC and `self`'s RGB chromacities and whitepoint.
    ///
    /// # Returns
    ///
    /// the new [`ColorProfile`][crate::ColorProfile], or [`None`] if
    ///  `self` is not an RGB profile or not matrix-based.
    #[doc(alias = "gimp_color_profile_new_srgb_trc_from_color_profile")]
#[must_use]
    pub fn new_srgb_trc_from_color_profile(&self) -> Option<ColorProfile> {
        unsafe {
            from_glib_full(ffi::gimp_color_profile_new_srgb_trc_from_color_profile(self.to_glib_none().0))
        }
    }

    /// This function saves `self` to `file` as ICC profile.
    /// ## `file`
    /// a [`gio::File`][crate::gio::File]
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] if an error occurred.
    #[doc(alias = "gimp_color_profile_save_to_file")]
    pub fn save_to_file(&self, file: &impl IsA<gio::File>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_color_profile_save_to_file(self.to_glib_none().0, file.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    //#[doc(alias = "gimp_color_profile_get_lcms_format")]
    //#[doc(alias = "get_lcms_format")]
    //pub fn lcms_format(format: /*Ignored*/&babl::Object) -> (/*Ignored*/Option<babl::Object>, u32) {
    //    unsafe { TODO: call ffi:gimp_color_profile_get_lcms_format() }
    //}
}
