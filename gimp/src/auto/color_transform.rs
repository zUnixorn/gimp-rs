// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,ColorProfile,ColorRenderingIntent,ColorTransformFlags};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "GimpColorTransform")]
    pub struct ColorTransform(Object<ffi::GimpColorTransform, ffi::GimpColorTransformClass>);

    match fn {
        type_ => || ffi::gimp_color_transform_get_type(),
    }
}

impl ColorTransform {
    #[doc(alias = "gimp_color_transform_new")]
    pub fn new(src_profile: &ColorProfile, src_format: &babl::Object, dest_profile: &ColorProfile, dest_format: &babl::Object, rendering_intent: ColorRenderingIntent, flags: ColorTransformFlags) -> Option<ColorTransform> {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(ffi::gimp_color_transform_new(src_profile.to_glib_none().0, src_format.to_glib_none().0, dest_profile.to_glib_none().0, dest_format.to_glib_none().0, rendering_intent.into_glib(), flags.into_glib()))
        }
    }

    #[doc(alias = "gimp_color_transform_new_proofing")]
    pub fn new_proofing(src_profile: &ColorProfile, src_format: &babl::Object, dest_profile: &ColorProfile, dest_format: &babl::Object, proof_profile: &ColorProfile, proof_intent: ColorRenderingIntent, display_intent: ColorRenderingIntent, flags: ColorTransformFlags) -> Option<ColorTransform> {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(ffi::gimp_color_transform_new_proofing(src_profile.to_glib_none().0, src_format.to_glib_none().0, dest_profile.to_glib_none().0, dest_format.to_glib_none().0, proof_profile.to_glib_none().0, proof_intent.into_glib(), display_intent.into_glib(), flags.into_glib()))
        }
    }

    #[doc(alias = "gimp_color_transform_process_buffer")]
    pub fn process_buffer(&self, src_buffer: &gegl::Buffer, src_rect: &gegl::Rectangle, dest_buffer: &gegl::Buffer, dest_rect: &gegl::Rectangle) {
        unsafe {
            ffi::gimp_color_transform_process_buffer(self.to_glib_none().0, src_buffer.to_glib_none().0, src_rect.to_glib_none().0, dest_buffer.to_glib_none().0, dest_rect.to_glib_none().0);
        }
    }

    //#[doc(alias = "gimp_color_transform_process_pixels")]
    //pub fn process_pixels(&self, src_format: &babl::Object, src_pixels: /*Unimplemented*/Option<Basic: Pointer>, dest_format: &babl::Object, dest_pixels: /*Unimplemented*/Option<Basic: Pointer>, length: usize) {
    //    unsafe { TODO: call ffi:gimp_color_transform_process_pixels() }
    //}

    #[doc(alias = "gimp_color_transform_can_gegl_copy")]
    pub fn can_gegl_copy(src_profile: &ColorProfile, dest_profile: &ColorProfile) -> bool {
        skip_assert_initialized!();
        unsafe {
            from_glib(ffi::gimp_color_transform_can_gegl_copy(src_profile.to_glib_none().0, dest_profile.to_glib_none().0))
        }
    }

    #[doc(alias = "progress")]
    pub fn connect_progress<F: Fn(&Self, f64) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn progress_trampoline<F: Fn(&ColorTransform, f64) + 'static>(this: *mut ffi::GimpColorTransform, object: std::ffi::c_double, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), object)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"progress".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(progress_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}
