// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,DesaturateMode,DrawableFilter,FillType,ForegroundExtractMode,GradientType,HistogramChannel,HueRange,ImageType,Item,OffsetType,PixbufTransparency,TransferMode};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    /// Functions to manipulate drawables.
    ///
    /// This is an Abstract Base Class, you cannot instantiate it.
    ///
    /// # Implements
    ///
    /// [`DrawableExt`][trait@crate::prelude::DrawableExt], [`ItemExt`][trait@crate::prelude::ItemExt], [`trait@glib::ObjectExt`]
    #[doc(alias = "GimpDrawable")]
    pub struct Drawable(Object<ffi::GimpDrawable, ffi::GimpDrawableClass>) @extends Item;

    match fn {
        type_ => || ffi::gimp_drawable_get_type(),
    }
}

impl Drawable {
        pub const NONE: Option<&'static Drawable> = None;
    

    /// Returns a [`Drawable`][crate::Drawable] representing `drawable_id`. This function
    /// calls [`Item::by_id()`][crate::Item::by_id()] and returns the item if it is drawable
    /// or [`None`] otherwise.
    /// ## `drawable_id`
    /// The drawable id.
    ///
    /// # Returns
    ///
    /// a [`Drawable`][crate::Drawable] for
    ///  `drawable_id` or [`None`] if `drawable_id` does not represent a
    ///  valid drawable. The object belongs to libgimp and you must
    ///  not modify or unref it.
    #[doc(alias = "gimp_drawable_get_by_id")]
    #[doc(alias = "get_by_id")]
    pub fn by_id(drawable_id: i32) -> Option<Drawable> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_drawable_get_by_id(drawable_id))
        }
    }
}

/// Trait containing all [`struct@Drawable`] methods.
///
/// # Implementors
///
/// [`Channel`][struct@crate::Channel], [`Drawable`][struct@crate::Drawable], [`Layer`][struct@crate::Layer]
pub trait DrawableExt: IsA<Drawable> + 'static {
    /// This procedure appends the specified drawable effect at the top of the
    /// effect list of `self`.
    ///
    /// The `self` argument must be the same as the one used when you
    /// created the effect with [ctor`Gimp`.new].
    /// Some effects may be slower than others to render. In order to
    /// minimize processing time, it is preferred to customize the
    /// operation's arguments as received with
    /// [method`Gimp`.get_config] before adding the effect.
    /// ## `filter`
    /// The drawable filter to append.
    #[doc(alias = "gimp_drawable_append_filter")]
    fn append_filter(&self, filter: &DrawableFilter) {
        unsafe {
            ffi::gimp_drawable_append_filter(self.as_ref().to_glib_none().0, filter.to_glib_none().0);
        }
    }

    //#[doc(alias = "gimp_drawable_append_new_filter")]
    //fn append_new_filter(&self, operation_name: &str, name: &str, mode: LayerMode, opacity: f64, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<DrawableFilter> {
    //    unsafe { TODO: call ffi:gimp_drawable_append_new_filter() }
    //}

    /// Modify brightness/contrast in the specified drawable.
    ///
    /// This procedures allows the brightness and contrast of the specified
    /// drawable to be modified. Both 'brightness' and 'contrast' parameters
    /// are defined between -1.0 and 1.0.
    /// ## `brightness`
    /// Brightness adjustment.
    /// ## `contrast`
    /// Contrast adjustment.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_brightness_contrast")]
    fn brightness_contrast(&self, brightness: f64, contrast: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_brightness_contrast(self.as_ref().to_glib_none().0, brightness, contrast))
        }
    }

    /// Modify the color balance of the specified drawable.
    ///
    /// Modify the color balance of the specified drawable. There are three
    /// axis which can be modified: cyan-red, magenta-green, and
    /// yellow-blue. Negative values increase the amount of the former,
    /// positive values increase the amount of the latter. Color balance can
    /// be controlled with the 'transfer_mode' setting, which allows
    /// shadows, mid-tones, and highlights in an image to be affected
    /// differently. The 'preserve-lum' parameter, if TRUE, ensures that the
    /// luminosity of each pixel remains fixed.
    /// ## `transfer_mode`
    /// Transfer mode.
    /// ## `preserve_lum`
    /// Preserve luminosity values at each pixel.
    /// ## `cyan_red`
    /// Cyan-Red color balance.
    /// ## `magenta_green`
    /// Magenta-Green color balance.
    /// ## `yellow_blue`
    /// Yellow-Blue color balance.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_color_balance")]
    fn color_balance(&self, transfer_mode: TransferMode, preserve_lum: bool, cyan_red: f64, magenta_green: f64, yellow_blue: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_color_balance(self.as_ref().to_glib_none().0, transfer_mode.into_glib(), preserve_lum.into_glib(), cyan_red, magenta_green, yellow_blue))
        }
    }

    /// Render the drawable as a grayscale image seen through a colored
    /// glass.
    ///
    /// Desaturates the drawable, then tints it with the specified color.
    /// This tool is only valid on RGB color images. It will not operate on
    /// grayscale drawables.
    /// ## `hue`
    /// Hue in degrees.
    /// ## `saturation`
    /// Saturation in percent.
    /// ## `lightness`
    /// Lightness in percent.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_colorize_hsl")]
    fn colorize_hsl(&self, hue: f64, saturation: f64, lightness: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_colorize_hsl(self.as_ref().to_glib_none().0, hue, saturation, lightness))
        }
    }

    /// Modifies the intensity curve(s) for specified drawable.
    ///
    /// Modifies the intensity mapping for one channel in the specified
    /// drawable. The channel can be either an intensity component, or the
    /// value. The 'values' parameter is an array of doubles which
    /// explicitly defines how each pixel value in the drawable will be
    /// modified. Use the [`curves_spline()`][Self::curves_spline()] function to modify
    /// intensity levels with Catmull Rom splines.
    /// ## `channel`
    /// The channel to modify.
    /// ## `values`
    /// The explicit curve.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_curves_explicit")]
    fn curves_explicit(&self, channel: HistogramChannel, values: &[f64]) -> bool {
        let num_values = values.len() as _;
        unsafe {
            from_glib(ffi::gimp_drawable_curves_explicit(self.as_ref().to_glib_none().0, channel.into_glib(), num_values, values.to_glib_none().0))
        }
    }

    /// Modifies the intensity curve(s) for specified drawable.
    ///
    /// Modifies the intensity mapping for one channel in the specified
    /// drawable. The channel can be either an intensity component, or the
    /// value. The 'points' parameter is an array of doubles which define a
    /// set of control points which describe a Catmull Rom spline which
    /// yields the final intensity curve. Use the
    /// [`curves_explicit()`][Self::curves_explicit()] function to explicitly modify
    /// intensity levels.
    /// ## `channel`
    /// The channel to modify.
    /// ## `points`
    /// The spline control points: { cp1.x, cp1.y, cp2.x, cp2.y, ... }.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_curves_spline")]
    fn curves_spline(&self, channel: HistogramChannel, points: &[f64]) -> bool {
        let num_points = points.len() as _;
        unsafe {
            from_glib(ffi::gimp_drawable_curves_spline(self.as_ref().to_glib_none().0, channel.into_glib(), num_points, points.to_glib_none().0))
        }
    }

    /// Desaturate the contents of the specified drawable, with the
    /// specified formula.
    ///
    /// This procedure desaturates the contents of the specified drawable,
    /// with the specified formula. This procedure only works on drawables
    /// of type RGB color.
    /// ## `desaturate_mode`
    /// The formula to use to desaturate.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_desaturate")]
    fn desaturate(&self, desaturate_mode: DesaturateMode) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_desaturate(self.as_ref().to_glib_none().0, desaturate_mode.into_glib()))
        }
    }

    /// Fill the area by a seed fill starting at the specified coordinates.
    ///
    /// This procedure does a seed fill at the specified coordinates, using
    /// various parameters from the current context.
    /// In the case of merged sampling, the x and y coordinates are relative
    /// to the image's origin; otherwise, they are relative to the
    /// drawable's origin.
    ///
    /// This procedure is affected by the following context setters:
    /// [`context_set_opacity()`][crate::context_set_opacity()], [`context_set_paint_mode()`][crate::context_set_paint_mode()],
    /// [`context_set_foreground()`][crate::context_set_foreground()], [`context_set_background()`][crate::context_set_background()],
    /// [`context_set_pattern()`][crate::context_set_pattern()], [`context_set_sample_threshold()`][crate::context_set_sample_threshold()],
    /// [`context_set_sample_merged()`][crate::context_set_sample_merged()],
    /// [`context_set_sample_criterion()`][crate::context_set_sample_criterion()],
    /// [`context_set_diagonal_neighbors()`][crate::context_set_diagonal_neighbors()], [`context_set_antialias()`][crate::context_set_antialias()].
    /// ## `fill_type`
    /// The type of fill.
    /// ## `x`
    /// The x coordinate of this bucket fill's application.
    /// ## `y`
    /// The y coordinate of this bucket fill's application.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_edit_bucket_fill")]
    fn edit_bucket_fill(&self, fill_type: FillType, x: f64, y: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_bucket_fill(self.as_ref().to_glib_none().0, fill_type.into_glib(), x, y))
        }
    }

    /// Clear selected area of drawable.
    ///
    /// This procedure clears the specified drawable. If the drawable has an
    /// alpha channel, the cleared pixels will become transparent. If the
    /// drawable does not have an alpha channel, cleared pixels will be set
    /// to the background color. This procedure only affects regions within
    /// a selection if there is a selection active.
    ///
    /// This procedure is affected by the following context setters:
    /// [`context_set_background()`][crate::context_set_background()].
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_edit_clear")]
    fn edit_clear(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_clear(self.as_ref().to_glib_none().0))
        }
    }

    /// Fill selected area of drawable.
    ///
    /// This procedure fills the specified drawable according to fill mode.
    /// This procedure only affects regions within a selection if there is a
    /// selection active. If you want to fill the whole drawable, regardless
    /// of the selection, use [`fill()`][Self::fill()].
    ///
    /// This procedure is affected by the following context setters:
    /// [`context_set_opacity()`][crate::context_set_opacity()], [`context_set_paint_mode()`][crate::context_set_paint_mode()],
    /// [`context_set_foreground()`][crate::context_set_foreground()], [`context_set_background()`][crate::context_set_background()],
    /// [`context_set_pattern()`][crate::context_set_pattern()].
    /// ## `fill_type`
    /// The type of fill.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_edit_fill")]
    fn edit_fill(&self, fill_type: FillType) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_fill(self.as_ref().to_glib_none().0, fill_type.into_glib()))
        }
    }

    /// Draw a gradient between the starting and ending coordinates with the
    /// specified gradient type.
    ///
    /// This tool requires information on the gradient type. It creates the
    /// specified variety of gradient using the starting and ending
    /// coordinates as defined for each gradient type. For shapeburst
    /// gradient types, the context's distance metric is also relevant and
    /// can be updated with [`context_set_distance_metric()`][crate::context_set_distance_metric()].
    ///
    /// This procedure is affected by the following context setters:
    /// [`context_set_opacity()`][crate::context_set_opacity()], [`context_set_paint_mode()`][crate::context_set_paint_mode()],
    /// [`context_set_foreground()`][crate::context_set_foreground()], [`context_set_background()`][crate::context_set_background()],
    /// [`context_set_gradient()`][crate::context_set_gradient()] and all gradient property settings,
    /// [`context_set_distance_metric()`][crate::context_set_distance_metric()].
    /// ## `gradient_type`
    /// The type of gradient.
    /// ## `offset`
    /// Offset relates to the starting and ending coordinates specified for the blend. This parameter is mode dependent.
    /// ## `supersample`
    /// Do adaptive supersampling.
    /// ## `supersample_max_depth`
    /// Maximum recursion levels for supersampling.
    /// ## `supersample_threshold`
    /// Supersampling threshold.
    /// ## `dither`
    /// Use dithering to reduce banding.
    /// ## `x1`
    /// The x coordinate of this gradient's starting point.
    /// ## `y1`
    /// The y coordinate of this gradient's starting point.
    /// ## `x2`
    /// The x coordinate of this gradient's ending point.
    /// ## `y2`
    /// The y coordinate of this gradient's ending point.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_edit_gradient_fill")]
    fn edit_gradient_fill(&self, gradient_type: GradientType, offset: f64, supersample: bool, supersample_max_depth: i32, supersample_threshold: f64, dither: bool, x1: f64, y1: f64, x2: f64, y2: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_gradient_fill(self.as_ref().to_glib_none().0, gradient_type.into_glib(), offset, supersample.into_glib(), supersample_max_depth, supersample_threshold, dither.into_glib(), x1, y1, x2, y2))
        }
    }

    /// Stroke the specified item
    ///
    /// This procedure strokes the specified item, painting along its
    /// outline (e.g. along a path, or along a channel's boundary), with the
    /// active paint method and brush, or using a plain line with
    /// configurable properties.
    ///
    /// This procedure is affected by the following context setters:
    /// [`context_set_opacity()`][crate::context_set_opacity()], [`context_set_paint_mode()`][crate::context_set_paint_mode()],
    /// [`context_set_paint_method()`][crate::context_set_paint_method()], [`context_set_stroke_method()`][crate::context_set_stroke_method()],
    /// [`context_set_foreground()`][crate::context_set_foreground()], [`context_set_brush()`][crate::context_set_brush()] and all
    /// brush property settings, [`context_set_gradient()`][crate::context_set_gradient()] and all
    /// gradient property settings, [`context_set_line_width()`][crate::context_set_line_width()] and all
    /// line property settings, [`context_set_antialias()`][crate::context_set_antialias()].
    /// ## `item`
    /// The item to stroke.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_edit_stroke_item")]
    fn edit_stroke_item(&self, item: &impl IsA<Item>) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_stroke_item(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Stroke the current selection
    ///
    /// This procedure strokes the current selection, painting along the
    /// selection boundary with the active paint method and brush, or using
    /// a plain line with configurable properties. The paint is applied to
    /// the specified drawable regardless of the active selection.
    ///
    /// This procedure is affected by the following context setters:
    /// [`context_set_opacity()`][crate::context_set_opacity()], [`context_set_paint_mode()`][crate::context_set_paint_mode()],
    /// [`context_set_paint_method()`][crate::context_set_paint_method()], [`context_set_stroke_method()`][crate::context_set_stroke_method()],
    /// [`context_set_foreground()`][crate::context_set_foreground()], [`context_set_brush()`][crate::context_set_brush()] and all
    /// brush property settings, [`context_set_gradient()`][crate::context_set_gradient()] and all
    /// gradient property settings, [`context_set_line_width()`][crate::context_set_line_width()] and all
    /// line property settings, [`context_set_antialias()`][crate::context_set_antialias()].
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_edit_stroke_selection")]
    fn edit_stroke_selection(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_stroke_selection(self.as_ref().to_glib_none().0))
        }
    }

    /// Equalize the contents of the specified drawable.
    ///
    /// This procedure equalizes the contents of the specified drawable.
    /// Each intensity channel is equalized independently. The equalized
    /// intensity is given as inten' = (255 - inten). The 'mask_only' option
    /// specifies whether to adjust only the area of the image within the
    /// selection bounds, or the entire image based on the histogram of the
    /// selected area. If there is no selection, the entire image is
    /// adjusted based on the histogram for the entire image.
    /// ## `mask_only`
    /// Equalization option.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_equalize")]
    fn equalize(&self, mask_only: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_equalize(self.as_ref().to_glib_none().0, mask_only.into_glib()))
        }
    }

    /// Extract a color model component.
    ///
    /// Extract a color model component.
    /// ## `component`
    /// Component (RGB Red (0), RGB Green (1), RGB Blue (2), Hue (3), HSV Saturation (4), HSV Value (5), HSL Saturation (6), HSL Lightness (7), CMYK Cyan (8), CMYK Magenta (9), CMYK Yellow (10), CMYK Key (11), Y'CbCr Y' (12), Y'CbCr Cb (13), Y'CbCr Cr (14), LAB L (15), LAB A (16), LAB B (17), LCH C(ab) (18), LCH H(ab) (19), Alpha (20)).
    /// ## `invert`
    /// Invert the extracted component.
    /// ## `linear`
    /// Use linear output instead of gamma corrected.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_extract_component")]
    fn extract_component(&self, component: i32, invert: bool, linear: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_extract_component(self.as_ref().to_glib_none().0, component, invert.into_glib(), linear.into_glib()))
        }
    }

    /// Fill the drawable with the specified fill mode.
    ///
    /// This procedure fills the drawable. If the fill mode is foreground
    /// the current foreground color is used. If the fill mode is
    /// background, the current background color is used. If the fill type
    /// is white, then white is used. Transparent fill only affects layers
    /// with an alpha channel, in which case the alpha channel is set to
    /// transparent. If the drawable has no alpha channel, it is filled to
    /// white. No fill leaves the drawable's contents undefined.
    /// This procedure is unlike [`edit_fill()`][Self::edit_fill()] or the bucket
    /// fill tool because it fills regardless of a selection. Its main
    /// purpose is to fill a newly created drawable before adding it to the
    /// image. This operation cannot be undone.
    /// ## `fill_type`
    /// The type of fill.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_fill")]
    fn fill(&self, fill_type: FillType) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_fill(self.as_ref().to_glib_none().0, fill_type.into_glib()))
        }
    }

    /// Extract the foreground of a drawable using a given trimap.
    ///
    /// Image Segmentation by Uniform Color Clustering, see
    /// https://www.inf.fu-berlin.de/inst/pubs/tr-b-05-07.pdf
    /// ## `mode`
    /// The algorithm to use.
    /// ## `mask`
    /// Tri-Map.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_foreground_extract")]
    fn foreground_extract(&self, mode: ForegroundExtractMode, mask: &impl IsA<Drawable>) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_foreground_extract(self.as_ref().to_glib_none().0, mode.into_glib(), mask.as_ref().to_glib_none().0))
        }
    }

    /// Free the specified drawable's shadow data (if it exists).
    ///
    /// This procedure is intended as a memory saving device. If any shadow
    /// memory has been allocated, it will be freed automatically when the
    /// drawable is removed from the image, or when the plug-in procedure
    /// which allocated it returns.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_free_shadow")]
    fn free_shadow(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_free_shadow(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the bytes per pixel.
    ///
    /// This procedure returns the number of bytes per pixel.
    ///
    /// # Returns
    ///
    /// Bytes per pixel.
    #[doc(alias = "gimp_drawable_get_bpp")]
    #[doc(alias = "get_bpp")]
    fn bpp(&self) -> i32 {
        unsafe {
            ffi::gimp_drawable_get_bpp(self.as_ref().to_glib_none().0)
        }
    }

    /// Returns a [`gegl::Buffer`][crate::gegl::Buffer] of a specified drawable. The buffer can be used
    /// like any other GEGL buffer. Its data will we synced back with the core
    /// drawable when the buffer gets destroyed, or when [`Buffer::flush()`][crate::gegl::Buffer::flush()]
    /// is called.
    ///
    /// # Returns
    ///
    /// The [`gegl::Buffer`][crate::gegl::Buffer].
    ///
    /// See Also: [`shadow_buffer()`][Self::shadow_buffer()]
    #[doc(alias = "gimp_drawable_get_buffer")]
    #[doc(alias = "get_buffer")]
    fn buffer(&self) -> Option<gegl::Buffer> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_buffer(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the list of filters applied to the drawable.
    ///
    /// This procedure returns the list of filters which are currently
    /// applied non-destructively to `self`. The order of filters is from
    /// topmost to bottommost.
    ///
    /// # Returns
    ///
    ///
    ///  The list of filters on the drawable.
    ///  The returned value must be freed with `g_free()`.
    #[doc(alias = "gimp_drawable_get_filters")]
    #[doc(alias = "get_filters")]
    fn filters(&self) -> Vec<DrawableFilter> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_drawable_get_filters(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the `Babl` format of the drawable.
    ///
    /// # Returns
    ///
    /// The `Babl` format.
    #[doc(alias = "gimp_drawable_get_format")]
    #[doc(alias = "get_format")]
    fn format(&self) -> Option<babl::Object> {
        unsafe {
            from_glib_none(ffi::gimp_drawable_get_format(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the height of the drawable.
    ///
    /// This procedure returns the specified drawable's height in pixels.
    ///
    /// # Returns
    ///
    /// Height of drawable.
    #[doc(alias = "gimp_drawable_get_height")]
    #[doc(alias = "get_height")]
    fn height(&self) -> i32 {
        unsafe {
            ffi::gimp_drawable_get_height(self.as_ref().to_glib_none().0)
        }
    }

    /// Returns the offsets for the drawable.
    ///
    /// This procedure returns the specified drawable's offsets. This only
    /// makes sense if the drawable is a layer since channels are anchored.
    /// The offsets of a channel will be returned as 0.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    ///
    /// ## `offset_x`
    /// x offset of drawable.
    ///
    /// ## `offset_y`
    /// y offset of drawable.
    #[doc(alias = "gimp_drawable_get_offsets")]
    #[doc(alias = "get_offsets")]
    fn offsets(&self) -> Option<(i32, i32)> {
        unsafe {
            let mut offset_x = std::mem::MaybeUninit::uninit();
            let mut offset_y = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_get_offsets(self.as_ref().to_glib_none().0, offset_x.as_mut_ptr(), offset_y.as_mut_ptr()));
            if ret { Some((offset_x.assume_init(), offset_y.assume_init())) } else { None }
        }
    }

    /// Gets the value of the pixel at the specified coordinates.
    ///
    /// This procedure gets the pixel value at the specified coordinates.
    /// ## `x_coord`
    /// The x coordinate.
    /// ## `y_coord`
    /// The y coordinate.
    ///
    /// # Returns
    ///
    /// The pixel color.
    #[doc(alias = "gimp_drawable_get_pixel")]
    #[doc(alias = "get_pixel")]
    fn pixel(&self, x_coord: i32, y_coord: i32) -> Option<gegl::Color> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_pixel(self.as_ref().to_glib_none().0, x_coord, y_coord))
        }
    }

    /// Returns a [`gegl::Buffer`][crate::gegl::Buffer] of a specified drawable's shadow tiles. The
    /// buffer can be used like any other GEGL buffer. Its data will we
    /// synced back with the core drawable's shadow tiles when the buffer
    /// gets destroyed, or when [`Buffer::flush()`][crate::gegl::Buffer::flush()] is called.
    ///
    /// # Returns
    ///
    /// The [`gegl::Buffer`][crate::gegl::Buffer].
    #[doc(alias = "gimp_drawable_get_shadow_buffer")]
    #[doc(alias = "get_shadow_buffer")]
    fn shadow_buffer(&self) -> Option<gegl::Buffer> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_shadow_buffer(self.as_ref().to_glib_none().0))
        }
    }

    /// Retrieves a thumbnail pixbuf for the drawable identified by
    /// `self`. The thumbnail will be not larger than the requested
    /// size.
    /// ## `src_x`
    /// the x coordinate of the area
    /// ## `src_y`
    /// the y coordinate of the area
    /// ## `src_width`
    /// the width of the area
    /// ## `src_height`
    /// the height of the area
    /// ## `dest_width`
    /// the requested thumbnail width (<= 1024 pixels)
    /// ## `dest_height`
    /// the requested thumbnail height (<= 1024 pixels)
    /// ## `alpha`
    /// how to handle an alpha channel
    ///
    /// # Returns
    ///
    /// a new [`gdk_pixbuf::Pixbuf`][crate::gdk_pixbuf::Pixbuf]
    #[doc(alias = "gimp_drawable_get_sub_thumbnail")]
    #[doc(alias = "get_sub_thumbnail")]
    fn sub_thumbnail(&self, src_x: i32, src_y: i32, src_width: i32, src_height: i32, dest_width: i32, dest_height: i32, alpha: PixbufTransparency) -> Option<gdk_pixbuf::Pixbuf> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_sub_thumbnail(self.as_ref().to_glib_none().0, src_x, src_y, src_width, src_height, dest_width, dest_height, alpha.into_glib()))
        }
    }

    /// Retrieves thumbnail data for the drawable identified by `self`.
    /// The thumbnail will be not larger than the requested size.
    /// ## `src_x`
    /// the x coordinate of the area
    /// ## `src_y`
    /// the y coordinate of the area
    /// ## `src_width`
    /// the width of the area
    /// ## `src_height`
    /// the height of the area
    /// ## `dest_width`
    /// the requested thumbnail width (<= 1024 pixels)
    /// ## `dest_height`
    /// the requested thumbnail height (<= 1024 pixels)
    ///
    /// # Returns
    ///
    /// thumbnail data or [`None`] if
    ///  `self` is invalid.
    ///
    /// ## `actual_width`
    /// the width of the returned thumbnail
    ///
    /// ## `actual_height`
    /// the height of the returned thumbnail
    ///
    /// ## `bpp`
    /// the bytes per pixel of the returned thumbnail data
    #[doc(alias = "gimp_drawable_get_sub_thumbnail_data")]
    #[doc(alias = "get_sub_thumbnail_data")]
    fn sub_thumbnail_data(&self, src_x: i32, src_y: i32, src_width: i32, src_height: i32, dest_width: i32, dest_height: i32) -> (glib::Bytes, i32, i32, i32) {
        unsafe {
            let mut actual_width = std::mem::MaybeUninit::uninit();
            let mut actual_height = std::mem::MaybeUninit::uninit();
            let mut bpp = std::mem::MaybeUninit::uninit();
            let ret = from_glib_full(ffi::gimp_drawable_get_sub_thumbnail_data(self.as_ref().to_glib_none().0, src_x, src_y, src_width, src_height, dest_width, dest_height, actual_width.as_mut_ptr(), actual_height.as_mut_ptr(), bpp.as_mut_ptr()));
            (ret, actual_width.assume_init(), actual_height.assume_init(), bpp.assume_init())
        }
    }

    /// Retrieves a thumbnail pixbuf for the drawable identified by
    /// `self`. The thumbnail will be not larger than the requested
    /// size.
    /// ## `width`
    /// the requested thumbnail width (<= 1024 pixels)
    /// ## `height`
    /// the requested thumbnail height (<= 1024 pixels)
    /// ## `alpha`
    /// how to handle an alpha channel
    ///
    /// # Returns
    ///
    /// a new [`gdk_pixbuf::Pixbuf`][crate::gdk_pixbuf::Pixbuf]
    #[doc(alias = "gimp_drawable_get_thumbnail")]
    #[doc(alias = "get_thumbnail")]
    fn thumbnail(&self, width: i32, height: i32, alpha: PixbufTransparency) -> Option<gdk_pixbuf::Pixbuf> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_thumbnail(self.as_ref().to_glib_none().0, width, height, alpha.into_glib()))
        }
    }

    /// Retrieves thumbnail data for the drawable identified by `self`.
    /// The thumbnail will be not larger than the requested size.
    /// ## `width`
    /// the requested thumbnail width (<= 1024 pixels)
    /// ## `height`
    /// the requested thumbnail height (<= 1024 pixels)
    ///
    /// # Returns
    ///
    /// thumbnail data or [`None`] if
    ///  `self` is invalid.
    ///
    /// ## `actual_width`
    /// the resulting thumbnail's actual width
    ///
    /// ## `actual_height`
    /// the resulting thumbnail's actual height
    ///
    /// ## `bpp`
    /// the bytes per pixel of the returned thubmnail data
    #[doc(alias = "gimp_drawable_get_thumbnail_data")]
    #[doc(alias = "get_thumbnail_data")]
    fn thumbnail_data(&self, width: i32, height: i32) -> (Option<glib::Bytes>, i32, i32, i32) {
        unsafe {
            let mut actual_width = std::mem::MaybeUninit::uninit();
            let mut actual_height = std::mem::MaybeUninit::uninit();
            let mut bpp = std::mem::MaybeUninit::uninit();
            let ret = from_glib_full(ffi::gimp_drawable_get_thumbnail_data(self.as_ref().to_glib_none().0, width, height, actual_width.as_mut_ptr(), actual_height.as_mut_ptr(), bpp.as_mut_ptr()));
            (ret, actual_width.assume_init(), actual_height.assume_init(), bpp.assume_init())
        }
    }

    /// Returns the `Babl` thumbnail format of the drawable.
    ///
    /// # Returns
    ///
    /// The `Babl` thumbnail format.
    #[doc(alias = "gimp_drawable_get_thumbnail_format")]
    #[doc(alias = "get_thumbnail_format")]
    fn thumbnail_format(&self) -> Option<babl::Object> {
        unsafe {
            from_glib_none(ffi::gimp_drawable_get_thumbnail_format(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the width of the drawable.
    ///
    /// This procedure returns the specified drawable's width in pixels.
    ///
    /// # Returns
    ///
    /// Width of drawable.
    #[doc(alias = "gimp_drawable_get_width")]
    #[doc(alias = "get_width")]
    fn width(&self) -> i32 {
        unsafe {
            ffi::gimp_drawable_get_width(self.as_ref().to_glib_none().0)
        }
    }

    /// Returns TRUE if the drawable has an alpha channel.
    ///
    /// This procedure returns whether the specified drawable has an alpha
    /// channel. This can only be true for layers, and the associated type
    /// will be one of: { RGBA , GRAYA, INDEXEDA }.
    ///
    /// # Returns
    ///
    /// Does the drawable have an alpha channel?
    #[doc(alias = "gimp_drawable_has_alpha")]
    fn has_alpha(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_has_alpha(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns information on the intensity histogram for the specified
    /// drawable.
    ///
    /// This tool makes it possible to gather information about the
    /// intensity histogram of a drawable. A channel to examine is first
    /// specified. This can be either value, red, green, or blue, depending
    /// on whether the drawable is of type color or grayscale. Second, a
    /// range of intensities are specified. The [`histogram()`][Self::histogram()]
    /// function returns statistics based on the pixels in the drawable that
    /// fall under this range of values. Mean, standard deviation, median,
    /// number of pixels, and percentile are all returned. Additionally, the
    /// total count of pixels in the image is returned. Counts of pixels are
    /// weighted by any associated alpha values and by the current selection
    /// mask. That is, pixels that lie outside an active selection mask will
    /// not be counted. Similarly, pixels with transparent alpha values will
    /// not be counted. The returned mean, std_dev and median are in the
    /// range (0..255) for 8-bit images or if the plug-in is not
    /// precision-aware, and in the range (0.0..1.0) otherwise.
    /// ## `channel`
    /// The channel to query.
    /// ## `start_range`
    /// Start of the intensity measurement range.
    /// ## `end_range`
    /// End of the intensity measurement range.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    ///
    /// ## `mean`
    /// Mean intensity value.
    ///
    /// ## `std_dev`
    /// Standard deviation of intensity values.
    ///
    /// ## `median`
    /// Median intensity value.
    ///
    /// ## `pixels`
    /// Alpha-weighted pixel count for entire image.
    ///
    /// ## `count`
    /// Alpha-weighted pixel count for range.
    ///
    /// ## `percentile`
    /// Percentile that range falls under.
    #[doc(alias = "gimp_drawable_histogram")]
    fn histogram(&self, channel: HistogramChannel, start_range: f64, end_range: f64) -> Option<(f64, f64, f64, f64, f64, f64)> {
        unsafe {
            let mut mean = std::mem::MaybeUninit::uninit();
            let mut std_dev = std::mem::MaybeUninit::uninit();
            let mut median = std::mem::MaybeUninit::uninit();
            let mut pixels = std::mem::MaybeUninit::uninit();
            let mut count = std::mem::MaybeUninit::uninit();
            let mut percentile = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_histogram(self.as_ref().to_glib_none().0, channel.into_glib(), start_range, end_range, mean.as_mut_ptr(), std_dev.as_mut_ptr(), median.as_mut_ptr(), pixels.as_mut_ptr(), count.as_mut_ptr(), percentile.as_mut_ptr()));
            if ret { Some((mean.assume_init(), std_dev.assume_init(), median.assume_init(), pixels.assume_init(), count.assume_init(), percentile.assume_init())) } else { None }
        }
    }

    /// Modify hue, lightness, and saturation in the specified drawable.
    ///
    /// This procedure allows the hue, lightness, and saturation in the
    /// specified drawable to be modified. The 'hue-range' parameter
    /// provides the capability to limit range of affected hues. The
    /// 'overlap' parameter provides blending into neighboring hue channels
    /// when rendering.
    /// ## `hue_range`
    /// Range of affected hues.
    /// ## `hue_offset`
    /// Hue offset in degrees.
    /// ## `lightness`
    /// Lightness modification.
    /// ## `saturation`
    /// Saturation modification.
    /// ## `overlap`
    /// Overlap other hue channels.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_hue_saturation")]
    fn hue_saturation(&self, hue_range: HueRange, hue_offset: f64, lightness: f64, saturation: f64, overlap: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_hue_saturation(self.as_ref().to_glib_none().0, hue_range.into_glib(), hue_offset, lightness, saturation, overlap))
        }
    }

    /// Invert the contents of the specified drawable.
    ///
    /// This procedure inverts the contents of the specified drawable. Each
    /// intensity channel is inverted independently. The inverted intensity
    /// is given as inten' = (255 - inten). If 'linear' is TRUE, the
    /// drawable is inverted in linear space.
    /// ## `linear`
    /// Whether to invert in linear space.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_invert")]
    fn invert(&self, linear: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_invert(self.as_ref().to_glib_none().0, linear.into_glib()))
        }
    }

    /// Returns whether the drawable is a grayscale type.
    ///
    /// This procedure returns TRUE if the specified drawable is of type {
    /// Gray, GrayA }.
    ///
    /// # Returns
    ///
    /// TRUE if the drawable is a grayscale type.
    #[doc(alias = "gimp_drawable_is_gray")]
    fn is_gray(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_is_gray(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns whether the drawable is an indexed type.
    ///
    /// This procedure returns TRUE if the specified drawable is of type {
    /// Indexed, IndexedA }.
    ///
    /// # Returns
    ///
    /// TRUE if the drawable is an indexed type.
    #[doc(alias = "gimp_drawable_is_indexed")]
    fn is_indexed(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_is_indexed(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns whether the drawable is an RGB type.
    ///
    /// This procedure returns TRUE if the specified drawable is of type {
    /// RGB, RGBA }.
    ///
    /// # Returns
    ///
    /// TRUE if the drawable is an RGB type.
    #[doc(alias = "gimp_drawable_is_rgb")]
    fn is_rgb(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_is_rgb(self.as_ref().to_glib_none().0))
        }
    }

    /// Modifies intensity levels in the specified drawable.
    ///
    /// This tool allows intensity levels in the specified drawable to be
    /// remapped according to a set of parameters. The low/high input levels
    /// specify an initial mapping from the source intensities. The gamma
    /// value determines how intensities between the low and high input
    /// intensities are interpolated. A gamma value of 1.0 results in a
    /// linear interpolation. Higher gamma values result in more high-level
    /// intensities. Lower gamma values result in more low-level
    /// intensities. The low/high output levels constrain the final
    /// intensity mapping--that is, no final intensity will be lower than
    /// the low output level and no final intensity will be higher than the
    /// high output level. This tool is only valid on RGB color and
    /// grayscale images.
    /// ## `channel`
    /// The channel to modify.
    /// ## `low_input`
    /// Intensity of lowest input.
    /// ## `high_input`
    /// Intensity of highest input.
    /// ## `clamp_input`
    /// Clamp input values before applying output levels.
    /// ## `gamma`
    /// Gamma adjustment factor.
    /// ## `low_output`
    /// Intensity of lowest output.
    /// ## `high_output`
    /// Intensity of highest output.
    /// ## `clamp_output`
    /// Clamp final output values.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_levels")]
    fn levels(&self, channel: HistogramChannel, low_input: f64, high_input: f64, clamp_input: bool, gamma: f64, low_output: f64, high_output: f64, clamp_output: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_levels(self.as_ref().to_glib_none().0, channel.into_glib(), low_input, high_input, clamp_input.into_glib(), gamma, low_output, high_output, clamp_output.into_glib()))
        }
    }

    /// Automatically modifies intensity levels in the specified drawable.
    ///
    /// This procedure allows intensity levels in the specified drawable to
    /// be remapped according to a set of guessed parameters. It is
    /// equivalent to clicking the \"Auto\" button in the Levels tool.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_levels_stretch")]
    fn levels_stretch(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_levels_stretch(self.as_ref().to_glib_none().0))
        }
    }

    /// Find the bounding box of the current selection in relation to the
    /// specified drawable.
    ///
    /// This procedure returns whether there is a selection. If there is
    /// one, the upper left and lower right-hand corners of its bounding box
    /// are returned. These coordinates are specified relative to the
    /// drawable's origin, and bounded by the drawable's extents. Please
    /// note that the pixel specified by the lower right-hand coordinate of
    /// the bounding box is not part of the selection. The selection ends at
    /// the upper left corner of this pixel. This means the width of the
    /// selection can be calculated as (x2 - x1), its height as (y2 - y1).
    /// Note that the returned boolean does NOT correspond with the returned
    /// region being empty or not, it always returns whether the selection
    /// is non_empty. See [`mask_intersect()`][Self::mask_intersect()] for a boolean
    /// return value which is more useful in most cases.
    ///
    /// # Returns
    ///
    /// TRUE if there is a selection.
    ///
    /// ## `x1`
    /// x coordinate of the upper left corner of selection bounds.
    ///
    /// ## `y1`
    /// y coordinate of the upper left corner of selection bounds.
    ///
    /// ## `x2`
    /// x coordinate of the lower right corner of selection bounds.
    ///
    /// ## `y2`
    /// y coordinate of the lower right corner of selection bounds.
    #[doc(alias = "gimp_drawable_mask_bounds")]
    fn mask_bounds(&self) -> Option<(i32, i32, i32, i32)> {
        unsafe {
            let mut x1 = std::mem::MaybeUninit::uninit();
            let mut y1 = std::mem::MaybeUninit::uninit();
            let mut x2 = std::mem::MaybeUninit::uninit();
            let mut y2 = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_mask_bounds(self.as_ref().to_glib_none().0, x1.as_mut_ptr(), y1.as_mut_ptr(), x2.as_mut_ptr(), y2.as_mut_ptr()));
            if ret { Some((x1.assume_init(), y1.assume_init(), x2.assume_init(), y2.assume_init())) } else { None }
        }
    }

    /// Find the bounding box of the current selection in relation to the
    /// specified drawable.
    ///
    /// This procedure returns whether there is an intersection between the
    /// drawable and the selection. Unlike [`mask_bounds()`][Self::mask_bounds()], the
    /// intersection's bounds are returned as x, y, width, height.
    /// If there is no selection this function returns TRUE and the returned
    /// bounds are the extents of the whole drawable.
    ///
    /// # Returns
    ///
    /// TRUE if the returned area is not empty.
    ///
    /// ## `x`
    /// x coordinate of the upper left corner of the intersection.
    ///
    /// ## `y`
    /// y coordinate of the upper left corner of the intersection.
    ///
    /// ## `width`
    /// width of the intersection.
    ///
    /// ## `height`
    /// height of the intersection.
    #[doc(alias = "gimp_drawable_mask_intersect")]
    fn mask_intersect(&self) -> Option<(i32, i32, i32, i32)> {
        unsafe {
            let mut x = std::mem::MaybeUninit::uninit();
            let mut y = std::mem::MaybeUninit::uninit();
            let mut width = std::mem::MaybeUninit::uninit();
            let mut height = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_mask_intersect(self.as_ref().to_glib_none().0, x.as_mut_ptr(), y.as_mut_ptr(), width.as_mut_ptr(), height.as_mut_ptr()));
            if ret { Some((x.assume_init(), y.assume_init(), width.assume_init(), height.assume_init())) } else { None }
        }
    }

    /// This procedure applies the specified drawable effect on `self`
    /// and merge it (therefore before any non-destructive effects are
    /// computed).
    ///
    /// The `self` argument must be the same as the one used when you
    /// created the effect with [ctor`Gimp`.new].
    /// Once this is run, `filter` is not valid anymore and you should not
    /// try to do anything with it. In particular, you must customize the
    /// operation's arguments as received with
    /// [method`Gimp`.get_config] or set the filter's opacity
    /// and blend mode before merging the effect.
    /// ## `filter`
    /// The drawable filter to merge.
    #[doc(alias = "gimp_drawable_merge_filter")]
    fn merge_filter(&self, filter: &DrawableFilter) {
        unsafe {
            ffi::gimp_drawable_merge_filter(self.as_ref().to_glib_none().0, filter.to_glib_none().0);
        }
    }

    /// Merge the layer effect filters to the specified drawable.
    ///
    /// This procedure combines the contents of the drawable's filter stack
    /// (for export) with the specified drawable.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_merge_filters")]
    fn merge_filters(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_merge_filters(self.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_drawable_merge_new_filter")]
    //fn merge_new_filter(&self, operation_name: &str, name: &str, mode: LayerMode, opacity: f64, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) {
    //    unsafe { TODO: call ffi:gimp_drawable_merge_new_filter() }
    //}

    /// Merge the shadow buffer with the specified drawable.
    ///
    /// This procedure combines the contents of the drawable's shadow buffer
    /// (for temporary processing) with the specified drawable. The 'undo'
    /// parameter specifies whether to add an undo step for the operation.
    /// Requesting no undo is useful for such applications as 'auto-apply'.
    /// ## `undo`
    /// Push merge to undo stack?
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_merge_shadow")]
    fn merge_shadow(&self, undo: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_merge_shadow(self.as_ref().to_glib_none().0, undo.into_glib()))
        }
    }

    /// Offset the drawable by the specified amounts in the X and Y
    /// directions
    ///
    /// This procedure offsets the specified drawable by the amounts
    /// specified by 'offset_x' and 'offset_y'. If 'wrap_around' is set to
    /// TRUE, then portions of the drawable which are offset out of bounds
    /// are wrapped around. Alternatively, the undefined regions of the
    /// drawable can be filled with transparency or the background color, as
    /// specified by the 'fill-type' parameter.
    /// ## `wrap_around`
    /// wrap image around or fill vacated regions.
    /// ## `fill_type`
    /// fill vacated regions of drawable with background or transparent.
    /// ## `color`
    /// fills in the background color when fill_type is set to OFFSET-COLOR.
    /// ## `offset_x`
    /// offset by this amount in X direction.
    /// ## `offset_y`
    /// offset by this amount in Y direction.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_offset")]
    fn offset(&self, wrap_around: bool, fill_type: OffsetType, color: &impl IsA<gegl::Color>, offset_x: i32, offset_y: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_offset(self.as_ref().to_glib_none().0, wrap_around.into_glib(), fill_type.into_glib(), color.as_ref().to_glib_none().0, offset_x, offset_y))
        }
    }

    /// Posterize the specified drawable.
    ///
    /// This procedures reduces the number of shades allows in each
    /// intensity channel to the specified 'levels' parameter.
    /// ## `levels`
    /// Levels of posterization.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_posterize")]
    fn posterize(&self, levels: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_posterize(self.as_ref().to_glib_none().0, levels))
        }
    }

    /// Sets the value of the pixel at the specified coordinates.
    ///
    /// This procedure sets the pixel value at the specified coordinates.
    /// Note that this function is not undoable, you should use it only on
    /// drawables you just created yourself.
    /// ## `x_coord`
    /// The x coordinate.
    /// ## `y_coord`
    /// The y coordinate.
    /// ## `color`
    /// The pixel color.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_set_pixel")]
    fn set_pixel(&self, x_coord: i32, y_coord: i32, color: &impl IsA<gegl::Color>) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_set_pixel(self.as_ref().to_glib_none().0, x_coord, y_coord, color.as_ref().to_glib_none().0))
        }
    }

    /// Perform shadows and highlights correction.
    ///
    /// This filter allows adjusting shadows and highlights in the image
    /// separately. The implementation closely follow its counterpart in the
    /// Darktable photography software.
    /// ## `shadows`
    /// Adjust exposure of shadows.
    /// ## `highlights`
    /// Adjust exposure of highlights.
    /// ## `whitepoint`
    /// Shift white point.
    /// ## `radius`
    /// Spatial extent.
    /// ## `compress`
    /// Compress the effect on shadows/highlights and preserve midtones.
    /// ## `shadows_ccorrect`
    /// Adjust saturation of shadows.
    /// ## `highlights_ccorrect`
    /// Adjust saturation of highlights.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_shadows_highlights")]
    fn shadows_highlights(&self, shadows: f64, highlights: f64, whitepoint: f64, radius: f64, compress: f64, shadows_ccorrect: f64, highlights_ccorrect: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_shadows_highlights(self.as_ref().to_glib_none().0, shadows, highlights, whitepoint, radius, compress, shadows_ccorrect, highlights_ccorrect))
        }
    }

    /// Threshold the specified drawable.
    ///
    /// This procedures generates a threshold map of the specified drawable.
    /// All pixels between the values of 'low_threshold' and
    /// 'high_threshold', on the scale of 'channel' are replaced with white,
    /// and all other pixels with black.
    /// ## `channel`
    /// The channel to base the threshold on.
    /// ## `low_threshold`
    /// The low threshold value.
    /// ## `high_threshold`
    /// The high threshold value.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_threshold")]
    fn threshold(&self, channel: HistogramChannel, low_threshold: f64, high_threshold: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_threshold(self.as_ref().to_glib_none().0, channel.into_glib(), low_threshold, high_threshold))
        }
    }

    /// Returns the drawable's type.
    ///
    /// This procedure returns the drawable's type.
    ///
    /// # Returns
    ///
    /// The drawable's type.
    #[doc(alias = "gimp_drawable_type")]
    #[doc(alias = "type")]
    fn type_(&self) -> ImageType {
        unsafe {
            from_glib(ffi::gimp_drawable_type(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns the drawable's type with alpha.
    ///
    /// This procedure returns the drawable's type as if had an alpha
    /// channel. If the type is currently Gray, for instance, the returned
    /// type would be GrayA. If the drawable already has an alpha channel,
    /// the drawable's type is simply returned.
    ///
    /// # Returns
    ///
    /// The drawable's type with alpha.
    #[doc(alias = "gimp_drawable_type_with_alpha")]
    fn type_with_alpha(&self) -> ImageType {
        unsafe {
            from_glib(ffi::gimp_drawable_type_with_alpha(self.as_ref().to_glib_none().0))
        }
    }

    /// Update the specified region of the drawable.
    ///
    /// This procedure updates the specified region of the drawable. The (x,
    /// y) coordinate pair is relative to the drawable's origin, not to the
    /// image origin. Therefore, the entire drawable can be updated using
    /// (0, 0, width, height).
    /// ## `x`
    /// x coordinate of upper left corner of update region.
    /// ## `y`
    /// y coordinate of upper left corner of update region.
    /// ## `width`
    /// Width of update region.
    /// ## `height`
    /// Height of update region.
    ///
    /// # Returns
    ///
    /// TRUE on success.
    #[doc(alias = "gimp_drawable_update")]
    fn update(&self, x: i32, y: i32, width: i32, height: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_update(self.as_ref().to_glib_none().0, x, y, width, height))
        }
    }
}

impl<O: IsA<Drawable>> DrawableExt for O {}
