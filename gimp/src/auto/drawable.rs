// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,DesaturateMode,DrawableFilter,FillType,ForegroundExtractMode,GradientType,HistogramChannel,HueRange,ImageType,Item,OffsetType,PixbufTransparency,TransferMode};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "GimpDrawable")]
    pub struct Drawable(Object<ffi::GimpDrawable, ffi::GimpDrawableClass>) @extends Item;

    match fn {
        type_ => || ffi::gimp_drawable_get_type(),
    }
}

impl Drawable {
        pub const NONE: Option<&'static Drawable> = None;
    

    #[doc(alias = "gimp_drawable_get_by_id")]
    #[doc(alias = "get_by_id")]
    pub fn by_id(drawable_id: i32) -> Option<Drawable> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_drawable_get_by_id(drawable_id))
        }
    }
}

pub trait DrawableExt: IsA<Drawable> + 'static {
    #[doc(alias = "gimp_drawable_append_filter")]
    fn append_filter(&self, filter: &DrawableFilter) {
        unsafe {
            ffi::gimp_drawable_append_filter(self.as_ref().to_glib_none().0, filter.to_glib_none().0);
        }
    }

    //#[doc(alias = "gimp_drawable_append_new_filter")]
    //fn append_new_filter(&self, operation_name: &str, name: &str, mode: LayerMode, opacity: f64, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<DrawableFilter> {
    //    unsafe { TODO: call ffi:gimp_drawable_append_new_filter() }
    //}

    #[doc(alias = "gimp_drawable_brightness_contrast")]
    fn brightness_contrast(&self, brightness: f64, contrast: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_brightness_contrast(self.as_ref().to_glib_none().0, brightness, contrast))
        }
    }

    #[doc(alias = "gimp_drawable_color_balance")]
    fn color_balance(&self, transfer_mode: TransferMode, preserve_lum: bool, cyan_red: f64, magenta_green: f64, yellow_blue: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_color_balance(self.as_ref().to_glib_none().0, transfer_mode.into_glib(), preserve_lum.into_glib(), cyan_red, magenta_green, yellow_blue))
        }
    }

    #[doc(alias = "gimp_drawable_colorize_hsl")]
    fn colorize_hsl(&self, hue: f64, saturation: f64, lightness: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_colorize_hsl(self.as_ref().to_glib_none().0, hue, saturation, lightness))
        }
    }

    #[doc(alias = "gimp_drawable_curves_explicit")]
    fn curves_explicit(&self, channel: HistogramChannel, values: &[f64]) -> bool {
        let num_values = values.len() as _;
        unsafe {
            from_glib(ffi::gimp_drawable_curves_explicit(self.as_ref().to_glib_none().0, channel.into_glib(), num_values, values.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_curves_spline")]
    fn curves_spline(&self, channel: HistogramChannel, points: &[f64]) -> bool {
        let num_points = points.len() as _;
        unsafe {
            from_glib(ffi::gimp_drawable_curves_spline(self.as_ref().to_glib_none().0, channel.into_glib(), num_points, points.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_desaturate")]
    fn desaturate(&self, desaturate_mode: DesaturateMode) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_desaturate(self.as_ref().to_glib_none().0, desaturate_mode.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_edit_bucket_fill")]
    fn edit_bucket_fill(&self, fill_type: FillType, x: f64, y: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_bucket_fill(self.as_ref().to_glib_none().0, fill_type.into_glib(), x, y))
        }
    }

    #[doc(alias = "gimp_drawable_edit_clear")]
    fn edit_clear(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_clear(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_edit_fill")]
    fn edit_fill(&self, fill_type: FillType) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_fill(self.as_ref().to_glib_none().0, fill_type.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_edit_gradient_fill")]
    fn edit_gradient_fill(&self, gradient_type: GradientType, offset: f64, supersample: bool, supersample_max_depth: i32, supersample_threshold: f64, dither: bool, x1: f64, y1: f64, x2: f64, y2: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_gradient_fill(self.as_ref().to_glib_none().0, gradient_type.into_glib(), offset, supersample.into_glib(), supersample_max_depth, supersample_threshold, dither.into_glib(), x1, y1, x2, y2))
        }
    }

    #[doc(alias = "gimp_drawable_edit_stroke_item")]
    fn edit_stroke_item(&self, item: &impl IsA<Item>) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_stroke_item(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_edit_stroke_selection")]
    fn edit_stroke_selection(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_edit_stroke_selection(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_equalize")]
    fn equalize(&self, mask_only: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_equalize(self.as_ref().to_glib_none().0, mask_only.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_extract_component")]
    fn extract_component(&self, component: i32, invert: bool, linear: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_extract_component(self.as_ref().to_glib_none().0, component, invert.into_glib(), linear.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_fill")]
    fn fill(&self, fill_type: FillType) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_fill(self.as_ref().to_glib_none().0, fill_type.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_foreground_extract")]
    fn foreground_extract(&self, mode: ForegroundExtractMode, mask: &impl IsA<Drawable>) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_foreground_extract(self.as_ref().to_glib_none().0, mode.into_glib(), mask.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_free_shadow")]
    fn free_shadow(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_free_shadow(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_get_bpp")]
    #[doc(alias = "get_bpp")]
    fn bpp(&self) -> i32 {
        unsafe {
            ffi::gimp_drawable_get_bpp(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_drawable_get_buffer")]
    #[doc(alias = "get_buffer")]
    fn buffer(&self) -> Option<gegl::Buffer> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_buffer(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_get_filters")]
    #[doc(alias = "get_filters")]
    fn filters(&self) -> Vec<DrawableFilter> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_drawable_get_filters(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_get_format")]
    #[doc(alias = "get_format")]
    fn format(&self) -> Option<babl::Object> {
        unsafe {
            from_glib_none(ffi::gimp_drawable_get_format(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_get_height")]
    #[doc(alias = "get_height")]
    fn height(&self) -> i32 {
        unsafe {
            ffi::gimp_drawable_get_height(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_drawable_get_offsets")]
    #[doc(alias = "get_offsets")]
    fn offsets(&self) -> Option<(i32, i32)> {
        unsafe {
            let mut offset_x = std::mem::MaybeUninit::uninit();
            let mut offset_y = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_get_offsets(self.as_ref().to_glib_none().0, offset_x.as_mut_ptr(), offset_y.as_mut_ptr()));
            if ret { Some((offset_x.assume_init(), offset_y.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_drawable_get_pixel")]
    #[doc(alias = "get_pixel")]
    fn pixel(&self, x_coord: i32, y_coord: i32) -> Option<gegl::Color> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_pixel(self.as_ref().to_glib_none().0, x_coord, y_coord))
        }
    }

    #[doc(alias = "gimp_drawable_get_shadow_buffer")]
    #[doc(alias = "get_shadow_buffer")]
    fn shadow_buffer(&self) -> Option<gegl::Buffer> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_shadow_buffer(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_get_sub_thumbnail")]
    #[doc(alias = "get_sub_thumbnail")]
    fn sub_thumbnail(&self, src_x: i32, src_y: i32, src_width: i32, src_height: i32, dest_width: i32, dest_height: i32, alpha: PixbufTransparency) -> Option<gdk_pixbuf::Pixbuf> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_sub_thumbnail(self.as_ref().to_glib_none().0, src_x, src_y, src_width, src_height, dest_width, dest_height, alpha.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_get_sub_thumbnail_data")]
    #[doc(alias = "get_sub_thumbnail_data")]
    fn sub_thumbnail_data(&self, src_x: i32, src_y: i32, src_width: i32, src_height: i32, dest_width: i32, dest_height: i32) -> (glib::Bytes, i32, i32, i32) {
        unsafe {
            let mut actual_width = std::mem::MaybeUninit::uninit();
            let mut actual_height = std::mem::MaybeUninit::uninit();
            let mut bpp = std::mem::MaybeUninit::uninit();
            let ret = from_glib_full(ffi::gimp_drawable_get_sub_thumbnail_data(self.as_ref().to_glib_none().0, src_x, src_y, src_width, src_height, dest_width, dest_height, actual_width.as_mut_ptr(), actual_height.as_mut_ptr(), bpp.as_mut_ptr()));
            (ret, actual_width.assume_init(), actual_height.assume_init(), bpp.assume_init())
        }
    }

    #[doc(alias = "gimp_drawable_get_thumbnail")]
    #[doc(alias = "get_thumbnail")]
    fn thumbnail(&self, width: i32, height: i32, alpha: PixbufTransparency) -> Option<gdk_pixbuf::Pixbuf> {
        unsafe {
            from_glib_full(ffi::gimp_drawable_get_thumbnail(self.as_ref().to_glib_none().0, width, height, alpha.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_get_thumbnail_data")]
    #[doc(alias = "get_thumbnail_data")]
    fn thumbnail_data(&self, width: i32, height: i32) -> (Option<glib::Bytes>, i32, i32, i32) {
        unsafe {
            let mut actual_width = std::mem::MaybeUninit::uninit();
            let mut actual_height = std::mem::MaybeUninit::uninit();
            let mut bpp = std::mem::MaybeUninit::uninit();
            let ret = from_glib_full(ffi::gimp_drawable_get_thumbnail_data(self.as_ref().to_glib_none().0, width, height, actual_width.as_mut_ptr(), actual_height.as_mut_ptr(), bpp.as_mut_ptr()));
            (ret, actual_width.assume_init(), actual_height.assume_init(), bpp.assume_init())
        }
    }

    #[doc(alias = "gimp_drawable_get_thumbnail_format")]
    #[doc(alias = "get_thumbnail_format")]
    fn thumbnail_format(&self) -> Option<babl::Object> {
        unsafe {
            from_glib_none(ffi::gimp_drawable_get_thumbnail_format(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_get_width")]
    #[doc(alias = "get_width")]
    fn width(&self) -> i32 {
        unsafe {
            ffi::gimp_drawable_get_width(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_drawable_has_alpha")]
    fn has_alpha(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_has_alpha(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_histogram")]
    fn histogram(&self, channel: HistogramChannel, start_range: f64, end_range: f64) -> Option<(f64, f64, f64, f64, f64, f64)> {
        unsafe {
            let mut mean = std::mem::MaybeUninit::uninit();
            let mut std_dev = std::mem::MaybeUninit::uninit();
            let mut median = std::mem::MaybeUninit::uninit();
            let mut pixels = std::mem::MaybeUninit::uninit();
            let mut count = std::mem::MaybeUninit::uninit();
            let mut percentile = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_histogram(self.as_ref().to_glib_none().0, channel.into_glib(), start_range, end_range, mean.as_mut_ptr(), std_dev.as_mut_ptr(), median.as_mut_ptr(), pixels.as_mut_ptr(), count.as_mut_ptr(), percentile.as_mut_ptr()));
            if ret { Some((mean.assume_init(), std_dev.assume_init(), median.assume_init(), pixels.assume_init(), count.assume_init(), percentile.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_drawable_hue_saturation")]
    fn hue_saturation(&self, hue_range: HueRange, hue_offset: f64, lightness: f64, saturation: f64, overlap: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_hue_saturation(self.as_ref().to_glib_none().0, hue_range.into_glib(), hue_offset, lightness, saturation, overlap))
        }
    }

    #[doc(alias = "gimp_drawable_invert")]
    fn invert(&self, linear: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_invert(self.as_ref().to_glib_none().0, linear.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_is_gray")]
    fn is_gray(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_is_gray(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_is_indexed")]
    fn is_indexed(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_is_indexed(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_is_rgb")]
    fn is_rgb(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_is_rgb(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_levels")]
    fn levels(&self, channel: HistogramChannel, low_input: f64, high_input: f64, clamp_input: bool, gamma: f64, low_output: f64, high_output: f64, clamp_output: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_levels(self.as_ref().to_glib_none().0, channel.into_glib(), low_input, high_input, clamp_input.into_glib(), gamma, low_output, high_output, clamp_output.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_levels_stretch")]
    fn levels_stretch(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_levels_stretch(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_mask_bounds")]
    fn mask_bounds(&self) -> Option<(i32, i32, i32, i32)> {
        unsafe {
            let mut x1 = std::mem::MaybeUninit::uninit();
            let mut y1 = std::mem::MaybeUninit::uninit();
            let mut x2 = std::mem::MaybeUninit::uninit();
            let mut y2 = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_mask_bounds(self.as_ref().to_glib_none().0, x1.as_mut_ptr(), y1.as_mut_ptr(), x2.as_mut_ptr(), y2.as_mut_ptr()));
            if ret { Some((x1.assume_init(), y1.assume_init(), x2.assume_init(), y2.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_drawable_mask_intersect")]
    fn mask_intersect(&self) -> Option<(i32, i32, i32, i32)> {
        unsafe {
            let mut x = std::mem::MaybeUninit::uninit();
            let mut y = std::mem::MaybeUninit::uninit();
            let mut width = std::mem::MaybeUninit::uninit();
            let mut height = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_drawable_mask_intersect(self.as_ref().to_glib_none().0, x.as_mut_ptr(), y.as_mut_ptr(), width.as_mut_ptr(), height.as_mut_ptr()));
            if ret { Some((x.assume_init(), y.assume_init(), width.assume_init(), height.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_drawable_merge_filter")]
    fn merge_filter(&self, filter: &DrawableFilter) {
        unsafe {
            ffi::gimp_drawable_merge_filter(self.as_ref().to_glib_none().0, filter.to_glib_none().0);
        }
    }

    #[doc(alias = "gimp_drawable_merge_filters")]
    fn merge_filters(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_merge_filters(self.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_drawable_merge_new_filter")]
    //fn merge_new_filter(&self, operation_name: &str, name: &str, mode: LayerMode, opacity: f64, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) {
    //    unsafe { TODO: call ffi:gimp_drawable_merge_new_filter() }
    //}

    #[doc(alias = "gimp_drawable_merge_shadow")]
    fn merge_shadow(&self, undo: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_merge_shadow(self.as_ref().to_glib_none().0, undo.into_glib()))
        }
    }

    #[doc(alias = "gimp_drawable_offset")]
    fn offset(&self, wrap_around: bool, fill_type: OffsetType, color: &impl IsA<gegl::Color>, offset_x: i32, offset_y: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_offset(self.as_ref().to_glib_none().0, wrap_around.into_glib(), fill_type.into_glib(), color.as_ref().to_glib_none().0, offset_x, offset_y))
        }
    }

    #[doc(alias = "gimp_drawable_posterize")]
    fn posterize(&self, levels: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_posterize(self.as_ref().to_glib_none().0, levels))
        }
    }

    #[doc(alias = "gimp_drawable_set_pixel")]
    fn set_pixel(&self, x_coord: i32, y_coord: i32, color: &impl IsA<gegl::Color>) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_set_pixel(self.as_ref().to_glib_none().0, x_coord, y_coord, color.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_shadows_highlights")]
    fn shadows_highlights(&self, shadows: f64, highlights: f64, whitepoint: f64, radius: f64, compress: f64, shadows_ccorrect: f64, highlights_ccorrect: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_shadows_highlights(self.as_ref().to_glib_none().0, shadows, highlights, whitepoint, radius, compress, shadows_ccorrect, highlights_ccorrect))
        }
    }

    #[doc(alias = "gimp_drawable_threshold")]
    fn threshold(&self, channel: HistogramChannel, low_threshold: f64, high_threshold: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_threshold(self.as_ref().to_glib_none().0, channel.into_glib(), low_threshold, high_threshold))
        }
    }

    #[doc(alias = "gimp_drawable_type")]
    #[doc(alias = "type")]
    fn type_(&self) -> ImageType {
        unsafe {
            from_glib(ffi::gimp_drawable_type(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_type_with_alpha")]
    fn type_with_alpha(&self) -> ImageType {
        unsafe {
            from_glib(ffi::gimp_drawable_type_with_alpha(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_drawable_update")]
    fn update(&self, x: i32, y: i32, width: i32, height: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_drawable_update(self.as_ref().to_glib_none().0, x, y, width, height))
        }
    }
}

impl<O: IsA<Drawable>> DrawableExt for O {}
