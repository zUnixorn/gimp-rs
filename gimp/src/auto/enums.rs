// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{prelude::*,translate::*};

/// Modes of initialising a layer mask.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpAddMaskType")]
pub enum AddMaskType {
    /// White (full opacity)
    #[doc(alias = "GIMP_ADD_MASK_WHITE")]
    White,
    /// Black (full transparency)
    #[doc(alias = "GIMP_ADD_MASK_BLACK")]
    Black,
    /// Layer's alpha channel
    #[doc(alias = "GIMP_ADD_MASK_ALPHA")]
    Alpha,
    /// Transfer layer's alpha channel
    #[doc(alias = "GIMP_ADD_MASK_ALPHA_TRANSFER")]
    AlphaTransfer,
    /// Selection
    #[doc(alias = "GIMP_ADD_MASK_SELECTION")]
    Selection,
    /// Grayscale copy of layer
    #[doc(alias = "GIMP_ADD_MASK_COPY")]
    Copy,
    /// Channel
    #[doc(alias = "GIMP_ADD_MASK_CHANNEL")]
    Channel,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AddMaskType {
    type GlibType = ffi::GimpAddMaskType;

    #[inline]
fn into_glib(self) -> ffi::GimpAddMaskType {
match self {
            Self::White => ffi::GIMP_ADD_MASK_WHITE,
            Self::Black => ffi::GIMP_ADD_MASK_BLACK,
            Self::Alpha => ffi::GIMP_ADD_MASK_ALPHA,
            Self::AlphaTransfer => ffi::GIMP_ADD_MASK_ALPHA_TRANSFER,
            Self::Selection => ffi::GIMP_ADD_MASK_SELECTION,
            Self::Copy => ffi::GIMP_ADD_MASK_COPY,
            Self::Channel => ffi::GIMP_ADD_MASK_CHANNEL,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpAddMaskType> for AddMaskType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpAddMaskType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_ADD_MASK_WHITE => Self::White,
            ffi::GIMP_ADD_MASK_BLACK => Self::Black,
            ffi::GIMP_ADD_MASK_ALPHA => Self::Alpha,
            ffi::GIMP_ADD_MASK_ALPHA_TRANSFER => Self::AlphaTransfer,
            ffi::GIMP_ADD_MASK_SELECTION => Self::Selection,
            ffi::GIMP_ADD_MASK_COPY => Self::Copy,
            ffi::GIMP_ADD_MASK_CHANNEL => Self::Channel,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for AddMaskType {
                #[inline]
    #[doc(alias = "gimp_add_mask_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_add_mask_type_get_type()) }
                }
            }

impl glib::HasParamSpec for AddMaskType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for AddMaskType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AddMaskType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AddMaskType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AddMaskType> for glib::Value {
    #[inline]
    fn from(v: AddMaskType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Methods of syncing procedure arguments.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpArgumentSync")]
pub enum ArgumentSync {
    /// Don't sync this argument
    #[doc(alias = "GIMP_ARGUMENT_SYNC_NONE")]
    None,
    /// Sync this argument with an image parasite
    #[doc(alias = "GIMP_ARGUMENT_SYNC_PARASITE")]
    Parasite,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ArgumentSync {
    type GlibType = ffi::GimpArgumentSync;

    #[inline]
fn into_glib(self) -> ffi::GimpArgumentSync {
match self {
            Self::None => ffi::GIMP_ARGUMENT_SYNC_NONE,
            Self::Parasite => ffi::GIMP_ARGUMENT_SYNC_PARASITE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpArgumentSync> for ArgumentSync {
    #[inline]
unsafe fn from_glib(value: ffi::GimpArgumentSync) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_ARGUMENT_SYNC_NONE => Self::None,
            ffi::GIMP_ARGUMENT_SYNC_PARASITE => Self::Parasite,
            value => Self::__Unknown(value),
}
}
}

/// Operations to combine channels and selections.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpChannelOps")]
pub enum ChannelOps {
    /// Add to the current selection
    #[doc(alias = "GIMP_CHANNEL_OP_ADD")]
    Add,
    /// Subtract from the current selection
    #[doc(alias = "GIMP_CHANNEL_OP_SUBTRACT")]
    Subtract,
    /// Replace the current selection
    #[doc(alias = "GIMP_CHANNEL_OP_REPLACE")]
    Replace,
    /// Intersect with the current selection
    #[doc(alias = "GIMP_CHANNEL_OP_INTERSECT")]
    Intersect,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ChannelOps {
    type GlibType = ffi::GimpChannelOps;

    #[inline]
fn into_glib(self) -> ffi::GimpChannelOps {
match self {
            Self::Add => ffi::GIMP_CHANNEL_OP_ADD,
            Self::Subtract => ffi::GIMP_CHANNEL_OP_SUBTRACT,
            Self::Replace => ffi::GIMP_CHANNEL_OP_REPLACE,
            Self::Intersect => ffi::GIMP_CHANNEL_OP_INTERSECT,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpChannelOps> for ChannelOps {
    #[inline]
unsafe fn from_glib(value: ffi::GimpChannelOps) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_CHANNEL_OP_ADD => Self::Add,
            ffi::GIMP_CHANNEL_OP_SUBTRACT => Self::Subtract,
            ffi::GIMP_CHANNEL_OP_REPLACE => Self::Replace,
            ffi::GIMP_CHANNEL_OP_INTERSECT => Self::Intersect,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ChannelOps {
                #[inline]
    #[doc(alias = "gimp_channel_ops_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_channel_ops_get_type()) }
                }
            }

impl glib::HasParamSpec for ChannelOps {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ChannelOps {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ChannelOps {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ChannelOps {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ChannelOps> for glib::Value {
    #[inline]
    fn from(v: ChannelOps) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Channels (as in color components).
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpChannelType")]
pub enum ChannelType {
    /// Red
    #[doc(alias = "GIMP_CHANNEL_RED")]
    Red,
    /// Green
    #[doc(alias = "GIMP_CHANNEL_GREEN")]
    Green,
    /// Blue
    #[doc(alias = "GIMP_CHANNEL_BLUE")]
    Blue,
    /// Gray
    #[doc(alias = "GIMP_CHANNEL_GRAY")]
    Gray,
    /// Indexed
    #[doc(alias = "GIMP_CHANNEL_INDEXED")]
    Indexed,
    /// Alpha
    #[doc(alias = "GIMP_CHANNEL_ALPHA")]
    Alpha,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ChannelType {
    type GlibType = ffi::GimpChannelType;

    #[inline]
fn into_glib(self) -> ffi::GimpChannelType {
match self {
            Self::Red => ffi::GIMP_CHANNEL_RED,
            Self::Green => ffi::GIMP_CHANNEL_GREEN,
            Self::Blue => ffi::GIMP_CHANNEL_BLUE,
            Self::Gray => ffi::GIMP_CHANNEL_GRAY,
            Self::Indexed => ffi::GIMP_CHANNEL_INDEXED,
            Self::Alpha => ffi::GIMP_CHANNEL_ALPHA,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpChannelType> for ChannelType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpChannelType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_CHANNEL_RED => Self::Red,
            ffi::GIMP_CHANNEL_GREEN => Self::Green,
            ffi::GIMP_CHANNEL_BLUE => Self::Blue,
            ffi::GIMP_CHANNEL_GRAY => Self::Gray,
            ffi::GIMP_CHANNEL_INDEXED => Self::Indexed,
            ffi::GIMP_CHANNEL_ALPHA => Self::Alpha,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ChannelType {
                #[inline]
    #[doc(alias = "gimp_channel_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_channel_type_get_type()) }
                }
            }

impl glib::HasParamSpec for ChannelType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ChannelType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ChannelType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ChannelType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ChannelType> for glib::Value {
    #[inline]
    fn from(v: ChannelType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Intents for color management.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpColorRenderingIntent")]
pub enum ColorRenderingIntent {
    /// Perceptual
    #[doc(alias = "GIMP_COLOR_RENDERING_INTENT_PERCEPTUAL")]
    Perceptual,
    /// Relative colorimetric
    #[doc(alias = "GIMP_COLOR_RENDERING_INTENT_RELATIVE_COLORIMETRIC")]
    RelativeColorimetric,
    /// Saturation
    #[doc(alias = "GIMP_COLOR_RENDERING_INTENT_SATURATION")]
    Saturation,
    /// Absolute colorimetric
    #[doc(alias = "GIMP_COLOR_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC")]
    AbsoluteColorimetric,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ColorRenderingIntent {
    type GlibType = ffi::GimpColorRenderingIntent;

    #[inline]
fn into_glib(self) -> ffi::GimpColorRenderingIntent {
match self {
            Self::Perceptual => ffi::GIMP_COLOR_RENDERING_INTENT_PERCEPTUAL,
            Self::RelativeColorimetric => ffi::GIMP_COLOR_RENDERING_INTENT_RELATIVE_COLORIMETRIC,
            Self::Saturation => ffi::GIMP_COLOR_RENDERING_INTENT_SATURATION,
            Self::AbsoluteColorimetric => ffi::GIMP_COLOR_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpColorRenderingIntent> for ColorRenderingIntent {
    #[inline]
unsafe fn from_glib(value: ffi::GimpColorRenderingIntent) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_COLOR_RENDERING_INTENT_PERCEPTUAL => Self::Perceptual,
            ffi::GIMP_COLOR_RENDERING_INTENT_RELATIVE_COLORIMETRIC => Self::RelativeColorimetric,
            ffi::GIMP_COLOR_RENDERING_INTENT_SATURATION => Self::Saturation,
            ffi::GIMP_COLOR_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC => Self::AbsoluteColorimetric,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ColorRenderingIntent {
                #[inline]
    #[doc(alias = "gimp_color_rendering_intent_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_color_rendering_intent_get_type()) }
                }
            }

impl glib::HasParamSpec for ColorRenderingIntent {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ColorRenderingIntent {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ColorRenderingIntent {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ColorRenderingIntent {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ColorRenderingIntent> for glib::Value {
    #[inline]
    fn from(v: ColorRenderingIntent) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Extracted from app/core/core-enums.h
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpConvertDitherType")]
pub enum ConvertDitherType {
    /// GIMP_CONVERT_DITHER_NONE
    #[doc(alias = "GIMP_CONVERT_DITHER_NONE")]
    None,
    /// GIMP_CONVERT_DITHER_FS
    #[doc(alias = "GIMP_CONVERT_DITHER_FS")]
    Fs,
    /// GIMP_CONVERT_DITHER_FS_LOWBLEED
    #[doc(alias = "GIMP_CONVERT_DITHER_FS_LOWBLEED")]
    FsLowbleed,
    /// GIMP_CONVERT_DITHER_FIXED
    #[doc(alias = "GIMP_CONVERT_DITHER_FIXED")]
    Fixed,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConvertDitherType {
    type GlibType = ffi::GimpConvertDitherType;

    #[inline]
fn into_glib(self) -> ffi::GimpConvertDitherType {
match self {
            Self::None => ffi::GIMP_CONVERT_DITHER_NONE,
            Self::Fs => ffi::GIMP_CONVERT_DITHER_FS,
            Self::FsLowbleed => ffi::GIMP_CONVERT_DITHER_FS_LOWBLEED,
            Self::Fixed => ffi::GIMP_CONVERT_DITHER_FIXED,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpConvertDitherType> for ConvertDitherType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpConvertDitherType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_CONVERT_DITHER_NONE => Self::None,
            ffi::GIMP_CONVERT_DITHER_FS => Self::Fs,
            ffi::GIMP_CONVERT_DITHER_FS_LOWBLEED => Self::FsLowbleed,
            ffi::GIMP_CONVERT_DITHER_FIXED => Self::Fixed,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ConvertDitherType {
                #[inline]
    #[doc(alias = "gimp_convert_dither_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_convert_dither_type_get_type()) }
                }
            }

impl glib::HasParamSpec for ConvertDitherType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ConvertDitherType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConvertDitherType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConvertDitherType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConvertDitherType> for glib::Value {
    #[inline]
    fn from(v: ConvertDitherType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Types of palettes for indexed conversion.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpConvertPaletteType")]
pub enum ConvertPaletteType {
    /// Generate optimum palette
    #[doc(alias = "GIMP_CONVERT_PALETTE_GENERATE")]
    Generate,
    /// Use web-optimized palette
    #[doc(alias = "GIMP_CONVERT_PALETTE_WEB")]
    Web,
    /// Use black and white (1-bit) palette
    #[doc(alias = "GIMP_CONVERT_PALETTE_MONO")]
    Mono,
    /// Use custom palette
    #[doc(alias = "GIMP_CONVERT_PALETTE_CUSTOM")]
    Custom,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ConvertPaletteType {
    type GlibType = ffi::GimpConvertPaletteType;

    #[inline]
fn into_glib(self) -> ffi::GimpConvertPaletteType {
match self {
            Self::Generate => ffi::GIMP_CONVERT_PALETTE_GENERATE,
            Self::Web => ffi::GIMP_CONVERT_PALETTE_WEB,
            Self::Mono => ffi::GIMP_CONVERT_PALETTE_MONO,
            Self::Custom => ffi::GIMP_CONVERT_PALETTE_CUSTOM,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpConvertPaletteType> for ConvertPaletteType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpConvertPaletteType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_CONVERT_PALETTE_GENERATE => Self::Generate,
            ffi::GIMP_CONVERT_PALETTE_WEB => Self::Web,
            ffi::GIMP_CONVERT_PALETTE_MONO => Self::Mono,
            ffi::GIMP_CONVERT_PALETTE_CUSTOM => Self::Custom,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ConvertPaletteType {
                #[inline]
    #[doc(alias = "gimp_convert_palette_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_convert_palette_type_get_type()) }
                }
            }

impl glib::HasParamSpec for ConvertPaletteType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ConvertPaletteType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ConvertPaletteType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ConvertPaletteType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ConvertPaletteType> for glib::Value {
    #[inline]
    fn from(v: ConvertPaletteType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Rendering types for the display grid.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpGridStyle")]
pub enum GridStyle {
    /// Intersections (dots)
    #[doc(alias = "GIMP_GRID_DOTS")]
    Dots,
    /// Intersections (crosshairs)
    #[doc(alias = "GIMP_GRID_INTERSECTIONS")]
    Intersections,
    /// Dashed
    #[doc(alias = "GIMP_GRID_ON_OFF_DASH")]
    OnOffDash,
    /// Double dashed
    #[doc(alias = "GIMP_GRID_DOUBLE_DASH")]
    DoubleDash,
    /// Solid
    #[doc(alias = "GIMP_GRID_SOLID")]
    Solid,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GridStyle {
    type GlibType = ffi::GimpGridStyle;

    #[inline]
fn into_glib(self) -> ffi::GimpGridStyle {
match self {
            Self::Dots => ffi::GIMP_GRID_DOTS,
            Self::Intersections => ffi::GIMP_GRID_INTERSECTIONS,
            Self::OnOffDash => ffi::GIMP_GRID_ON_OFF_DASH,
            Self::DoubleDash => ffi::GIMP_GRID_DOUBLE_DASH,
            Self::Solid => ffi::GIMP_GRID_SOLID,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpGridStyle> for GridStyle {
    #[inline]
unsafe fn from_glib(value: ffi::GimpGridStyle) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_GRID_DOTS => Self::Dots,
            ffi::GIMP_GRID_INTERSECTIONS => Self::Intersections,
            ffi::GIMP_GRID_ON_OFF_DASH => Self::OnOffDash,
            ffi::GIMP_GRID_DOUBLE_DASH => Self::DoubleDash,
            ffi::GIMP_GRID_SOLID => Self::Solid,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for GridStyle {
                #[inline]
    #[doc(alias = "gimp_grid_style_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_grid_style_get_type()) }
                }
            }

impl glib::HasParamSpec for GridStyle {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for GridStyle {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GridStyle {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for GridStyle {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<GridStyle> for glib::Value {
    #[inline]
    fn from(v: GridStyle) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Icon types for plug-ins to register.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpIconType")]
pub enum IconType {
    /// Icon name
    #[doc(alias = "GIMP_ICON_TYPE_ICON_NAME")]
    IconName,
    /// Inline pixbuf
    #[doc(alias = "GIMP_ICON_TYPE_PIXBUF")]
    Pixbuf,
    /// Image file
    #[doc(alias = "GIMP_ICON_TYPE_IMAGE_FILE")]
    ImageFile,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for IconType {
    type GlibType = ffi::GimpIconType;

    #[inline]
fn into_glib(self) -> ffi::GimpIconType {
match self {
            Self::IconName => ffi::GIMP_ICON_TYPE_ICON_NAME,
            Self::Pixbuf => ffi::GIMP_ICON_TYPE_PIXBUF,
            Self::ImageFile => ffi::GIMP_ICON_TYPE_IMAGE_FILE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpIconType> for IconType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpIconType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_ICON_TYPE_ICON_NAME => Self::IconName,
            ffi::GIMP_ICON_TYPE_PIXBUF => Self::Pixbuf,
            ffi::GIMP_ICON_TYPE_IMAGE_FILE => Self::ImageFile,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for IconType {
                #[inline]
    #[doc(alias = "gimp_icon_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_icon_type_get_type()) }
                }
            }

impl glib::HasParamSpec for IconType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for IconType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for IconType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for IconType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<IconType> for glib::Value {
    #[inline]
    fn from(v: IconType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Image color models.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpImageBaseType")]
pub enum ImageBaseType {
    /// RGB color
    #[doc(alias = "GIMP_RGB")]
    Rgb,
    /// Grayscale
    #[doc(alias = "GIMP_GRAY")]
    Gray,
    /// Indexed color
    #[doc(alias = "GIMP_INDEXED")]
    Indexed,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ImageBaseType {
    type GlibType = ffi::GimpImageBaseType;

    #[inline]
fn into_glib(self) -> ffi::GimpImageBaseType {
match self {
            Self::Rgb => ffi::GIMP_RGB,
            Self::Gray => ffi::GIMP_GRAY,
            Self::Indexed => ffi::GIMP_INDEXED,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpImageBaseType> for ImageBaseType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpImageBaseType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_RGB => Self::Rgb,
            ffi::GIMP_GRAY => Self::Gray,
            ffi::GIMP_INDEXED => Self::Indexed,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ImageBaseType {
                #[inline]
    #[doc(alias = "gimp_image_base_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_image_base_type_get_type()) }
                }
            }

impl glib::HasParamSpec for ImageBaseType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ImageBaseType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ImageBaseType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ImageBaseType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ImageBaseType> for glib::Value {
    #[inline]
    fn from(v: ImageBaseType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Extracted from app/operations/operations-enums.h
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpLayerMode")]
pub enum LayerMode {
    /// GIMP_LAYER_MODE_NORMAL_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_NORMAL_LEGACY")]
    NormalLegacy,
    /// GIMP_LAYER_MODE_DISSOLVE
    #[doc(alias = "GIMP_LAYER_MODE_DISSOLVE")]
    Dissolve,
    /// GIMP_LAYER_MODE_BEHIND_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_BEHIND_LEGACY")]
    BehindLegacy,
    /// GIMP_LAYER_MODE_MULTIPLY_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_MULTIPLY_LEGACY")]
    MultiplyLegacy,
    /// GIMP_LAYER_MODE_SCREEN_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_SCREEN_LEGACY")]
    ScreenLegacy,
    /// GIMP_LAYER_MODE_OVERLAY_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_OVERLAY_LEGACY")]
    OverlayLegacy,
    /// GIMP_LAYER_MODE_DIFFERENCE_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_DIFFERENCE_LEGACY")]
    DifferenceLegacy,
    /// GIMP_LAYER_MODE_ADDITION_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_ADDITION_LEGACY")]
    AdditionLegacy,
    /// GIMP_LAYER_MODE_SUBTRACT_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_SUBTRACT_LEGACY")]
    SubtractLegacy,
    /// GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY")]
    DarkenOnlyLegacy,
    /// GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY")]
    LightenOnlyLegacy,
    /// GIMP_LAYER_MODE_HSV_HUE_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_HSV_HUE_LEGACY")]
    HsvHueLegacy,
    /// GIMP_LAYER_MODE_HSV_SATURATION_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_HSV_SATURATION_LEGACY")]
    HsvSaturationLegacy,
    /// GIMP_LAYER_MODE_HSL_COLOR_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_HSL_COLOR_LEGACY")]
    HslColorLegacy,
    /// GIMP_LAYER_MODE_HSV_VALUE_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_HSV_VALUE_LEGACY")]
    HsvValueLegacy,
    /// GIMP_LAYER_MODE_DIVIDE_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_DIVIDE_LEGACY")]
    DivideLegacy,
    /// GIMP_LAYER_MODE_DODGE_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_DODGE_LEGACY")]
    DodgeLegacy,
    /// GIMP_LAYER_MODE_BURN_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_BURN_LEGACY")]
    BurnLegacy,
    /// GIMP_LAYER_MODE_HARDLIGHT_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_HARDLIGHT_LEGACY")]
    HardlightLegacy,
    /// GIMP_LAYER_MODE_SOFTLIGHT_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_SOFTLIGHT_LEGACY")]
    SoftlightLegacy,
    /// GIMP_LAYER_MODE_GRAIN_EXTRACT_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_GRAIN_EXTRACT_LEGACY")]
    GrainExtractLegacy,
    /// GIMP_LAYER_MODE_GRAIN_MERGE_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_GRAIN_MERGE_LEGACY")]
    GrainMergeLegacy,
    /// GIMP_LAYER_MODE_COLOR_ERASE_LEGACY
    #[doc(alias = "GIMP_LAYER_MODE_COLOR_ERASE_LEGACY")]
    ColorEraseLegacy,
    /// GIMP_LAYER_MODE_OVERLAY
    #[doc(alias = "GIMP_LAYER_MODE_OVERLAY")]
    Overlay,
    /// GIMP_LAYER_MODE_LCH_HUE
    #[doc(alias = "GIMP_LAYER_MODE_LCH_HUE")]
    LchHue,
    /// GIMP_LAYER_MODE_LCH_CHROMA
    #[doc(alias = "GIMP_LAYER_MODE_LCH_CHROMA")]
    LchChroma,
    /// GIMP_LAYER_MODE_LCH_COLOR
    #[doc(alias = "GIMP_LAYER_MODE_LCH_COLOR")]
    LchColor,
    /// GIMP_LAYER_MODE_LCH_LIGHTNESS
    #[doc(alias = "GIMP_LAYER_MODE_LCH_LIGHTNESS")]
    LchLightness,
    /// GIMP_LAYER_MODE_NORMAL
    #[doc(alias = "GIMP_LAYER_MODE_NORMAL")]
    Normal,
    /// GIMP_LAYER_MODE_BEHIND
    #[doc(alias = "GIMP_LAYER_MODE_BEHIND")]
    Behind,
    /// GIMP_LAYER_MODE_MULTIPLY
    #[doc(alias = "GIMP_LAYER_MODE_MULTIPLY")]
    Multiply,
    /// GIMP_LAYER_MODE_SCREEN
    #[doc(alias = "GIMP_LAYER_MODE_SCREEN")]
    Screen,
    /// GIMP_LAYER_MODE_DIFFERENCE
    #[doc(alias = "GIMP_LAYER_MODE_DIFFERENCE")]
    Difference,
    /// GIMP_LAYER_MODE_ADDITION
    #[doc(alias = "GIMP_LAYER_MODE_ADDITION")]
    Addition,
    /// GIMP_LAYER_MODE_SUBTRACT
    #[doc(alias = "GIMP_LAYER_MODE_SUBTRACT")]
    Subtract,
    /// GIMP_LAYER_MODE_DARKEN_ONLY
    #[doc(alias = "GIMP_LAYER_MODE_DARKEN_ONLY")]
    DarkenOnly,
    /// GIMP_LAYER_MODE_LIGHTEN_ONLY
    #[doc(alias = "GIMP_LAYER_MODE_LIGHTEN_ONLY")]
    LightenOnly,
    /// GIMP_LAYER_MODE_HSV_HUE
    #[doc(alias = "GIMP_LAYER_MODE_HSV_HUE")]
    HsvHue,
    /// GIMP_LAYER_MODE_HSV_SATURATION
    #[doc(alias = "GIMP_LAYER_MODE_HSV_SATURATION")]
    HsvSaturation,
    /// GIMP_LAYER_MODE_HSL_COLOR
    #[doc(alias = "GIMP_LAYER_MODE_HSL_COLOR")]
    HslColor,
    /// GIMP_LAYER_MODE_HSV_VALUE
    #[doc(alias = "GIMP_LAYER_MODE_HSV_VALUE")]
    HsvValue,
    /// GIMP_LAYER_MODE_DIVIDE
    #[doc(alias = "GIMP_LAYER_MODE_DIVIDE")]
    Divide,
    /// GIMP_LAYER_MODE_DODGE
    #[doc(alias = "GIMP_LAYER_MODE_DODGE")]
    Dodge,
    /// GIMP_LAYER_MODE_BURN
    #[doc(alias = "GIMP_LAYER_MODE_BURN")]
    Burn,
    /// GIMP_LAYER_MODE_HARDLIGHT
    #[doc(alias = "GIMP_LAYER_MODE_HARDLIGHT")]
    Hardlight,
    /// GIMP_LAYER_MODE_SOFTLIGHT
    #[doc(alias = "GIMP_LAYER_MODE_SOFTLIGHT")]
    Softlight,
    /// GIMP_LAYER_MODE_GRAIN_EXTRACT
    #[doc(alias = "GIMP_LAYER_MODE_GRAIN_EXTRACT")]
    GrainExtract,
    /// GIMP_LAYER_MODE_GRAIN_MERGE
    #[doc(alias = "GIMP_LAYER_MODE_GRAIN_MERGE")]
    GrainMerge,
    /// GIMP_LAYER_MODE_VIVID_LIGHT
    #[doc(alias = "GIMP_LAYER_MODE_VIVID_LIGHT")]
    VividLight,
    /// GIMP_LAYER_MODE_PIN_LIGHT
    #[doc(alias = "GIMP_LAYER_MODE_PIN_LIGHT")]
    PinLight,
    /// GIMP_LAYER_MODE_LINEAR_LIGHT
    #[doc(alias = "GIMP_LAYER_MODE_LINEAR_LIGHT")]
    LinearLight,
    /// GIMP_LAYER_MODE_HARD_MIX
    #[doc(alias = "GIMP_LAYER_MODE_HARD_MIX")]
    HardMix,
    /// GIMP_LAYER_MODE_EXCLUSION
    #[doc(alias = "GIMP_LAYER_MODE_EXCLUSION")]
    Exclusion,
    /// GIMP_LAYER_MODE_LINEAR_BURN
    #[doc(alias = "GIMP_LAYER_MODE_LINEAR_BURN")]
    LinearBurn,
    /// GIMP_LAYER_MODE_LUMA_DARKEN_ONLY
    #[doc(alias = "GIMP_LAYER_MODE_LUMA_DARKEN_ONLY")]
    LumaDarkenOnly,
    /// GIMP_LAYER_MODE_LUMA_LIGHTEN_ONLY
    #[doc(alias = "GIMP_LAYER_MODE_LUMA_LIGHTEN_ONLY")]
    LumaLightenOnly,
    /// GIMP_LAYER_MODE_LUMINANCE
    #[doc(alias = "GIMP_LAYER_MODE_LUMINANCE")]
    Luminance,
    /// GIMP_LAYER_MODE_COLOR_ERASE
    #[doc(alias = "GIMP_LAYER_MODE_COLOR_ERASE")]
    ColorErase,
    /// GIMP_LAYER_MODE_ERASE
    #[doc(alias = "GIMP_LAYER_MODE_ERASE")]
    Erase,
    /// GIMP_LAYER_MODE_MERGE
    #[doc(alias = "GIMP_LAYER_MODE_MERGE")]
    Merge,
    /// GIMP_LAYER_MODE_SPLIT
    #[doc(alias = "GIMP_LAYER_MODE_SPLIT")]
    Split,
    /// GIMP_LAYER_MODE_PASS_THROUGH
    #[doc(alias = "GIMP_LAYER_MODE_PASS_THROUGH")]
    PassThrough,
    /// GIMP_LAYER_MODE_REPLACE
    #[doc(alias = "GIMP_LAYER_MODE_REPLACE")]
    Replace,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for LayerMode {
    type GlibType = ffi::GimpLayerMode;

    fn into_glib(self) -> ffi::GimpLayerMode {
match self {
            Self::NormalLegacy => ffi::GIMP_LAYER_MODE_NORMAL_LEGACY,
            Self::Dissolve => ffi::GIMP_LAYER_MODE_DISSOLVE,
            Self::BehindLegacy => ffi::GIMP_LAYER_MODE_BEHIND_LEGACY,
            Self::MultiplyLegacy => ffi::GIMP_LAYER_MODE_MULTIPLY_LEGACY,
            Self::ScreenLegacy => ffi::GIMP_LAYER_MODE_SCREEN_LEGACY,
            Self::OverlayLegacy => ffi::GIMP_LAYER_MODE_OVERLAY_LEGACY,
            Self::DifferenceLegacy => ffi::GIMP_LAYER_MODE_DIFFERENCE_LEGACY,
            Self::AdditionLegacy => ffi::GIMP_LAYER_MODE_ADDITION_LEGACY,
            Self::SubtractLegacy => ffi::GIMP_LAYER_MODE_SUBTRACT_LEGACY,
            Self::DarkenOnlyLegacy => ffi::GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY,
            Self::LightenOnlyLegacy => ffi::GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY,
            Self::HsvHueLegacy => ffi::GIMP_LAYER_MODE_HSV_HUE_LEGACY,
            Self::HsvSaturationLegacy => ffi::GIMP_LAYER_MODE_HSV_SATURATION_LEGACY,
            Self::HslColorLegacy => ffi::GIMP_LAYER_MODE_HSL_COLOR_LEGACY,
            Self::HsvValueLegacy => ffi::GIMP_LAYER_MODE_HSV_VALUE_LEGACY,
            Self::DivideLegacy => ffi::GIMP_LAYER_MODE_DIVIDE_LEGACY,
            Self::DodgeLegacy => ffi::GIMP_LAYER_MODE_DODGE_LEGACY,
            Self::BurnLegacy => ffi::GIMP_LAYER_MODE_BURN_LEGACY,
            Self::HardlightLegacy => ffi::GIMP_LAYER_MODE_HARDLIGHT_LEGACY,
            Self::SoftlightLegacy => ffi::GIMP_LAYER_MODE_SOFTLIGHT_LEGACY,
            Self::GrainExtractLegacy => ffi::GIMP_LAYER_MODE_GRAIN_EXTRACT_LEGACY,
            Self::GrainMergeLegacy => ffi::GIMP_LAYER_MODE_GRAIN_MERGE_LEGACY,
            Self::ColorEraseLegacy => ffi::GIMP_LAYER_MODE_COLOR_ERASE_LEGACY,
            Self::Overlay => ffi::GIMP_LAYER_MODE_OVERLAY,
            Self::LchHue => ffi::GIMP_LAYER_MODE_LCH_HUE,
            Self::LchChroma => ffi::GIMP_LAYER_MODE_LCH_CHROMA,
            Self::LchColor => ffi::GIMP_LAYER_MODE_LCH_COLOR,
            Self::LchLightness => ffi::GIMP_LAYER_MODE_LCH_LIGHTNESS,
            Self::Normal => ffi::GIMP_LAYER_MODE_NORMAL,
            Self::Behind => ffi::GIMP_LAYER_MODE_BEHIND,
            Self::Multiply => ffi::GIMP_LAYER_MODE_MULTIPLY,
            Self::Screen => ffi::GIMP_LAYER_MODE_SCREEN,
            Self::Difference => ffi::GIMP_LAYER_MODE_DIFFERENCE,
            Self::Addition => ffi::GIMP_LAYER_MODE_ADDITION,
            Self::Subtract => ffi::GIMP_LAYER_MODE_SUBTRACT,
            Self::DarkenOnly => ffi::GIMP_LAYER_MODE_DARKEN_ONLY,
            Self::LightenOnly => ffi::GIMP_LAYER_MODE_LIGHTEN_ONLY,
            Self::HsvHue => ffi::GIMP_LAYER_MODE_HSV_HUE,
            Self::HsvSaturation => ffi::GIMP_LAYER_MODE_HSV_SATURATION,
            Self::HslColor => ffi::GIMP_LAYER_MODE_HSL_COLOR,
            Self::HsvValue => ffi::GIMP_LAYER_MODE_HSV_VALUE,
            Self::Divide => ffi::GIMP_LAYER_MODE_DIVIDE,
            Self::Dodge => ffi::GIMP_LAYER_MODE_DODGE,
            Self::Burn => ffi::GIMP_LAYER_MODE_BURN,
            Self::Hardlight => ffi::GIMP_LAYER_MODE_HARDLIGHT,
            Self::Softlight => ffi::GIMP_LAYER_MODE_SOFTLIGHT,
            Self::GrainExtract => ffi::GIMP_LAYER_MODE_GRAIN_EXTRACT,
            Self::GrainMerge => ffi::GIMP_LAYER_MODE_GRAIN_MERGE,
            Self::VividLight => ffi::GIMP_LAYER_MODE_VIVID_LIGHT,
            Self::PinLight => ffi::GIMP_LAYER_MODE_PIN_LIGHT,
            Self::LinearLight => ffi::GIMP_LAYER_MODE_LINEAR_LIGHT,
            Self::HardMix => ffi::GIMP_LAYER_MODE_HARD_MIX,
            Self::Exclusion => ffi::GIMP_LAYER_MODE_EXCLUSION,
            Self::LinearBurn => ffi::GIMP_LAYER_MODE_LINEAR_BURN,
            Self::LumaDarkenOnly => ffi::GIMP_LAYER_MODE_LUMA_DARKEN_ONLY,
            Self::LumaLightenOnly => ffi::GIMP_LAYER_MODE_LUMA_LIGHTEN_ONLY,
            Self::Luminance => ffi::GIMP_LAYER_MODE_LUMINANCE,
            Self::ColorErase => ffi::GIMP_LAYER_MODE_COLOR_ERASE,
            Self::Erase => ffi::GIMP_LAYER_MODE_ERASE,
            Self::Merge => ffi::GIMP_LAYER_MODE_MERGE,
            Self::Split => ffi::GIMP_LAYER_MODE_SPLIT,
            Self::PassThrough => ffi::GIMP_LAYER_MODE_PASS_THROUGH,
            Self::Replace => ffi::GIMP_LAYER_MODE_REPLACE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpLayerMode> for LayerMode {
    unsafe fn from_glib(value: ffi::GimpLayerMode) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_LAYER_MODE_NORMAL_LEGACY => Self::NormalLegacy,
            ffi::GIMP_LAYER_MODE_DISSOLVE => Self::Dissolve,
            ffi::GIMP_LAYER_MODE_BEHIND_LEGACY => Self::BehindLegacy,
            ffi::GIMP_LAYER_MODE_MULTIPLY_LEGACY => Self::MultiplyLegacy,
            ffi::GIMP_LAYER_MODE_SCREEN_LEGACY => Self::ScreenLegacy,
            ffi::GIMP_LAYER_MODE_OVERLAY_LEGACY => Self::OverlayLegacy,
            ffi::GIMP_LAYER_MODE_DIFFERENCE_LEGACY => Self::DifferenceLegacy,
            ffi::GIMP_LAYER_MODE_ADDITION_LEGACY => Self::AdditionLegacy,
            ffi::GIMP_LAYER_MODE_SUBTRACT_LEGACY => Self::SubtractLegacy,
            ffi::GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY => Self::DarkenOnlyLegacy,
            ffi::GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY => Self::LightenOnlyLegacy,
            ffi::GIMP_LAYER_MODE_HSV_HUE_LEGACY => Self::HsvHueLegacy,
            ffi::GIMP_LAYER_MODE_HSV_SATURATION_LEGACY => Self::HsvSaturationLegacy,
            ffi::GIMP_LAYER_MODE_HSL_COLOR_LEGACY => Self::HslColorLegacy,
            ffi::GIMP_LAYER_MODE_HSV_VALUE_LEGACY => Self::HsvValueLegacy,
            ffi::GIMP_LAYER_MODE_DIVIDE_LEGACY => Self::DivideLegacy,
            ffi::GIMP_LAYER_MODE_DODGE_LEGACY => Self::DodgeLegacy,
            ffi::GIMP_LAYER_MODE_BURN_LEGACY => Self::BurnLegacy,
            ffi::GIMP_LAYER_MODE_HARDLIGHT_LEGACY => Self::HardlightLegacy,
            ffi::GIMP_LAYER_MODE_SOFTLIGHT_LEGACY => Self::SoftlightLegacy,
            ffi::GIMP_LAYER_MODE_GRAIN_EXTRACT_LEGACY => Self::GrainExtractLegacy,
            ffi::GIMP_LAYER_MODE_GRAIN_MERGE_LEGACY => Self::GrainMergeLegacy,
            ffi::GIMP_LAYER_MODE_COLOR_ERASE_LEGACY => Self::ColorEraseLegacy,
            ffi::GIMP_LAYER_MODE_OVERLAY => Self::Overlay,
            ffi::GIMP_LAYER_MODE_LCH_HUE => Self::LchHue,
            ffi::GIMP_LAYER_MODE_LCH_CHROMA => Self::LchChroma,
            ffi::GIMP_LAYER_MODE_LCH_COLOR => Self::LchColor,
            ffi::GIMP_LAYER_MODE_LCH_LIGHTNESS => Self::LchLightness,
            ffi::GIMP_LAYER_MODE_NORMAL => Self::Normal,
            ffi::GIMP_LAYER_MODE_BEHIND => Self::Behind,
            ffi::GIMP_LAYER_MODE_MULTIPLY => Self::Multiply,
            ffi::GIMP_LAYER_MODE_SCREEN => Self::Screen,
            ffi::GIMP_LAYER_MODE_DIFFERENCE => Self::Difference,
            ffi::GIMP_LAYER_MODE_ADDITION => Self::Addition,
            ffi::GIMP_LAYER_MODE_SUBTRACT => Self::Subtract,
            ffi::GIMP_LAYER_MODE_DARKEN_ONLY => Self::DarkenOnly,
            ffi::GIMP_LAYER_MODE_LIGHTEN_ONLY => Self::LightenOnly,
            ffi::GIMP_LAYER_MODE_HSV_HUE => Self::HsvHue,
            ffi::GIMP_LAYER_MODE_HSV_SATURATION => Self::HsvSaturation,
            ffi::GIMP_LAYER_MODE_HSL_COLOR => Self::HslColor,
            ffi::GIMP_LAYER_MODE_HSV_VALUE => Self::HsvValue,
            ffi::GIMP_LAYER_MODE_DIVIDE => Self::Divide,
            ffi::GIMP_LAYER_MODE_DODGE => Self::Dodge,
            ffi::GIMP_LAYER_MODE_BURN => Self::Burn,
            ffi::GIMP_LAYER_MODE_HARDLIGHT => Self::Hardlight,
            ffi::GIMP_LAYER_MODE_SOFTLIGHT => Self::Softlight,
            ffi::GIMP_LAYER_MODE_GRAIN_EXTRACT => Self::GrainExtract,
            ffi::GIMP_LAYER_MODE_GRAIN_MERGE => Self::GrainMerge,
            ffi::GIMP_LAYER_MODE_VIVID_LIGHT => Self::VividLight,
            ffi::GIMP_LAYER_MODE_PIN_LIGHT => Self::PinLight,
            ffi::GIMP_LAYER_MODE_LINEAR_LIGHT => Self::LinearLight,
            ffi::GIMP_LAYER_MODE_HARD_MIX => Self::HardMix,
            ffi::GIMP_LAYER_MODE_EXCLUSION => Self::Exclusion,
            ffi::GIMP_LAYER_MODE_LINEAR_BURN => Self::LinearBurn,
            ffi::GIMP_LAYER_MODE_LUMA_DARKEN_ONLY => Self::LumaDarkenOnly,
            ffi::GIMP_LAYER_MODE_LUMA_LIGHTEN_ONLY => Self::LumaLightenOnly,
            ffi::GIMP_LAYER_MODE_LUMINANCE => Self::Luminance,
            ffi::GIMP_LAYER_MODE_COLOR_ERASE => Self::ColorErase,
            ffi::GIMP_LAYER_MODE_ERASE => Self::Erase,
            ffi::GIMP_LAYER_MODE_MERGE => Self::Merge,
            ffi::GIMP_LAYER_MODE_SPLIT => Self::Split,
            ffi::GIMP_LAYER_MODE_PASS_THROUGH => Self::PassThrough,
            ffi::GIMP_LAYER_MODE_REPLACE => Self::Replace,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for LayerMode {
                #[inline]
    #[doc(alias = "gimp_layer_mode_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_layer_mode_get_type()) }
                }
            }

impl glib::HasParamSpec for LayerMode {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for LayerMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for LayerMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LayerMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<LayerMode> for glib::Value {
    #[inline]
    fn from(v: LayerMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Types of merging layers.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpMergeType")]
pub enum MergeType {
    /// Expanded as necessary
    #[doc(alias = "GIMP_EXPAND_AS_NECESSARY")]
    ExpandAsNecessary,
    /// Clipped to image
    #[doc(alias = "GIMP_CLIP_TO_IMAGE")]
    ClipToImage,
    /// Clipped to bottom layer
    #[doc(alias = "GIMP_CLIP_TO_BOTTOM_LAYER")]
    ClipToBottomLayer,
    /// Flatten
    #[doc(alias = "GIMP_FLATTEN_IMAGE")]
    FlattenImage,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MergeType {
    type GlibType = ffi::GimpMergeType;

    #[inline]
fn into_glib(self) -> ffi::GimpMergeType {
match self {
            Self::ExpandAsNecessary => ffi::GIMP_EXPAND_AS_NECESSARY,
            Self::ClipToImage => ffi::GIMP_CLIP_TO_IMAGE,
            Self::ClipToBottomLayer => ffi::GIMP_CLIP_TO_BOTTOM_LAYER,
            Self::FlattenImage => ffi::GIMP_FLATTEN_IMAGE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpMergeType> for MergeType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpMergeType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_EXPAND_AS_NECESSARY => Self::ExpandAsNecessary,
            ffi::GIMP_CLIP_TO_IMAGE => Self::ClipToImage,
            ffi::GIMP_CLIP_TO_BOTTOM_LAYER => Self::ClipToBottomLayer,
            ffi::GIMP_FLATTEN_IMAGE => Self::FlattenImage,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for MergeType {
                #[inline]
    #[doc(alias = "gimp_merge_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_merge_type_get_type()) }
                }
            }

impl glib::HasParamSpec for MergeType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for MergeType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MergeType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for MergeType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MergeType> for glib::Value {
    #[inline]
    fn from(v: MergeType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Orientations for various purposes.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpOrientationType")]
pub enum OrientationType {
    /// Horizontal
    #[doc(alias = "GIMP_ORIENTATION_HORIZONTAL")]
    Horizontal,
    /// Vertical
    #[doc(alias = "GIMP_ORIENTATION_VERTICAL")]
    Vertical,
    /// Unknown
    #[doc(alias = "GIMP_ORIENTATION_UNKNOWN")]
    Unknown,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for OrientationType {
    type GlibType = ffi::GimpOrientationType;

    #[inline]
fn into_glib(self) -> ffi::GimpOrientationType {
match self {
            Self::Horizontal => ffi::GIMP_ORIENTATION_HORIZONTAL,
            Self::Vertical => ffi::GIMP_ORIENTATION_VERTICAL,
            Self::Unknown => ffi::GIMP_ORIENTATION_UNKNOWN,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpOrientationType> for OrientationType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpOrientationType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_ORIENTATION_HORIZONTAL => Self::Horizontal,
            ffi::GIMP_ORIENTATION_VERTICAL => Self::Vertical,
            ffi::GIMP_ORIENTATION_UNKNOWN => Self::Unknown,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for OrientationType {
                #[inline]
    #[doc(alias = "gimp_orientation_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_orientation_type_get_type()) }
                }
            }

impl glib::HasParamSpec for OrientationType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for OrientationType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for OrientationType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for OrientationType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<OrientationType> for glib::Value {
    #[inline]
    fn from(v: OrientationType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// PDB error handlers.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpPDBErrorHandler")]
pub enum PDBErrorHandler {
    /// Internal
    #[doc(alias = "GIMP_PDB_ERROR_HANDLER_INTERNAL")]
    Internal,
    /// Plug-In
    #[doc(alias = "GIMP_PDB_ERROR_HANDLER_PLUGIN")]
    Plugin,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PDBErrorHandler {
    type GlibType = ffi::GimpPDBErrorHandler;

    #[inline]
fn into_glib(self) -> ffi::GimpPDBErrorHandler {
match self {
            Self::Internal => ffi::GIMP_PDB_ERROR_HANDLER_INTERNAL,
            Self::Plugin => ffi::GIMP_PDB_ERROR_HANDLER_PLUGIN,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpPDBErrorHandler> for PDBErrorHandler {
    #[inline]
unsafe fn from_glib(value: ffi::GimpPDBErrorHandler) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_PDB_ERROR_HANDLER_INTERNAL => Self::Internal,
            ffi::GIMP_PDB_ERROR_HANDLER_PLUGIN => Self::Plugin,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for PDBErrorHandler {
                #[inline]
    #[doc(alias = "gimp_pdb_error_handler_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_pdb_error_handler_get_type()) }
                }
            }

impl glib::HasParamSpec for PDBErrorHandler {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for PDBErrorHandler {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PDBErrorHandler {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PDBErrorHandler {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PDBErrorHandler> for glib::Value {
    #[inline]
    fn from(v: PDBErrorHandler) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Types of PDB procedures.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpPDBProcType")]
pub enum PDBProcType {
    /// Internal GIMP procedure
    #[doc(alias = "GIMP_PDB_PROC_TYPE_INTERNAL")]
    Internal,
    /// GIMP Plug-In
    #[doc(alias = "GIMP_PDB_PROC_TYPE_PLUGIN")]
    Plugin,
    /// GIMP Persistent Plug-in
    #[doc(alias = "GIMP_PDB_PROC_TYPE_PERSISTENT")]
    Persistent,
    /// Temporary Procedure
    #[doc(alias = "GIMP_PDB_PROC_TYPE_TEMPORARY")]
    Temporary,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PDBProcType {
    type GlibType = ffi::GimpPDBProcType;

    #[inline]
fn into_glib(self) -> ffi::GimpPDBProcType {
match self {
            Self::Internal => ffi::GIMP_PDB_PROC_TYPE_INTERNAL,
            Self::Plugin => ffi::GIMP_PDB_PROC_TYPE_PLUGIN,
            Self::Persistent => ffi::GIMP_PDB_PROC_TYPE_PERSISTENT,
            Self::Temporary => ffi::GIMP_PDB_PROC_TYPE_TEMPORARY,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpPDBProcType> for PDBProcType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpPDBProcType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_PDB_PROC_TYPE_INTERNAL => Self::Internal,
            ffi::GIMP_PDB_PROC_TYPE_PLUGIN => Self::Plugin,
            ffi::GIMP_PDB_PROC_TYPE_PERSISTENT => Self::Persistent,
            ffi::GIMP_PDB_PROC_TYPE_TEMPORARY => Self::Temporary,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for PDBProcType {
                #[inline]
    #[doc(alias = "gimp_pdb_proc_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_pdb_proc_type_get_type()) }
                }
            }

impl glib::HasParamSpec for PDBProcType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for PDBProcType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PDBProcType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PDBProcType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PDBProcType> for glib::Value {
    #[inline]
    fn from(v: PDBProcType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Return status of PDB calls.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpPDBStatusType")]
pub enum PDBStatusType {
    /// Execution error
    #[doc(alias = "GIMP_PDB_EXECUTION_ERROR")]
    ExecutionError,
    /// Calling error
    #[doc(alias = "GIMP_PDB_CALLING_ERROR")]
    CallingError,
    /// Pass through
    #[doc(alias = "GIMP_PDB_PASS_THROUGH")]
    PassThrough,
    /// Success
    #[doc(alias = "GIMP_PDB_SUCCESS")]
    Success,
    /// User cancel
    #[doc(alias = "GIMP_PDB_CANCEL")]
    Cancel,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PDBStatusType {
    type GlibType = ffi::GimpPDBStatusType;

    #[inline]
fn into_glib(self) -> ffi::GimpPDBStatusType {
match self {
            Self::ExecutionError => ffi::GIMP_PDB_EXECUTION_ERROR,
            Self::CallingError => ffi::GIMP_PDB_CALLING_ERROR,
            Self::PassThrough => ffi::GIMP_PDB_PASS_THROUGH,
            Self::Success => ffi::GIMP_PDB_SUCCESS,
            Self::Cancel => ffi::GIMP_PDB_CANCEL,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpPDBStatusType> for PDBStatusType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpPDBStatusType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_PDB_EXECUTION_ERROR => Self::ExecutionError,
            ffi::GIMP_PDB_CALLING_ERROR => Self::CallingError,
            ffi::GIMP_PDB_PASS_THROUGH => Self::PassThrough,
            ffi::GIMP_PDB_SUCCESS => Self::Success,
            ffi::GIMP_PDB_CANCEL => Self::Cancel,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for PDBStatusType {
                #[inline]
    #[doc(alias = "gimp_pdb_status_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_pdb_status_type_get_type()) }
                }
            }

impl glib::HasParamSpec for PDBStatusType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for PDBStatusType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PDBStatusType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PDBStatusType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PDBStatusType> for glib::Value {
    #[inline]
    fn from(v: PDBStatusType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// How to deal with transparency when creating thubnail pixbufs from
/// images and drawables.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpPixbufTransparency")]
pub enum PixbufTransparency {
    /// Create a pixbuf with alpha
    #[doc(alias = "GIMP_PIXBUF_KEEP_ALPHA")]
    KeepAlpha,
    /// Show transparency as small checks
    #[doc(alias = "GIMP_PIXBUF_SMALL_CHECKS")]
    SmallChecks,
    /// Show transparency as large checks
    #[doc(alias = "GIMP_PIXBUF_LARGE_CHECKS")]
    LargeChecks,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PixbufTransparency {
    type GlibType = ffi::GimpPixbufTransparency;

    #[inline]
fn into_glib(self) -> ffi::GimpPixbufTransparency {
match self {
            Self::KeepAlpha => ffi::GIMP_PIXBUF_KEEP_ALPHA,
            Self::SmallChecks => ffi::GIMP_PIXBUF_SMALL_CHECKS,
            Self::LargeChecks => ffi::GIMP_PIXBUF_LARGE_CHECKS,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpPixbufTransparency> for PixbufTransparency {
    #[inline]
unsafe fn from_glib(value: ffi::GimpPixbufTransparency) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_PIXBUF_KEEP_ALPHA => Self::KeepAlpha,
            ffi::GIMP_PIXBUF_SMALL_CHECKS => Self::SmallChecks,
            ffi::GIMP_PIXBUF_LARGE_CHECKS => Self::LargeChecks,
            value => Self::__Unknown(value),
}
}
}

/// Precisions for pixel encoding.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpPrecision")]
pub enum Precision {
    /// 8-bit linear integer
    #[doc(alias = "GIMP_PRECISION_U8_LINEAR")]
    U8Linear,
    /// 8-bit non-linear integer
    #[doc(alias = "GIMP_PRECISION_U8_NON_LINEAR")]
    U8NonLinear,
    /// 8-bit perceptual integer
    #[doc(alias = "GIMP_PRECISION_U8_PERCEPTUAL")]
    U8Perceptual,
    /// 16-bit linear integer
    #[doc(alias = "GIMP_PRECISION_U16_LINEAR")]
    U16Linear,
    /// 16-bit non-linear integer
    #[doc(alias = "GIMP_PRECISION_U16_NON_LINEAR")]
    U16NonLinear,
    /// 16-bit perceptual integer
    #[doc(alias = "GIMP_PRECISION_U16_PERCEPTUAL")]
    U16Perceptual,
    /// 32-bit linear integer
    #[doc(alias = "GIMP_PRECISION_U32_LINEAR")]
    U32Linear,
    /// 32-bit non-linear integer
    #[doc(alias = "GIMP_PRECISION_U32_NON_LINEAR")]
    U32NonLinear,
    /// 32-bit perceptual integer
    #[doc(alias = "GIMP_PRECISION_U32_PERCEPTUAL")]
    U32Perceptual,
    /// 16-bit linear floating point
    #[doc(alias = "GIMP_PRECISION_HALF_LINEAR")]
    HalfLinear,
    /// 16-bit non-linear floating point
    #[doc(alias = "GIMP_PRECISION_HALF_NON_LINEAR")]
    HalfNonLinear,
    /// 16-bit perceptual floating point
    #[doc(alias = "GIMP_PRECISION_HALF_PERCEPTUAL")]
    HalfPerceptual,
    /// 32-bit linear floating point
    #[doc(alias = "GIMP_PRECISION_FLOAT_LINEAR")]
    FloatLinear,
    /// 32-bit non-linear floating point
    #[doc(alias = "GIMP_PRECISION_FLOAT_NON_LINEAR")]
    FloatNonLinear,
    /// 32-bit perceptual floating point
    #[doc(alias = "GIMP_PRECISION_FLOAT_PERCEPTUAL")]
    FloatPerceptual,
    /// 64-bit linear floating point
    #[doc(alias = "GIMP_PRECISION_DOUBLE_LINEAR")]
    DoubleLinear,
    /// 64-bit non-linear floating point
    #[doc(alias = "GIMP_PRECISION_DOUBLE_NON_LINEAR")]
    DoubleNonLinear,
    /// 64-bit perceptual floating point
    #[doc(alias = "GIMP_PRECISION_DOUBLE_PERCEPTUAL")]
    DoublePerceptual,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Precision {
    type GlibType = ffi::GimpPrecision;

    fn into_glib(self) -> ffi::GimpPrecision {
match self {
            Self::U8Linear => ffi::GIMP_PRECISION_U8_LINEAR,
            Self::U8NonLinear => ffi::GIMP_PRECISION_U8_NON_LINEAR,
            Self::U8Perceptual => ffi::GIMP_PRECISION_U8_PERCEPTUAL,
            Self::U16Linear => ffi::GIMP_PRECISION_U16_LINEAR,
            Self::U16NonLinear => ffi::GIMP_PRECISION_U16_NON_LINEAR,
            Self::U16Perceptual => ffi::GIMP_PRECISION_U16_PERCEPTUAL,
            Self::U32Linear => ffi::GIMP_PRECISION_U32_LINEAR,
            Self::U32NonLinear => ffi::GIMP_PRECISION_U32_NON_LINEAR,
            Self::U32Perceptual => ffi::GIMP_PRECISION_U32_PERCEPTUAL,
            Self::HalfLinear => ffi::GIMP_PRECISION_HALF_LINEAR,
            Self::HalfNonLinear => ffi::GIMP_PRECISION_HALF_NON_LINEAR,
            Self::HalfPerceptual => ffi::GIMP_PRECISION_HALF_PERCEPTUAL,
            Self::FloatLinear => ffi::GIMP_PRECISION_FLOAT_LINEAR,
            Self::FloatNonLinear => ffi::GIMP_PRECISION_FLOAT_NON_LINEAR,
            Self::FloatPerceptual => ffi::GIMP_PRECISION_FLOAT_PERCEPTUAL,
            Self::DoubleLinear => ffi::GIMP_PRECISION_DOUBLE_LINEAR,
            Self::DoubleNonLinear => ffi::GIMP_PRECISION_DOUBLE_NON_LINEAR,
            Self::DoublePerceptual => ffi::GIMP_PRECISION_DOUBLE_PERCEPTUAL,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpPrecision> for Precision {
    unsafe fn from_glib(value: ffi::GimpPrecision) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_PRECISION_U8_LINEAR => Self::U8Linear,
            ffi::GIMP_PRECISION_U8_NON_LINEAR => Self::U8NonLinear,
            ffi::GIMP_PRECISION_U8_PERCEPTUAL => Self::U8Perceptual,
            ffi::GIMP_PRECISION_U16_LINEAR => Self::U16Linear,
            ffi::GIMP_PRECISION_U16_NON_LINEAR => Self::U16NonLinear,
            ffi::GIMP_PRECISION_U16_PERCEPTUAL => Self::U16Perceptual,
            ffi::GIMP_PRECISION_U32_LINEAR => Self::U32Linear,
            ffi::GIMP_PRECISION_U32_NON_LINEAR => Self::U32NonLinear,
            ffi::GIMP_PRECISION_U32_PERCEPTUAL => Self::U32Perceptual,
            ffi::GIMP_PRECISION_HALF_LINEAR => Self::HalfLinear,
            ffi::GIMP_PRECISION_HALF_NON_LINEAR => Self::HalfNonLinear,
            ffi::GIMP_PRECISION_HALF_PERCEPTUAL => Self::HalfPerceptual,
            ffi::GIMP_PRECISION_FLOAT_LINEAR => Self::FloatLinear,
            ffi::GIMP_PRECISION_FLOAT_NON_LINEAR => Self::FloatNonLinear,
            ffi::GIMP_PRECISION_FLOAT_PERCEPTUAL => Self::FloatPerceptual,
            ffi::GIMP_PRECISION_DOUBLE_LINEAR => Self::DoubleLinear,
            ffi::GIMP_PRECISION_DOUBLE_NON_LINEAR => Self::DoubleNonLinear,
            ffi::GIMP_PRECISION_DOUBLE_PERCEPTUAL => Self::DoublePerceptual,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for Precision {
                #[inline]
    #[doc(alias = "gimp_precision_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_precision_get_type()) }
                }
            }

impl glib::HasParamSpec for Precision {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for Precision {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Precision {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Precision {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Precision> for glib::Value {
    #[inline]
    fn from(v: Precision) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Types of simple rotations.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpRotationType")]
pub enum RotationType {
    /// 90 degrees
    #[doc(alias = "GIMP_ROTATE_DEGREES90")]
    Degrees90,
    /// 180 degrees
    #[doc(alias = "GIMP_ROTATE_DEGREES180")]
    Degrees180,
    /// 270 degrees
    #[doc(alias = "GIMP_ROTATE_DEGREES270")]
    Degrees270,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RotationType {
    type GlibType = ffi::GimpRotationType;

    #[inline]
fn into_glib(self) -> ffi::GimpRotationType {
match self {
            Self::Degrees90 => ffi::GIMP_ROTATE_DEGREES90,
            Self::Degrees180 => ffi::GIMP_ROTATE_DEGREES180,
            Self::Degrees270 => ffi::GIMP_ROTATE_DEGREES270,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpRotationType> for RotationType {
    #[inline]
unsafe fn from_glib(value: ffi::GimpRotationType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_ROTATE_DEGREES90 => Self::Degrees90,
            ffi::GIMP_ROTATE_DEGREES180 => Self::Degrees180,
            ffi::GIMP_ROTATE_DEGREES270 => Self::Degrees270,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for RotationType {
                #[inline]
    #[doc(alias = "gimp_rotation_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_rotation_type_get_type()) }
                }
            }

impl glib::HasParamSpec for RotationType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for RotationType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RotationType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RotationType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RotationType> for glib::Value {
    #[inline]
    fn from(v: RotationType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Run modes for plug-ins.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GimpRunMode")]
pub enum RunMode {
    /// Run interactively
    #[doc(alias = "GIMP_RUN_INTERACTIVE")]
    Interactive,
    /// Run non-interactively
    #[doc(alias = "GIMP_RUN_NONINTERACTIVE")]
    Noninteractive,
    /// Run with last used values
    #[doc(alias = "GIMP_RUN_WITH_LAST_VALS")]
    WithLastVals,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RunMode {
    type GlibType = ffi::GimpRunMode;

    #[inline]
fn into_glib(self) -> ffi::GimpRunMode {
match self {
            Self::Interactive => ffi::GIMP_RUN_INTERACTIVE,
            Self::Noninteractive => ffi::GIMP_RUN_NONINTERACTIVE,
            Self::WithLastVals => ffi::GIMP_RUN_WITH_LAST_VALS,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GimpRunMode> for RunMode {
    #[inline]
unsafe fn from_glib(value: ffi::GimpRunMode) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GIMP_RUN_INTERACTIVE => Self::Interactive,
            ffi::GIMP_RUN_NONINTERACTIVE => Self::Noninteractive,
            ffi::GIMP_RUN_WITH_LAST_VALS => Self::WithLastVals,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for RunMode {
                #[inline]
    #[doc(alias = "gimp_run_mode_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gimp_run_mode_get_type()) }
                }
            }

impl glib::HasParamSpec for RunMode {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for RunMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RunMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RunMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RunMode> for glib::Value {
    #[inline]
    fn from(v: RunMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

