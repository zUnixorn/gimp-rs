// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Brush,BrushApplicationMode,CapStyle,CheckSize,CheckType,Choice,CloneType,ColorConfig,ConfigPathType,ConvolveType,Display,DodgeBurnType,Drawable,ExportOptions,Font,Gradient,GradientBlendColorSpace,Image,ImageType,InkBlobType,InterpolationType,JoinStyle,Layer,LayerMode,Matrix2,MessageHandlerType,PDB,PaintApplicationMode,Palette,Parasite,Pattern,PlugIn,RepeatMode,Resource,RunMode,SelectCriterion,StrokeMethod,TransferMode,TransformDirection,TransformResize,Unit};
use glib::{prelude::*,translate::*};


//#[doc(alias = "gimp_adaptive_supersample_area")]
//pub fn adaptive_supersample_area<P: FnMut(f64, f64, f64), Q: FnMut(i32, i32, f64), R: FnMut(i32, i32, i32)>(x1: i32, y1: i32, x2: i32, y2: i32, max_depth: i32, threshold: f64, render_func: P, put_pixel_func: Q, progress_func: R) -> libc::c_ulong {
//    unsafe { TODO: call ffi:gimp_adaptive_supersample_area() }
//}

#[doc(alias = "gimp_airbrush")]
pub fn airbrush(drawable: &impl IsA<Drawable>, pressure: f64, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_airbrush(drawable.as_ref().to_glib_none().0, pressure, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_airbrush_default")]
pub fn airbrush_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_airbrush_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

//#[doc(alias = "gimp_any_to_utf8")]
//pub fn any_to_utf8(str: &[&str], warning_format: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_any_to_utf8() }
//}

#[doc(alias = "gimp_attach_parasite")]
pub fn attach_parasite(parasite: &Parasite) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_attach_parasite(parasite.to_glib_none().0))
    }
}

#[doc(alias = "gimp_babl_format_get_type")]
pub fn babl_format_get_type() -> glib::types::Type {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_babl_format_get_type())
    }
}

//#[doc(alias = "gimp_bilinear")]
//pub fn bilinear(x: f64, y: f64, values: /*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 21 }; 4) -> f64 {
//    unsafe { TODO: call ffi:gimp_bilinear() }
//}

//#[doc(alias = "gimp_bilinear_16")]
//pub fn bilinear_16(x: f64, y: f64, values: /*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 5 }; 4) -> u16 {
//    unsafe { TODO: call ffi:gimp_bilinear_16() }
//}

//#[doc(alias = "gimp_bilinear_32")]
//pub fn bilinear_32(x: f64, y: f64, values: /*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 7 }; 4) -> u32 {
//    unsafe { TODO: call ffi:gimp_bilinear_32() }
//}

//#[doc(alias = "gimp_bilinear_8")]
//pub fn bilinear_8(x: f64, y: f64, values: /*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 3 }; 4) -> u8 {
//    unsafe { TODO: call ffi:gimp_bilinear_8() }
//}

//#[doc(alias = "gimp_bilinear_rgb")]
//pub fn bilinear_rgb(x: f64, y: f64, values: /*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 21 }; 16, has_alpha: bool, retvalues: /*Unimplemented*/FixedArray TypeId { ns_id: 0, id: 21 }; 4) {
//    unsafe { TODO: call ffi:gimp_bilinear_rgb() }
//}

#[doc(alias = "gimp_bind_text_domain")]
pub fn bind_text_domain(domain_name: &str, dir_name: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_bind_text_domain(domain_name.to_glib_none().0, dir_name.to_glib_none().0);
    }
}

#[doc(alias = "gimp_brushes_close_popup")]
pub fn brushes_close_popup(brush_callback: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_brushes_close_popup(brush_callback.to_glib_none().0))
    }
}

#[doc(alias = "gimp_brushes_get_list")]
pub fn brushes_get_list(filter: &str) -> Vec<Brush> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_brushes_get_list(filter.to_glib_none().0))
    }
}

#[doc(alias = "gimp_brushes_popup")]
pub fn brushes_popup(brush_callback: &str, popup_title: &str, initial_brush: &Brush, parent_window: &glib::Bytes) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_brushes_popup(brush_callback.to_glib_none().0, popup_title.to_glib_none().0, initial_brush.to_glib_none().0, parent_window.to_glib_none().0))
    }
}

#[doc(alias = "gimp_brushes_refresh")]
pub fn brushes_refresh() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_brushes_refresh())
    }
}

#[doc(alias = "gimp_brushes_set_popup")]
pub fn brushes_set_popup(brush_callback: &str, brush: &Brush) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_brushes_set_popup(brush_callback.to_glib_none().0, brush.to_glib_none().0))
    }
}

#[doc(alias = "gimp_buffer_delete")]
pub fn buffer_delete(buffer_name: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_buffer_delete(buffer_name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_buffer_get_bytes")]
pub fn buffer_get_bytes(buffer_name: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_buffer_get_bytes(buffer_name.to_glib_none().0)
    }
}

#[doc(alias = "gimp_buffer_get_height")]
pub fn buffer_get_height(buffer_name: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_buffer_get_height(buffer_name.to_glib_none().0)
    }
}

#[doc(alias = "gimp_buffer_get_image_type")]
pub fn buffer_get_image_type(buffer_name: &str) -> ImageType {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_buffer_get_image_type(buffer_name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_buffer_get_width")]
pub fn buffer_get_width(buffer_name: &str) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_buffer_get_width(buffer_name.to_glib_none().0)
    }
}

#[doc(alias = "gimp_buffer_rename")]
pub fn buffer_rename(buffer_name: &str, new_name: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_buffer_rename(buffer_name.to_glib_none().0, new_name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_buffers_get_name_list")]
pub fn buffers_get_name_list(filter: &str) -> Vec<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::gimp_buffers_get_name_list(filter.to_glib_none().0))
    }
}

#[doc(alias = "gimp_cache_directory")]
pub fn cache_directory() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_cache_directory())
    }
}

#[doc(alias = "gimp_canonicalize_identifier")]
pub fn canonicalize_identifier(identifier: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_canonicalize_identifier(identifier.to_glib_none().0))
    }
}

#[doc(alias = "gimp_check_custom_color1")]
pub fn check_custom_color1() -> Option<gegl::Color> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_check_custom_color1())
    }
}

#[doc(alias = "gimp_check_custom_color2")]
pub fn check_custom_color2() -> Option<gegl::Color> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_check_custom_color2())
    }
}

#[doc(alias = "gimp_check_size")]
pub fn check_size() -> CheckSize {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_check_size())
    }
}

#[doc(alias = "gimp_check_type")]
pub fn check_type() -> CheckType {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_check_type())
    }
}

//#[doc(alias = "gimp_checks_get_colors")]
//pub fn checks_get_colors(type_: CheckType, color1: impl IsA<gegl::Color>, color2: impl IsA<gegl::Color>) {
//    unsafe { TODO: call ffi:gimp_checks_get_colors() }
//}

#[doc(alias = "gimp_clone")]
pub fn clone(drawable: &impl IsA<Drawable>, src_drawable: &impl IsA<Drawable>, clone_type: CloneType, src_x: f64, src_y: f64, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_clone(drawable.as_ref().to_glib_none().0, src_drawable.as_ref().to_glib_none().0, clone_type.into_glib(), src_x, src_y, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_clone_default")]
pub fn clone_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_clone_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_color_array_get_type")]
pub fn color_array_get_type() -> glib::types::Type {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_color_array_get_type())
    }
}

#[doc(alias = "gimp_color_is_out_of_self_gamut")]
pub fn color_is_out_of_self_gamut(color: &impl IsA<gegl::Color>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_color_is_out_of_self_gamut(color.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_color_is_perceptually_identical")]
pub fn color_is_perceptually_identical(color1: &impl IsA<gegl::Color>, color2: &impl IsA<gegl::Color>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_color_is_perceptually_identical(color1.as_ref().to_glib_none().0, color2.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_color_parse_css")]
pub fn color_parse_css(css: &str) -> Option<gegl::Color> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_color_parse_css(css.to_glib_none().0))
    }
}

#[doc(alias = "gimp_color_parse_hex")]
pub fn color_parse_hex(hex: &str) -> Option<gegl::Color> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_color_parse_hex(hex.to_glib_none().0))
    }
}

#[doc(alias = "gimp_color_parse_name")]
pub fn color_parse_name(name: &str) -> Option<gegl::Color> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_color_parse_name(name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_color_set_alpha")]
pub fn color_set_alpha(color: &impl IsA<gegl::Color>, alpha: f64) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_color_set_alpha(color.as_ref().to_glib_none().0, alpha);
    }
}

#[doc(alias = "gimp_context_are_dynamics_enabled")]
pub fn context_are_dynamics_enabled() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_are_dynamics_enabled())
    }
}

#[doc(alias = "gimp_context_enable_dynamics")]
pub fn context_enable_dynamics(enable: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_enable_dynamics(enable.into_glib()))
    }
}

#[doc(alias = "gimp_context_get_antialias")]
pub fn context_get_antialias() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_antialias())
    }
}

#[doc(alias = "gimp_context_get_background")]
pub fn context_get_background() -> Option<gegl::Color> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_context_get_background())
    }
}

#[doc(alias = "gimp_context_get_brush")]
pub fn context_get_brush() -> Option<Brush> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_context_get_brush())
    }
}

#[doc(alias = "gimp_context_get_brush_angle")]
pub fn context_get_brush_angle() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_brush_angle()
    }
}

#[doc(alias = "gimp_context_get_brush_aspect_ratio")]
pub fn context_get_brush_aspect_ratio() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_brush_aspect_ratio()
    }
}

#[doc(alias = "gimp_context_get_brush_force")]
pub fn context_get_brush_force() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_brush_force()
    }
}

#[doc(alias = "gimp_context_get_brush_hardness")]
pub fn context_get_brush_hardness() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_brush_hardness()
    }
}

#[doc(alias = "gimp_context_get_brush_size")]
pub fn context_get_brush_size() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_brush_size()
    }
}

#[doc(alias = "gimp_context_get_brush_spacing")]
pub fn context_get_brush_spacing() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_brush_spacing()
    }
}

#[doc(alias = "gimp_context_get_diagonal_neighbors")]
pub fn context_get_diagonal_neighbors() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_diagonal_neighbors())
    }
}

#[doc(alias = "gimp_context_get_distance_metric")]
pub fn context_get_distance_metric() -> gegl::DistanceMetric {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_distance_metric())
    }
}

#[doc(alias = "gimp_context_get_dynamics_name")]
pub fn context_get_dynamics_name() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_context_get_dynamics_name())
    }
}

#[doc(alias = "gimp_context_get_emulate_brush_dynamics")]
pub fn context_get_emulate_brush_dynamics() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_emulate_brush_dynamics())
    }
}

#[doc(alias = "gimp_context_get_feather")]
pub fn context_get_feather() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_feather())
    }
}

#[doc(alias = "gimp_context_get_feather_radius")]
pub fn context_get_feather_radius() -> Option<(f64, f64)> {
    assert_initialized_main_thread!();
    unsafe {
        let mut feather_radius_x = std::mem::MaybeUninit::uninit();
        let mut feather_radius_y = std::mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::gimp_context_get_feather_radius(feather_radius_x.as_mut_ptr(), feather_radius_y.as_mut_ptr()));
        if ret { Some((feather_radius_x.assume_init(), feather_radius_y.assume_init())) } else { None }
    }
}

#[doc(alias = "gimp_context_get_font")]
pub fn context_get_font() -> Option<Font> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_context_get_font())
    }
}

#[doc(alias = "gimp_context_get_foreground")]
pub fn context_get_foreground() -> Option<gegl::Color> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_context_get_foreground())
    }
}

#[doc(alias = "gimp_context_get_gradient")]
pub fn context_get_gradient() -> Option<Gradient> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_context_get_gradient())
    }
}

#[doc(alias = "gimp_context_get_gradient_blend_color_space")]
pub fn context_get_gradient_blend_color_space() -> GradientBlendColorSpace {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_gradient_blend_color_space())
    }
}

#[doc(alias = "gimp_context_get_gradient_repeat_mode")]
pub fn context_get_gradient_repeat_mode() -> RepeatMode {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_gradient_repeat_mode())
    }
}

#[doc(alias = "gimp_context_get_gradient_reverse")]
pub fn context_get_gradient_reverse() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_gradient_reverse())
    }
}

#[doc(alias = "gimp_context_get_ink_angle")]
pub fn context_get_ink_angle() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_ink_angle()
    }
}

#[doc(alias = "gimp_context_get_ink_blob_angle")]
pub fn context_get_ink_blob_angle() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_ink_blob_angle()
    }
}

#[doc(alias = "gimp_context_get_ink_blob_aspect_ratio")]
pub fn context_get_ink_blob_aspect_ratio() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_ink_blob_aspect_ratio()
    }
}

#[doc(alias = "gimp_context_get_ink_blob_type")]
pub fn context_get_ink_blob_type() -> InkBlobType {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_ink_blob_type())
    }
}

#[doc(alias = "gimp_context_get_ink_size")]
pub fn context_get_ink_size() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_ink_size()
    }
}

#[doc(alias = "gimp_context_get_ink_size_sensitivity")]
pub fn context_get_ink_size_sensitivity() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_ink_size_sensitivity()
    }
}

#[doc(alias = "gimp_context_get_ink_speed_sensitivity")]
pub fn context_get_ink_speed_sensitivity() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_ink_speed_sensitivity()
    }
}

#[doc(alias = "gimp_context_get_ink_tilt_sensitivity")]
pub fn context_get_ink_tilt_sensitivity() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_ink_tilt_sensitivity()
    }
}

#[doc(alias = "gimp_context_get_interpolation")]
pub fn context_get_interpolation() -> InterpolationType {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_interpolation())
    }
}

#[doc(alias = "gimp_context_get_line_cap_style")]
pub fn context_get_line_cap_style() -> CapStyle {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_line_cap_style())
    }
}

#[doc(alias = "gimp_context_get_line_dash_offset")]
pub fn context_get_line_dash_offset() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_line_dash_offset()
    }
}

#[doc(alias = "gimp_context_get_line_dash_pattern")]
pub fn context_get_line_dash_pattern() -> Option<Vec<f64>> {
    assert_initialized_main_thread!();
    unsafe {
        let mut num_dashes = std::mem::MaybeUninit::uninit();
        let mut dashes = std::ptr::null_mut();
        let ret = from_glib(ffi::gimp_context_get_line_dash_pattern(num_dashes.as_mut_ptr(), &mut dashes));
        if ret { Some(FromGlibContainer::from_glib_full_num(dashes, num_dashes.assume_init() as _)) } else { None }
    }
}

#[doc(alias = "gimp_context_get_line_join_style")]
pub fn context_get_line_join_style() -> JoinStyle {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_line_join_style())
    }
}

#[doc(alias = "gimp_context_get_line_miter_limit")]
pub fn context_get_line_miter_limit() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_line_miter_limit()
    }
}

#[doc(alias = "gimp_context_get_line_width")]
pub fn context_get_line_width() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_line_width()
    }
}

#[doc(alias = "gimp_context_get_line_width_unit")]
pub fn context_get_line_width_unit() -> Option<Unit> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_context_get_line_width_unit())
    }
}

#[doc(alias = "gimp_context_get_mypaint_brush")]
pub fn context_get_mypaint_brush() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_context_get_mypaint_brush())
    }
}

#[doc(alias = "gimp_context_get_opacity")]
pub fn context_get_opacity() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_opacity()
    }
}

#[doc(alias = "gimp_context_get_paint_method")]
pub fn context_get_paint_method() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_context_get_paint_method())
    }
}

#[doc(alias = "gimp_context_get_paint_mode")]
pub fn context_get_paint_mode() -> LayerMode {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_paint_mode())
    }
}

#[doc(alias = "gimp_context_get_palette")]
pub fn context_get_palette() -> Option<Palette> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_context_get_palette())
    }
}

#[doc(alias = "gimp_context_get_pattern")]
pub fn context_get_pattern() -> Option<Pattern> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_context_get_pattern())
    }
}

#[doc(alias = "gimp_context_get_sample_criterion")]
pub fn context_get_sample_criterion() -> SelectCriterion {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_sample_criterion())
    }
}

#[doc(alias = "gimp_context_get_sample_merged")]
pub fn context_get_sample_merged() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_sample_merged())
    }
}

#[doc(alias = "gimp_context_get_sample_threshold")]
pub fn context_get_sample_threshold() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_sample_threshold()
    }
}

#[doc(alias = "gimp_context_get_sample_threshold_int")]
pub fn context_get_sample_threshold_int() -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_context_get_sample_threshold_int()
    }
}

#[doc(alias = "gimp_context_get_sample_transparent")]
pub fn context_get_sample_transparent() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_sample_transparent())
    }
}

#[doc(alias = "gimp_context_get_stroke_method")]
pub fn context_get_stroke_method() -> StrokeMethod {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_stroke_method())
    }
}

#[doc(alias = "gimp_context_get_transform_direction")]
pub fn context_get_transform_direction() -> TransformDirection {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_transform_direction())
    }
}

#[doc(alias = "gimp_context_get_transform_resize")]
pub fn context_get_transform_resize() -> TransformResize {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_get_transform_resize())
    }
}

#[doc(alias = "gimp_context_list_paint_methods")]
pub fn context_list_paint_methods() -> Option<Vec<glib::GString>> {
    assert_initialized_main_thread!();
    unsafe {
        let mut paint_methods = std::ptr::null_mut();
        let ret = from_glib(ffi::gimp_context_list_paint_methods(&mut paint_methods));
        if ret { Some(FromGlibPtrContainer::from_glib_full(paint_methods)) } else { None }
    }
}

#[doc(alias = "gimp_context_pop")]
pub fn context_pop() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_pop())
    }
}

#[doc(alias = "gimp_context_push")]
pub fn context_push() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_push())
    }
}

#[doc(alias = "gimp_context_set_antialias")]
pub fn context_set_antialias(antialias: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_antialias(antialias.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_background")]
pub fn context_set_background(background: &impl IsA<gegl::Color>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_background(background.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_brush")]
pub fn context_set_brush(brush: &Brush) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush(brush.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_brush_angle")]
pub fn context_set_brush_angle(angle: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_angle(angle))
    }
}

#[doc(alias = "gimp_context_set_brush_aspect_ratio")]
pub fn context_set_brush_aspect_ratio(aspect: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_aspect_ratio(aspect))
    }
}

#[doc(alias = "gimp_context_set_brush_default_hardness")]
pub fn context_set_brush_default_hardness() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_default_hardness())
    }
}

#[doc(alias = "gimp_context_set_brush_default_size")]
pub fn context_set_brush_default_size() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_default_size())
    }
}

#[doc(alias = "gimp_context_set_brush_default_spacing")]
pub fn context_set_brush_default_spacing() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_default_spacing())
    }
}

#[doc(alias = "gimp_context_set_brush_force")]
pub fn context_set_brush_force(force: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_force(force))
    }
}

#[doc(alias = "gimp_context_set_brush_hardness")]
pub fn context_set_brush_hardness(hardness: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_hardness(hardness))
    }
}

#[doc(alias = "gimp_context_set_brush_size")]
pub fn context_set_brush_size(size: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_size(size))
    }
}

#[doc(alias = "gimp_context_set_brush_spacing")]
pub fn context_set_brush_spacing(spacing: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_brush_spacing(spacing))
    }
}

#[doc(alias = "gimp_context_set_default_colors")]
pub fn context_set_default_colors() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_default_colors())
    }
}

#[doc(alias = "gimp_context_set_defaults")]
pub fn context_set_defaults() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_defaults())
    }
}

#[doc(alias = "gimp_context_set_diagonal_neighbors")]
pub fn context_set_diagonal_neighbors(diagonal_neighbors: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_diagonal_neighbors(diagonal_neighbors.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_distance_metric")]
pub fn context_set_distance_metric(metric: gegl::DistanceMetric) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_distance_metric(metric.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_dynamics_name")]
pub fn context_set_dynamics_name(name: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_dynamics_name(name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_emulate_brush_dynamics")]
pub fn context_set_emulate_brush_dynamics(emulate_dynamics: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_emulate_brush_dynamics(emulate_dynamics.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_feather")]
pub fn context_set_feather(feather: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_feather(feather.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_feather_radius")]
pub fn context_set_feather_radius(feather_radius_x: f64, feather_radius_y: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_feather_radius(feather_radius_x, feather_radius_y))
    }
}

#[doc(alias = "gimp_context_set_font")]
pub fn context_set_font(font: &Font) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_context_set_font(font.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_foreground")]
pub fn context_set_foreground(foreground: &impl IsA<gegl::Color>) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_foreground(foreground.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_gradient")]
pub fn context_set_gradient(gradient: &Gradient) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient(gradient.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_gradient_blend_color_space")]
pub fn context_set_gradient_blend_color_space(blend_color_space: GradientBlendColorSpace) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient_blend_color_space(blend_color_space.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_gradient_fg_bg_hsv_ccw")]
pub fn context_set_gradient_fg_bg_hsv_ccw() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient_fg_bg_hsv_ccw())
    }
}

#[doc(alias = "gimp_context_set_gradient_fg_bg_hsv_cw")]
pub fn context_set_gradient_fg_bg_hsv_cw() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient_fg_bg_hsv_cw())
    }
}

#[doc(alias = "gimp_context_set_gradient_fg_bg_rgb")]
pub fn context_set_gradient_fg_bg_rgb() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient_fg_bg_rgb())
    }
}

#[doc(alias = "gimp_context_set_gradient_fg_transparent")]
pub fn context_set_gradient_fg_transparent() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient_fg_transparent())
    }
}

#[doc(alias = "gimp_context_set_gradient_repeat_mode")]
pub fn context_set_gradient_repeat_mode(repeat_mode: RepeatMode) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient_repeat_mode(repeat_mode.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_gradient_reverse")]
pub fn context_set_gradient_reverse(reverse: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_gradient_reverse(reverse.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_ink_angle")]
pub fn context_set_ink_angle(angle: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_angle(angle))
    }
}

#[doc(alias = "gimp_context_set_ink_blob_angle")]
pub fn context_set_ink_blob_angle(angle: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_blob_angle(angle))
    }
}

#[doc(alias = "gimp_context_set_ink_blob_aspect_ratio")]
pub fn context_set_ink_blob_aspect_ratio(aspect: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_blob_aspect_ratio(aspect))
    }
}

#[doc(alias = "gimp_context_set_ink_blob_type")]
pub fn context_set_ink_blob_type(type_: InkBlobType) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_blob_type(type_.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_ink_size")]
pub fn context_set_ink_size(size: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_size(size))
    }
}

#[doc(alias = "gimp_context_set_ink_size_sensitivity")]
pub fn context_set_ink_size_sensitivity(size: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_size_sensitivity(size))
    }
}

#[doc(alias = "gimp_context_set_ink_speed_sensitivity")]
pub fn context_set_ink_speed_sensitivity(speed: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_speed_sensitivity(speed))
    }
}

#[doc(alias = "gimp_context_set_ink_tilt_sensitivity")]
pub fn context_set_ink_tilt_sensitivity(tilt: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_ink_tilt_sensitivity(tilt))
    }
}

#[doc(alias = "gimp_context_set_interpolation")]
pub fn context_set_interpolation(interpolation: InterpolationType) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_interpolation(interpolation.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_line_cap_style")]
pub fn context_set_line_cap_style(cap_style: CapStyle) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_line_cap_style(cap_style.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_line_dash_offset")]
pub fn context_set_line_dash_offset(dash_offset: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_line_dash_offset(dash_offset))
    }
}

#[doc(alias = "gimp_context_set_line_dash_pattern")]
pub fn context_set_line_dash_pattern(dashes: &[f64]) -> bool {
    assert_initialized_main_thread!();
    let num_dashes = dashes.len() as _;
    unsafe {
        from_glib(ffi::gimp_context_set_line_dash_pattern(num_dashes, dashes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_line_join_style")]
pub fn context_set_line_join_style(join_style: JoinStyle) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_line_join_style(join_style.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_line_miter_limit")]
pub fn context_set_line_miter_limit(miter_limit: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_line_miter_limit(miter_limit))
    }
}

#[doc(alias = "gimp_context_set_line_width")]
pub fn context_set_line_width(line_width: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_line_width(line_width))
    }
}

#[doc(alias = "gimp_context_set_line_width_unit")]
pub fn context_set_line_width_unit(line_width_unit: &Unit) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_context_set_line_width_unit(line_width_unit.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_mypaint_brush")]
pub fn context_set_mypaint_brush(name: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_mypaint_brush(name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_opacity")]
pub fn context_set_opacity(opacity: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_opacity(opacity))
    }
}

#[doc(alias = "gimp_context_set_paint_method")]
pub fn context_set_paint_method(name: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_paint_method(name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_paint_mode")]
pub fn context_set_paint_mode(paint_mode: LayerMode) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_paint_mode(paint_mode.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_palette")]
pub fn context_set_palette(palette: &Palette) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_context_set_palette(palette.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_pattern")]
pub fn context_set_pattern(pattern: &Pattern) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_context_set_pattern(pattern.to_glib_none().0))
    }
}

#[doc(alias = "gimp_context_set_sample_criterion")]
pub fn context_set_sample_criterion(sample_criterion: SelectCriterion) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_sample_criterion(sample_criterion.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_sample_merged")]
pub fn context_set_sample_merged(sample_merged: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_sample_merged(sample_merged.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_sample_threshold")]
pub fn context_set_sample_threshold(sample_threshold: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_sample_threshold(sample_threshold))
    }
}

#[doc(alias = "gimp_context_set_sample_threshold_int")]
pub fn context_set_sample_threshold_int(sample_threshold: i32) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_sample_threshold_int(sample_threshold))
    }
}

#[doc(alias = "gimp_context_set_sample_transparent")]
pub fn context_set_sample_transparent(sample_transparent: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_sample_transparent(sample_transparent.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_stroke_method")]
pub fn context_set_stroke_method(stroke_method: StrokeMethod) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_stroke_method(stroke_method.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_transform_direction")]
pub fn context_set_transform_direction(transform_direction: TransformDirection) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_transform_direction(transform_direction.into_glib()))
    }
}

#[doc(alias = "gimp_context_set_transform_resize")]
pub fn context_set_transform_resize(transform_resize: TransformResize) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_set_transform_resize(transform_resize.into_glib()))
    }
}

#[doc(alias = "gimp_context_swap_colors")]
pub fn context_swap_colors() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_context_swap_colors())
    }
}

#[doc(alias = "gimp_convolve")]
pub fn convolve(drawable: &impl IsA<Drawable>, pressure: f64, convolve_type: ConvolveType, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_convolve(drawable.as_ref().to_glib_none().0, pressure, convolve_type.into_glib(), num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_convolve_default")]
pub fn convolve_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_convolve_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_core_object_array_get_type")]
pub fn core_object_array_get_type() -> glib::types::Type {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_core_object_array_get_type())
    }
}

//#[doc(alias = "gimp_cpu_accel_get_support")]
//pub fn cpu_accel_get_support() -> /*Ignored*/CpuAccelFlags {
//    unsafe { TODO: call ffi:gimp_cpu_accel_get_support() }
//}

#[doc(alias = "gimp_data_directory")]
pub fn data_directory() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_data_directory())
    }
}

//#[doc(alias = "gimp_data_directory_file")]
//pub fn data_directory_file(first_element: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<gio::File> {
//    unsafe { TODO: call ffi:gimp_data_directory_file() }
//}

#[doc(alias = "gimp_debug_timer_end")]
pub fn debug_timer_end() -> f64 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_debug_timer_end()
    }
}

#[doc(alias = "gimp_debug_timer_start")]
pub fn debug_timer_start() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_debug_timer_start())
    }
}

#[doc(alias = "gimp_default_display")]
pub fn default_display() -> Option<Display> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_default_display())
    }
}

#[doc(alias = "gimp_detach_parasite")]
pub fn detach_parasite(name: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_detach_parasite(name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_directory")]
pub fn directory() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_directory())
    }
}

//#[doc(alias = "gimp_directory_file")]
//pub fn directory_file(first_element: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<gio::File> {
//    unsafe { TODO: call ffi:gimp_directory_file() }
//}

#[doc(alias = "gimp_displays_flush")]
pub fn displays_flush() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_displays_flush())
    }
}

#[doc(alias = "gimp_displays_reconnect")]
pub fn displays_reconnect(old_image: &Image, new_image: &Image) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_displays_reconnect(old_image.to_glib_none().0, new_image.to_glib_none().0))
    }
}

#[doc(alias = "gimp_dodgeburn")]
pub fn dodgeburn(drawable: &impl IsA<Drawable>, exposure: f64, dodgeburn_type: DodgeBurnType, dodgeburn_mode: TransferMode, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_dodgeburn(drawable.as_ref().to_glib_none().0, exposure, dodgeburn_type.into_glib(), dodgeburn_mode.into_glib(), num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_dodgeburn_default")]
pub fn dodgeburn_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_dodgeburn_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_drawables_close_popup")]
pub fn drawables_close_popup(callback: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_drawables_close_popup(callback.to_glib_none().0))
    }
}

#[doc(alias = "gimp_drawables_popup")]
pub fn drawables_popup(callback: &str, popup_title: &str, drawable_type: &str, initial_drawable: &impl IsA<Drawable>, parent_window: &glib::Bytes) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_drawables_popup(callback.to_glib_none().0, popup_title.to_glib_none().0, drawable_type.to_glib_none().0, initial_drawable.as_ref().to_glib_none().0, parent_window.to_glib_none().0))
    }
}

#[doc(alias = "gimp_drawables_set_popup")]
pub fn drawables_set_popup(callback: &str, drawable: &impl IsA<Drawable>) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_drawables_set_popup(callback.to_glib_none().0, drawable.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_dynamics_get_name_list")]
pub fn dynamics_get_name_list(filter: &str) -> Vec<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::gimp_dynamics_get_name_list(filter.to_glib_none().0))
    }
}

#[doc(alias = "gimp_dynamics_refresh")]
pub fn dynamics_refresh() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_dynamics_refresh())
    }
}

#[doc(alias = "gimp_edit_copy_visible")]
pub fn edit_copy_visible(image: &Image) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_edit_copy_visible(image.to_glib_none().0))
    }
}

#[doc(alias = "gimp_edit_named_copy_visible")]
pub fn edit_named_copy_visible(image: &Image, buffer_name: &str) -> Option<glib::GString> {
    skip_assert_initialized!();
    unsafe {
        from_glib_full(ffi::gimp_edit_named_copy_visible(image.to_glib_none().0, buffer_name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_edit_named_paste")]
pub fn edit_named_paste(drawable: &impl IsA<Drawable>, buffer_name: &str, paste_into: bool) -> Option<Layer> {
    skip_assert_initialized!();
    unsafe {
        from_glib_none(ffi::gimp_edit_named_paste(drawable.as_ref().to_glib_none().0, buffer_name.to_glib_none().0, paste_into.into_glib()))
    }
}

#[doc(alias = "gimp_edit_named_paste_as_new_image")]
pub fn edit_named_paste_as_new_image(buffer_name: &str) -> Option<Image> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_edit_named_paste_as_new_image(buffer_name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_edit_paste")]
pub fn edit_paste(drawable: &impl IsA<Drawable>, paste_into: bool) -> Vec<Drawable> {
    skip_assert_initialized!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_edit_paste(drawable.as_ref().to_glib_none().0, paste_into.into_glib()))
    }
}

#[doc(alias = "gimp_edit_paste_as_new_image")]
pub fn edit_paste_as_new_image() -> Option<Image> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_edit_paste_as_new_image())
    }
}

//#[doc(alias = "gimp_enum_get_desc")]
//pub fn enum_get_desc(enum_class: /*Ignored*/&mut glib::EnumClass, value: i32) -> /*Ignored*/Option<EnumDesc> {
//    unsafe { TODO: call ffi:gimp_enum_get_desc() }
//}

//#[doc(alias = "gimp_enum_get_value_descriptions")]
//pub fn enum_get_value_descriptions(enum_type: glib::types::Type) -> /*Ignored*/Option<EnumDesc> {
//    unsafe { TODO: call ffi:gimp_enum_get_value_descriptions() }
//}

//#[doc(alias = "gimp_enum_set_value_descriptions")]
//pub fn enum_set_value_descriptions(enum_type: glib::types::Type, descriptions: /*Ignored*/&EnumDesc) {
//    unsafe { TODO: call ffi:gimp_enum_set_value_descriptions() }
//}

//#[doc(alias = "gimp_enum_value_get_abbrev")]
//pub fn enum_value_get_abbrev(enum_class: /*Ignored*/&mut glib::EnumClass, enum_value: &glib::EnumValue) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_enum_value_get_abbrev() }
//}

//#[doc(alias = "gimp_enum_value_get_desc")]
//pub fn enum_value_get_desc(enum_class: /*Ignored*/&mut glib::EnumClass, enum_value: &glib::EnumValue) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_enum_value_get_desc() }
//}

//#[doc(alias = "gimp_enum_value_get_help")]
//pub fn enum_value_get_help(enum_class: /*Ignored*/&mut glib::EnumClass, enum_value: &glib::EnumValue) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_enum_value_get_help() }
//}

#[doc(alias = "gimp_enums_get_type_names")]
pub fn enums_get_type_names() -> Vec<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        let mut n_type_names = std::mem::MaybeUninit::uninit();
        let ret = FromGlibContainer::from_glib_none_num(ffi::gimp_enums_get_type_names(n_type_names.as_mut_ptr()), n_type_names.assume_init() as _);
        ret
    }
}

#[doc(alias = "gimp_enums_init")]
pub fn enums_init() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_enums_init();
    }
}

#[doc(alias = "gimp_eraser")]
pub fn eraser(drawable: &impl IsA<Drawable>, strokes: &[f64], hardness: BrushApplicationMode, method: PaintApplicationMode) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_eraser(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0, hardness.into_glib(), method.into_glib()))
    }
}

#[doc(alias = "gimp_eraser_default")]
pub fn eraser_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_eraser_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_escape_uline")]
pub fn escape_uline(str: Option<&str>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_escape_uline(str.to_glib_none().0))
    }
}

#[doc(alias = "gimp_export_color_profile")]
pub fn export_color_profile() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_export_color_profile())
    }
}

#[doc(alias = "gimp_export_comment")]
pub fn export_comment() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_export_comment())
    }
}

#[doc(alias = "gimp_export_exif")]
pub fn export_exif() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_export_exif())
    }
}

#[doc(alias = "gimp_export_iptc")]
pub fn export_iptc() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_export_iptc())
    }
}

#[doc(alias = "gimp_export_thumbnail")]
pub fn export_thumbnail() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_export_thumbnail())
    }
}

#[doc(alias = "gimp_export_xmp")]
pub fn export_xmp() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_export_xmp())
    }
}

#[doc(alias = "gimp_file_get_config_path")]
pub fn file_get_config_path(file: &impl IsA<gio::File>) -> Result<glib::GString, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::gimp_file_get_config_path(file.as_ref().to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "gimp_file_get_utf8_name")]
pub fn file_get_utf8_name(file: &impl IsA<gio::File>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_file_get_utf8_name(file.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_file_has_extension")]
pub fn file_has_extension(file: &impl IsA<gio::File>, extension: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_file_has_extension(file.as_ref().to_glib_none().0, extension.to_glib_none().0))
    }
}

#[doc(alias = "gimp_file_load")]
pub fn file_load(run_mode: RunMode, file: &impl IsA<gio::File>) -> Option<Image> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_file_load(run_mode.into_glib(), file.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_file_load_layer")]
pub fn file_load_layer(run_mode: RunMode, image: &Image, file: &impl IsA<gio::File>) -> Option<Layer> {
    skip_assert_initialized!();
    unsafe {
        from_glib_none(ffi::gimp_file_load_layer(run_mode.into_glib(), image.to_glib_none().0, file.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_file_load_layers")]
pub fn file_load_layers(run_mode: RunMode, image: &Image, file: &impl IsA<gio::File>) -> Vec<Layer> {
    skip_assert_initialized!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_file_load_layers(run_mode.into_glib(), image.to_glib_none().0, file.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_file_new_for_config_path")]
pub fn file_new_for_config_path(path: &str) -> Result<Option<gio::File>, glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::gimp_file_new_for_config_path(path.to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "gimp_file_save")]
pub fn file_save(run_mode: RunMode, image: &Image, file: &impl IsA<gio::File>, options: Option<&ExportOptions>) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_file_save(run_mode.into_glib(), image.to_glib_none().0, file.as_ref().to_glib_none().0, options.to_glib_none().0))
    }
}

#[doc(alias = "gimp_file_save_thumbnail")]
pub fn file_save_thumbnail(image: &Image, file: &impl IsA<gio::File>) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_file_save_thumbnail(image.to_glib_none().0, file.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_file_show_in_file_manager")]
pub fn file_show_in_file_manager(file: &impl IsA<gio::File>) -> Result<(), glib::Error> {
    assert_initialized_main_thread!();
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::gimp_file_show_in_file_manager(file.as_ref().to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "gimp_filename_to_utf8")]
pub fn filename_to_utf8(filename: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_filename_to_utf8(filename.to_glib_none().0))
    }
}

//#[doc(alias = "gimp_flags_get_first_desc")]
//pub fn flags_get_first_desc(flags_class: /*Ignored*/&mut glib::FlagsClass, value: u32) -> /*Ignored*/Option<FlagsDesc> {
//    unsafe { TODO: call ffi:gimp_flags_get_first_desc() }
//}

//#[doc(alias = "gimp_flags_get_value_descriptions")]
//pub fn flags_get_value_descriptions(flags_type: glib::types::Type) -> /*Ignored*/Option<FlagsDesc> {
//    unsafe { TODO: call ffi:gimp_flags_get_value_descriptions() }
//}

//#[doc(alias = "gimp_flags_set_value_descriptions")]
//pub fn flags_set_value_descriptions(flags_type: glib::types::Type, descriptions: /*Ignored*/&FlagsDesc) {
//    unsafe { TODO: call ffi:gimp_flags_set_value_descriptions() }
//}

//#[doc(alias = "gimp_flags_value_get_abbrev")]
//pub fn flags_value_get_abbrev(flags_class: /*Ignored*/&mut glib::FlagsClass, flags_value: &glib::FlagsValue) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_flags_value_get_abbrev() }
//}

//#[doc(alias = "gimp_flags_value_get_desc")]
//pub fn flags_value_get_desc(flags_class: /*Ignored*/&mut glib::FlagsClass, flags_value: &glib::FlagsValue) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_flags_value_get_desc() }
//}

//#[doc(alias = "gimp_flags_value_get_help")]
//pub fn flags_value_get_help(flags_class: /*Ignored*/&mut glib::FlagsClass, flags_value: &glib::FlagsValue) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_flags_value_get_help() }
//}

#[doc(alias = "gimp_floating_sel_anchor")]
pub fn floating_sel_anchor(floating_sel: &impl IsA<Layer>) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_floating_sel_anchor(floating_sel.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_floating_sel_attach")]
pub fn floating_sel_attach(layer: &impl IsA<Layer>, drawable: &impl IsA<Drawable>) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_floating_sel_attach(layer.as_ref().to_glib_none().0, drawable.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_floating_sel_remove")]
pub fn floating_sel_remove(floating_sel: &impl IsA<Layer>) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_floating_sel_remove(floating_sel.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_floating_sel_to_layer")]
pub fn floating_sel_to_layer(floating_sel: &impl IsA<Layer>) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_floating_sel_to_layer(floating_sel.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_fonts_close_popup")]
pub fn fonts_close_popup(font_callback: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_fonts_close_popup(font_callback.to_glib_none().0))
    }
}

#[doc(alias = "gimp_fonts_get_list")]
pub fn fonts_get_list(filter: &str) -> Vec<Font> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_fonts_get_list(filter.to_glib_none().0))
    }
}

#[doc(alias = "gimp_fonts_popup")]
pub fn fonts_popup(font_callback: &str, popup_title: &str, initial_font: &Font, parent_window: &glib::Bytes) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_fonts_popup(font_callback.to_glib_none().0, popup_title.to_glib_none().0, initial_font.to_glib_none().0, parent_window.to_glib_none().0))
    }
}

#[doc(alias = "gimp_fonts_refresh")]
pub fn fonts_refresh() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_fonts_refresh())
    }
}

#[doc(alias = "gimp_fonts_set_popup")]
pub fn fonts_set_popup(font_callback: &str, font: &Font) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_fonts_set_popup(font_callback.to_glib_none().0, font.to_glib_none().0))
    }
}

#[doc(alias = "gimp_get_color_configuration")]
#[doc(alias = "get_color_configuration")]
pub fn color_configuration() -> Option<ColorConfig> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_get_color_configuration())
    }
}

#[doc(alias = "gimp_get_default_comment")]
#[doc(alias = "get_default_comment")]
pub fn default_comment() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_get_default_comment())
    }
}

#[doc(alias = "gimp_get_default_unit")]
#[doc(alias = "get_default_unit")]
pub fn default_unit() -> Option<Unit> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_get_default_unit())
    }
}

#[doc(alias = "gimp_get_images")]
#[doc(alias = "get_images")]
pub fn images() -> Vec<Image> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_get_images())
    }
}

#[doc(alias = "gimp_get_module_load_inhibit")]
#[doc(alias = "get_module_load_inhibit")]
pub fn module_load_inhibit() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_get_module_load_inhibit())
    }
}

#[doc(alias = "gimp_get_monitor_resolution")]
#[doc(alias = "get_monitor_resolution")]
pub fn monitor_resolution() -> Option<(f64, f64)> {
    assert_initialized_main_thread!();
    unsafe {
        let mut xres = std::mem::MaybeUninit::uninit();
        let mut yres = std::mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::gimp_get_monitor_resolution(xres.as_mut_ptr(), yres.as_mut_ptr()));
        if ret { Some((xres.assume_init(), yres.assume_init())) } else { None }
    }
}

#[doc(alias = "gimp_get_num_processors")]
#[doc(alias = "get_num_processors")]
pub fn num_processors() -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_get_num_processors()
    }
}

#[doc(alias = "gimp_get_parasite")]
#[doc(alias = "get_parasite")]
pub fn parasite(name: &str) -> Option<Parasite> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_get_parasite(name.to_glib_none().0))
    }
}

#[doc(alias = "gimp_get_parasite_list")]
#[doc(alias = "get_parasite_list")]
pub fn parasite_list() -> Vec<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::gimp_get_parasite_list())
    }
}

#[doc(alias = "gimp_get_pdb")]
#[doc(alias = "get_pdb")]
pub fn pdb() -> Option<PDB> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_get_pdb())
    }
}

#[doc(alias = "gimp_get_plug_in")]
#[doc(alias = "get_plug_in")]
pub fn plug_in() -> Option<PlugIn> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_get_plug_in())
    }
}

#[doc(alias = "gimp_get_progname")]
#[doc(alias = "get_progname")]
pub fn progname() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_get_progname())
    }
}

#[doc(alias = "gimp_getpid")]
pub fn getpid() -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_getpid()
    }
}

#[doc(alias = "gimp_gimprc_query")]
pub fn gimprc_query(token: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_gimprc_query(token.to_glib_none().0))
    }
}

#[doc(alias = "gimp_gimprc_set")]
pub fn gimprc_set(token: &str, value: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_gimprc_set(token.to_glib_none().0, value.to_glib_none().0))
    }
}

#[doc(alias = "gimp_gradients_close_popup")]
pub fn gradients_close_popup(gradient_callback: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_gradients_close_popup(gradient_callback.to_glib_none().0))
    }
}

#[doc(alias = "gimp_gradients_get_list")]
pub fn gradients_get_list(filter: &str) -> Vec<Gradient> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_gradients_get_list(filter.to_glib_none().0))
    }
}

#[doc(alias = "gimp_gradients_popup")]
pub fn gradients_popup(gradient_callback: &str, popup_title: &str, initial_gradient: &Gradient, parent_window: &glib::Bytes) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_gradients_popup(gradient_callback.to_glib_none().0, popup_title.to_glib_none().0, initial_gradient.to_glib_none().0, parent_window.to_glib_none().0))
    }
}

#[doc(alias = "gimp_gradients_refresh")]
pub fn gradients_refresh() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_gradients_refresh())
    }
}

#[doc(alias = "gimp_gradients_set_popup")]
pub fn gradients_set_popup(gradient_callback: &str, gradient: &Gradient) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_gradients_set_popup(gradient_callback.to_glib_none().0, gradient.to_glib_none().0))
    }
}

#[doc(alias = "gimp_heal")]
pub fn heal(drawable: &impl IsA<Drawable>, src_drawable: &impl IsA<Drawable>, src_x: f64, src_y: f64, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_heal(drawable.as_ref().to_glib_none().0, src_drawable.as_ref().to_glib_none().0, src_x, src_y, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_heal_default")]
pub fn heal_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_heal_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_help")]
pub fn help(help_domain: &str, help_id: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_help(help_domain.to_glib_none().0, help_id.to_glib_none().0))
    }
}

#[doc(alias = "gimp_icon_theme_dir")]
pub fn icon_theme_dir() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_icon_theme_dir())
    }
}

#[doc(alias = "gimp_installation_directory")]
pub fn installation_directory() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_installation_directory())
    }
}

//#[doc(alias = "gimp_installation_directory_file")]
//pub fn installation_directory_file(first_element: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<gio::File> {
//    unsafe { TODO: call ffi:gimp_installation_directory_file() }
//}

#[doc(alias = "gimp_is_canonical_identifier")]
pub fn is_canonical_identifier(identifier: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_is_canonical_identifier(identifier.to_glib_none().0))
    }
}

#[doc(alias = "gimp_list_images")]
pub fn list_images() -> Vec<Image> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_list_images())
    }
}

#[doc(alias = "gimp_locale_directory")]
pub fn locale_directory() -> Option<std::path::PathBuf> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_locale_directory())
    }
}

//#[doc(alias = "gimp_locale_directory_file")]
//pub fn locale_directory_file(first_element: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<gio::File> {
//    unsafe { TODO: call ffi:gimp_locale_directory_file() }
//}

#[doc(alias = "gimp_main")]
pub fn main(plug_in_type: glib::types::Type, argv: &[&str]) -> i32 {
    assert_initialized_main_thread!();
    let argc = argv.len() as _;
    unsafe {
        ffi::gimp_main(plug_in_type.into_glib(), argc, argv.to_glib_none().0)
    }
}

#[doc(alias = "gimp_message")]
pub fn message(message: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_message(message.to_glib_none().0))
    }
}

#[doc(alias = "gimp_message_get_handler")]
pub fn message_get_handler() -> MessageHandlerType {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_message_get_handler())
    }
}

#[doc(alias = "gimp_message_set_handler")]
pub fn message_set_handler(handler: MessageHandlerType) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_message_set_handler(handler.into_glib()))
    }
}

#[doc(alias = "gimp_monitor_number")]
pub fn monitor_number() -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_monitor_number()
    }
}

#[doc(alias = "gimp_paintbrush")]
pub fn paintbrush(drawable: &impl IsA<Drawable>, fade_out: f64, strokes: &[f64], method: PaintApplicationMode, gradient_length: f64) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_paintbrush(drawable.as_ref().to_glib_none().0, fade_out, num_strokes, strokes.to_glib_none().0, method.into_glib(), gradient_length))
    }
}

#[doc(alias = "gimp_paintbrush_default")]
pub fn paintbrush_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_paintbrush_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_palettes_close_popup")]
pub fn palettes_close_popup(palette_callback: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_palettes_close_popup(palette_callback.to_glib_none().0))
    }
}

#[doc(alias = "gimp_palettes_get_list")]
pub fn palettes_get_list(filter: &str) -> Vec<Palette> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_palettes_get_list(filter.to_glib_none().0))
    }
}

#[doc(alias = "gimp_palettes_popup")]
pub fn palettes_popup(palette_callback: &str, popup_title: &str, initial_palette: &Palette, parent_window: &glib::Bytes) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_palettes_popup(palette_callback.to_glib_none().0, popup_title.to_glib_none().0, initial_palette.to_glib_none().0, parent_window.to_glib_none().0))
    }
}

#[doc(alias = "gimp_palettes_refresh")]
pub fn palettes_refresh() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_palettes_refresh())
    }
}

#[doc(alias = "gimp_palettes_set_popup")]
pub fn palettes_set_popup(palette_callback: &str, palette: &Palette) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_palettes_set_popup(palette_callback.to_glib_none().0, palette.to_glib_none().0))
    }
}

#[doc(alias = "gimp_param_spec_array")]
pub fn param_spec_array(name: &str, nick: &str, blurb: &str, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_array(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_brush")]
pub fn param_spec_brush(name: &str, nick: &str, blurb: &str, none_ok: bool, default_value: Option<&Brush>, default_to_context: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_brush(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), default_value.to_glib_none().0, default_to_context.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_channel")]
pub fn param_spec_channel(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_channel(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_choice")]
pub fn param_spec_choice(name: &str, nick: &str, blurb: &str, choice: Choice, default_value: &str, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    skip_assert_initialized!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_choice(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, choice.into_glib_ptr(), default_value.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_color")]
pub fn param_spec_color(name: &str, nick: &str, blurb: &str, has_alpha: bool, default_color: &impl IsA<gegl::Color>, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_param_spec_color(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, has_alpha.into_glib(), default_color.as_ref().to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_config_path")]
pub fn param_spec_config_path(name: &str, nick: &str, blurb: &str, type_: ConfigPathType, default_value: &str, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_param_spec_config_path(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, type_.into_glib(), default_value.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_config_path_type")]
pub fn param_spec_config_path_type(pspec: impl AsRef<glib::ParamSpec>) -> ConfigPathType {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_param_spec_config_path_type(pspec.as_ref().to_glib_none().0))
    }
}

#[doc(alias = "gimp_param_spec_core_object_array")]
pub fn param_spec_core_object_array(name: &str, nick: &str, blurb: &str, object_type: glib::types::Type, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_core_object_array(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, object_type.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_display")]
pub fn param_spec_display(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_display(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_double_array")]
pub fn param_spec_double_array(name: &str, nick: &str, blurb: &str, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_double_array(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_drawable")]
pub fn param_spec_drawable(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_drawable(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_drawable_filter")]
pub fn param_spec_drawable_filter(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_drawable_filter(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_export_options")]
pub fn param_spec_export_options(name: &str, nick: &str, blurb: &str, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_export_options(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_font")]
pub fn param_spec_font(name: &str, nick: &str, blurb: &str, none_ok: bool, default_value: Option<&Font>, default_to_context: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_font(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), default_value.to_glib_none().0, default_to_context.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_gradient")]
pub fn param_spec_gradient(name: &str, nick: &str, blurb: &str, none_ok: bool, default_value: Option<&Gradient>, default_to_context: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_gradient(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), default_value.to_glib_none().0, default_to_context.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_group_layer")]
pub fn param_spec_group_layer(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_group_layer(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_image")]
pub fn param_spec_image(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_image(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_int32_array")]
pub fn param_spec_int32_array(name: &str, nick: &str, blurb: &str, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_int32_array(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_item")]
pub fn param_spec_item(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_item(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_layer")]
pub fn param_spec_layer(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_layer(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_layer_mask")]
pub fn param_spec_layer_mask(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_layer_mask(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_matrix2")]
pub fn param_spec_matrix2(name: &str, nick: &str, blurb: &str, default_value: &Matrix2, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_param_spec_matrix2(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, default_value.to_glib_none().0, flags.into_glib()))
    }
}

//#[doc(alias = "gimp_param_spec_matrix3")]
//pub fn param_spec_matrix3(name: &str, nick: &str, blurb: &str, default_value: /*Ignored*/&Matrix3, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
//    unsafe { TODO: call ffi:gimp_param_spec_matrix3() }
//}

#[doc(alias = "gimp_param_spec_memsize")]
pub fn param_spec_memsize(name: &str, nick: &str, blurb: &str, minimum: u64, maximum: u64, default_value: u64, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_param_spec_memsize(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, minimum, maximum, default_value, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_palette")]
pub fn param_spec_palette(name: &str, nick: &str, blurb: &str, none_ok: bool, default_value: Option<&Palette>, default_to_context: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_palette(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), default_value.to_glib_none().0, default_to_context.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_parasite")]
pub fn param_spec_parasite(name: &str, nick: &str, blurb: &str, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_param_spec_parasite(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_path")]
pub fn param_spec_path(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_path(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_pattern")]
pub fn param_spec_pattern(name: &str, nick: &str, blurb: &str, none_ok: bool, default_value: Option<&Pattern>, default_to_context: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_pattern(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), default_value.to_glib_none().0, default_to_context.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_resource")]
pub fn param_spec_resource(name: &str, nick: &str, blurb: &str, resource_type: glib::types::Type, none_ok: bool, default_value: Option<&impl IsA<Resource>>, default_to_context: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_resource(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, resource_type.into_glib(), none_ok.into_glib(), default_value.map(|p| p.as_ref()).to_glib_none().0, default_to_context.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_selection")]
pub fn param_spec_selection(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_selection(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_text_layer")]
pub fn param_spec_text_layer(name: &str, nick: &str, blurb: &str, none_ok: bool, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_param_spec_text_layer(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, none_ok.into_glib(), flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_unit")]
pub fn param_spec_unit(name: &str, nick: &str, blurb: &str, allow_pixel: bool, allow_percent: bool, default_value: &Unit, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    skip_assert_initialized!();
    unsafe {
        from_glib_full(ffi::gimp_param_spec_unit(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, allow_pixel.into_glib(), allow_percent.into_glib(), default_value.to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_param_spec_value_array")]
pub fn param_spec_value_array(name: &str, nick: &str, blurb: &str, element_spec: Option<impl AsRef<glib::ParamSpec>>, flags: glib::ParamFlags) -> Option<glib::ParamSpec> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_param_spec_value_array(name.to_glib_none().0, nick.to_glib_none().0, blurb.to_glib_none().0, element_spec.as_ref().map(|p| p.as_ref()).to_glib_none().0, flags.into_glib()))
    }
}

#[doc(alias = "gimp_patterns_close_popup")]
pub fn patterns_close_popup(pattern_callback: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_patterns_close_popup(pattern_callback.to_glib_none().0))
    }
}

#[doc(alias = "gimp_patterns_get_list")]
pub fn patterns_get_list(filter: &str) -> Vec<Pattern> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_container(ffi::gimp_patterns_get_list(filter.to_glib_none().0))
    }
}

#[doc(alias = "gimp_patterns_popup")]
pub fn patterns_popup(pattern_callback: &str, popup_title: &str, initial_pattern: &Pattern, parent_window: &glib::Bytes) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_patterns_popup(pattern_callback.to_glib_none().0, popup_title.to_glib_none().0, initial_pattern.to_glib_none().0, parent_window.to_glib_none().0))
    }
}

#[doc(alias = "gimp_patterns_refresh")]
pub fn patterns_refresh() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_patterns_refresh())
    }
}

#[doc(alias = "gimp_patterns_set_popup")]
pub fn patterns_set_popup(pattern_callback: &str, pattern: &Pattern) -> bool {
    skip_assert_initialized!();
    unsafe {
        from_glib(ffi::gimp_patterns_set_popup(pattern_callback.to_glib_none().0, pattern.to_glib_none().0))
    }
}

#[doc(alias = "gimp_pencil")]
pub fn pencil(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_pencil(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_pixbuf_create_buffer")]
pub fn pixbuf_create_buffer(pixbuf: &gdk_pixbuf::Pixbuf) -> Option<gegl::Buffer> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_pixbuf_create_buffer(pixbuf.to_glib_none().0))
    }
}

#[doc(alias = "gimp_pixbuf_get_icc_profile")]
pub fn pixbuf_get_icc_profile(pixbuf: &gdk_pixbuf::Pixbuf) -> Vec<u8> {
    assert_initialized_main_thread!();
    unsafe {
        let mut length = std::mem::MaybeUninit::uninit();
        let ret = FromGlibContainer::from_glib_none_num(ffi::gimp_pixbuf_get_icc_profile(pixbuf.to_glib_none().0, length.as_mut_ptr()), length.assume_init() as _);
        ret
    }
}

#[doc(alias = "gimp_pixels_to_units")]
pub fn pixels_to_units(pixels: f64, unit: &Unit, resolution: f64) -> f64 {
    skip_assert_initialized!();
    unsafe {
        ffi::gimp_pixels_to_units(pixels, unit.to_glib_none().0, resolution)
    }
}

//#[doc(alias = "gimp_pixpipe_params_build")]
//pub fn pixpipe_params_build(params: /*Ignored*/&mut PixPipeParams) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_pixpipe_params_build() }
//}

//#[doc(alias = "gimp_pixpipe_params_free")]
//pub fn pixpipe_params_free(params: /*Ignored*/&mut PixPipeParams) {
//    unsafe { TODO: call ffi:gimp_pixpipe_params_free() }
//}

//#[doc(alias = "gimp_pixpipe_params_init")]
//pub fn pixpipe_params_init(params: /*Ignored*/&mut PixPipeParams) {
//    unsafe { TODO: call ffi:gimp_pixpipe_params_init() }
//}

//#[doc(alias = "gimp_pixpipe_params_parse")]
//pub fn pixpipe_params_parse(parameters: &str, params: /*Ignored*/&mut PixPipeParams) {
//    unsafe { TODO: call ffi:gimp_pixpipe_params_parse() }
//}

#[doc(alias = "gimp_progress_cancel")]
pub fn progress_cancel(progress_callback: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_progress_cancel(progress_callback.to_glib_none().0))
    }
}

#[doc(alias = "gimp_progress_end")]
pub fn progress_end() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_progress_end())
    }
}

#[doc(alias = "gimp_progress_get_window_handle")]
pub fn progress_get_window_handle() -> Option<glib::Bytes> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_progress_get_window_handle())
    }
}

#[doc(alias = "gimp_progress_init")]
pub fn progress_init(message: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_progress_init(message.to_glib_none().0))
    }
}

//#[doc(alias = "gimp_progress_init_printf")]
//pub fn progress_init_printf(format: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> bool {
//    unsafe { TODO: call ffi:gimp_progress_init_printf() }
//}

//#[doc(alias = "gimp_progress_install_vtable")]
//pub fn progress_install_vtable(vtable: /*Ignored*/&ProgressVtable, user_data: /*Unimplemented*/Option<Basic: Pointer>) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_progress_install_vtable() }
//}

#[doc(alias = "gimp_progress_pulse")]
pub fn progress_pulse() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_progress_pulse())
    }
}

#[doc(alias = "gimp_progress_set_text")]
pub fn progress_set_text(message: &str) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_progress_set_text(message.to_glib_none().0))
    }
}

//#[doc(alias = "gimp_progress_set_text_printf")]
//pub fn progress_set_text_printf(format: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> bool {
//    unsafe { TODO: call ffi:gimp_progress_set_text_printf() }
//}

#[doc(alias = "gimp_progress_uninstall")]
pub fn progress_uninstall(progress_callback: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_progress_uninstall(progress_callback.to_glib_none().0);
    }
}

#[doc(alias = "gimp_progress_update")]
pub fn progress_update(percentage: f64) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_progress_update(percentage))
    }
}

#[doc(alias = "gimp_quit")]
pub fn quit() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_quit();
    }
}

#[doc(alias = "gimp_range_estimate_settings")]
pub fn range_estimate_settings(lower: f64, upper: f64) -> (f64, f64, i32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut step = std::mem::MaybeUninit::uninit();
        let mut page = std::mem::MaybeUninit::uninit();
        let mut digits = std::mem::MaybeUninit::uninit();
        ffi::gimp_range_estimate_settings(lower, upper, step.as_mut_ptr(), page.as_mut_ptr(), digits.as_mut_ptr());
        (step.assume_init(), page.assume_init(), digits.assume_init())
    }
}

#[doc(alias = "gimp_rectangle_intersect")]
pub fn rectangle_intersect(x1: i32, y1: i32, width1: i32, height1: i32, x2: i32, y2: i32, width2: i32, height2: i32) -> Option<(i32, i32, i32, i32)> {
    assert_initialized_main_thread!();
    unsafe {
        let mut dest_x = std::mem::MaybeUninit::uninit();
        let mut dest_y = std::mem::MaybeUninit::uninit();
        let mut dest_width = std::mem::MaybeUninit::uninit();
        let mut dest_height = std::mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::gimp_rectangle_intersect(x1, y1, width1, height1, x2, y2, width2, height2, dest_x.as_mut_ptr(), dest_y.as_mut_ptr(), dest_width.as_mut_ptr(), dest_height.as_mut_ptr()));
        if ret { Some((dest_x.assume_init(), dest_y.assume_init(), dest_width.assume_init(), dest_height.assume_init())) } else { None }
    }
}

#[doc(alias = "gimp_rectangle_union")]
pub fn rectangle_union(x1: i32, y1: i32, width1: i32, height1: i32, x2: i32, y2: i32, width2: i32, height2: i32) -> (i32, i32, i32, i32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut dest_x = std::mem::MaybeUninit::uninit();
        let mut dest_y = std::mem::MaybeUninit::uninit();
        let mut dest_width = std::mem::MaybeUninit::uninit();
        let mut dest_height = std::mem::MaybeUninit::uninit();
        ffi::gimp_rectangle_union(x1, y1, width1, height1, x2, y2, width2, height2, dest_x.as_mut_ptr(), dest_y.as_mut_ptr(), dest_width.as_mut_ptr(), dest_height.as_mut_ptr());
        (dest_x.assume_init(), dest_y.assume_init(), dest_width.assume_init(), dest_height.assume_init())
    }
}

#[doc(alias = "gimp_show_help_button")]
pub fn show_help_button() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_show_help_button())
    }
}

#[doc(alias = "gimp_smudge")]
pub fn smudge(drawable: &impl IsA<Drawable>, pressure: f64, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_smudge(drawable.as_ref().to_glib_none().0, pressure, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_smudge_default")]
pub fn smudge_default(drawable: &impl IsA<Drawable>, strokes: &[f64]) -> bool {
    skip_assert_initialized!();
    let num_strokes = strokes.len() as _;
    unsafe {
        from_glib(ffi::gimp_smudge_default(drawable.as_ref().to_glib_none().0, num_strokes, strokes.to_glib_none().0))
    }
}

#[doc(alias = "gimp_stack_trace_available")]
pub fn stack_trace_available(optimal: bool) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gimp_stack_trace_available(optimal.into_glib()))
    }
}

//#[doc(alias = "gimp_stack_trace_print")]
//pub fn stack_trace_print(prog_name: &str, stream: /*Unimplemented*/Option<Basic: Pointer>) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:gimp_stack_trace_print() }
//}

#[doc(alias = "gimp_stack_trace_query")]
pub fn stack_trace_query(prog_name: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_stack_trace_query(prog_name.to_glib_none().0);
    }
}

#[doc(alias = "gimp_strip_uline")]
pub fn strip_uline(str: Option<&str>) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_strip_uline(str.to_glib_none().0))
    }
}

#[doc(alias = "gimp_sysconf_directory")]
pub fn sysconf_directory() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_sysconf_directory())
    }
}

//#[doc(alias = "gimp_sysconf_directory_file")]
//pub fn sysconf_directory_file(first_element: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<gio::File> {
//    unsafe { TODO: call ffi:gimp_sysconf_directory_file() }
//}

#[doc(alias = "gimp_temp_directory")]
pub fn temp_directory() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_temp_directory())
    }
}

#[doc(alias = "gimp_temp_file")]
pub fn temp_file(extension: &str) -> Option<gio::File> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_temp_file(extension.to_glib_none().0))
    }
}

#[doc(alias = "gimp_text_font")]
pub fn text_font(image: &Image, drawable: Option<&impl IsA<Drawable>>, x: f64, y: f64, text: &str, border: i32, antialias: bool, size: f64, font: &Font) -> Option<Layer> {
    skip_assert_initialized!();
    unsafe {
        from_glib_none(ffi::gimp_text_font(image.to_glib_none().0, drawable.map(|p| p.as_ref()).to_glib_none().0, x, y, text.to_glib_none().0, border, antialias.into_glib(), size, font.to_glib_none().0))
    }
}

#[doc(alias = "gimp_text_get_extents_font")]
pub fn text_get_extents_font(text: &str, size: f64, font: &Font) -> Option<(i32, i32, i32, i32)> {
    skip_assert_initialized!();
    unsafe {
        let mut width = std::mem::MaybeUninit::uninit();
        let mut height = std::mem::MaybeUninit::uninit();
        let mut ascent = std::mem::MaybeUninit::uninit();
        let mut descent = std::mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::gimp_text_get_extents_font(text.to_glib_none().0, size, font.to_glib_none().0, width.as_mut_ptr(), height.as_mut_ptr(), ascent.as_mut_ptr(), descent.as_mut_ptr()));
        if ret { Some((width.assume_init(), height.assume_init(), ascent.assume_init(), descent.assume_init())) } else { None }
    }
}

#[doc(alias = "gimp_tile_height")]
pub fn tile_height() -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_tile_height()
    }
}

#[doc(alias = "gimp_tile_width")]
pub fn tile_width() -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_tile_width()
    }
}

#[doc(alias = "gimp_type_get_translation_context")]
pub fn type_get_translation_context(type_: glib::types::Type) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_type_get_translation_context(type_.into_glib()))
    }
}

#[doc(alias = "gimp_type_get_translation_domain")]
pub fn type_get_translation_domain(type_: glib::types::Type) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_type_get_translation_domain(type_.into_glib()))
    }
}

#[doc(alias = "gimp_type_set_translation_context")]
pub fn type_set_translation_context(type_: glib::types::Type, context: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_type_set_translation_context(type_.into_glib(), context.to_glib_none().0);
    }
}

#[doc(alias = "gimp_type_set_translation_domain")]
pub fn type_set_translation_domain(type_: glib::types::Type, domain: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_type_set_translation_domain(type_.into_glib(), domain.to_glib_none().0);
    }
}

#[doc(alias = "gimp_units_to_pixels")]
pub fn units_to_pixels(value: f64, unit: &Unit, resolution: f64) -> f64 {
    skip_assert_initialized!();
    unsafe {
        ffi::gimp_units_to_pixels(value, unit.to_glib_none().0, resolution)
    }
}

#[doc(alias = "gimp_units_to_points")]
pub fn units_to_points(value: f64, unit: &Unit, resolution: f64) -> f64 {
    skip_assert_initialized!();
    unsafe {
        ffi::gimp_units_to_points(value, unit.to_glib_none().0, resolution)
    }
}

#[doc(alias = "gimp_user_time")]
pub fn user_time() -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gimp_user_time()
    }
}

#[doc(alias = "gimp_utf8_strtrim")]
pub fn utf8_strtrim(str: Option<&str>, max_chars: i32) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_utf8_strtrim(str.to_glib_none().0, max_chars))
    }
}

#[doc(alias = "gimp_value_dup_double_array")]
pub fn value_dup_double_array(value: &glib::Value) -> Vec<f64> {
    assert_initialized_main_thread!();
    unsafe {
        let mut length = std::mem::MaybeUninit::uninit();
        let ret = FromGlibContainer::from_glib_full_num(ffi::gimp_value_dup_double_array(value.to_glib_none().0, length.as_mut_ptr()), length.assume_init() as _);
        ret
    }
}

#[doc(alias = "gimp_value_dup_int32_array")]
pub fn value_dup_int32_array(value: &glib::Value) -> Vec<i32> {
    assert_initialized_main_thread!();
    unsafe {
        let mut length = std::mem::MaybeUninit::uninit();
        let ret = FromGlibContainer::from_glib_full_num(ffi::gimp_value_dup_int32_array(value.to_glib_none().0, length.as_mut_ptr()), length.assume_init() as _);
        ret
    }
}

#[doc(alias = "gimp_value_get_double_array")]
pub fn value_get_double_array(value: &glib::Value) -> Vec<f64> {
    assert_initialized_main_thread!();
    unsafe {
        let mut length = std::mem::MaybeUninit::uninit();
        let ret = FromGlibContainer::from_glib_none_num(ffi::gimp_value_get_double_array(value.to_glib_none().0, length.as_mut_ptr()), length.assume_init() as _);
        ret
    }
}

#[doc(alias = "gimp_value_get_int32_array")]
pub fn value_get_int32_array(value: &glib::Value) -> Vec<i32> {
    assert_initialized_main_thread!();
    unsafe {
        let mut length = std::mem::MaybeUninit::uninit();
        let ret = FromGlibContainer::from_glib_none_num(ffi::gimp_value_get_int32_array(value.to_glib_none().0, length.as_mut_ptr()), length.assume_init() as _);
        ret
    }
}

#[doc(alias = "gimp_value_set_double_array")]
pub fn value_set_double_array(value: &mut glib::Value, data: &[f64]) {
    assert_initialized_main_thread!();
    let length = data.len() as _;
    unsafe {
        ffi::gimp_value_set_double_array(value.to_glib_none_mut().0, data.to_glib_none().0, length);
    }
}

#[doc(alias = "gimp_value_set_int32_array")]
pub fn value_set_int32_array(value: &mut glib::Value, data: &[i32]) {
    assert_initialized_main_thread!();
    let length = data.len() as _;
    unsafe {
        ffi::gimp_value_set_int32_array(value.to_glib_none_mut().0, data.to_glib_none().0, length);
    }
}

#[doc(alias = "gimp_value_set_static_double_array")]
pub fn value_set_static_double_array(value: &mut glib::Value, data: &[f64]) {
    assert_initialized_main_thread!();
    let length = data.len() as _;
    unsafe {
        ffi::gimp_value_set_static_double_array(value.to_glib_none_mut().0, data.to_glib_none().0, length);
    }
}

#[doc(alias = "gimp_value_set_static_int32_array")]
pub fn value_set_static_int32_array(value: &mut glib::Value, data: &[i32]) {
    assert_initialized_main_thread!();
    let length = data.len() as _;
    unsafe {
        ffi::gimp_value_set_static_int32_array(value.to_glib_none_mut().0, data.to_glib_none().0, length);
    }
}

#[doc(alias = "gimp_value_take_double_array")]
pub fn value_take_double_array(value: &mut glib::Value, data: &[f64]) {
    assert_initialized_main_thread!();
    let length = data.len() as _;
    unsafe {
        ffi::gimp_value_take_double_array(value.to_glib_none_mut().0, data.to_glib_full(), length);
    }
}

#[doc(alias = "gimp_value_take_int32_array")]
pub fn value_take_int32_array(value: &mut glib::Value, data: &[i32]) {
    assert_initialized_main_thread!();
    let length = data.len() as _;
    unsafe {
        ffi::gimp_value_take_int32_array(value.to_glib_none_mut().0, data.to_glib_full(), length);
    }
}

//#[doc(alias = "gimp_vector_2d_to_3d")]
//pub fn vector_2d_to_3d(sx: i32, sy: i32, w: i32, h: i32, x: i32, y: i32, vp: /*Ignored*/&Vector3, p: /*Ignored*/&mut Vector3) {
//    unsafe { TODO: call ffi:gimp_vector_2d_to_3d() }
//}

//#[doc(alias = "gimp_vector_2d_to_3d_val")]
//pub fn vector_2d_to_3d_val(sx: i32, sy: i32, w: i32, h: i32, x: i32, y: i32, vp: /*Ignored*/&Vector3, p: /*Ignored*/&Vector3) -> /*Ignored*/Option<Vector3> {
//    unsafe { TODO: call ffi:gimp_vector_2d_to_3d_val() }
//}

//#[doc(alias = "gimp_vector_3d_to_2d")]
//pub fn vector_3d_to_2d(sx: i32, sy: i32, w: i32, h: i32, vp: /*Ignored*/&Vector3, p: /*Ignored*/&Vector3) -> (f64, f64) {
//    unsafe { TODO: call ffi:gimp_vector_3d_to_2d() }
//}

#[doc(alias = "gimp_version")]
pub fn version() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gimp_version())
    }
}

#[doc(alias = "gimp_wm_class")]
pub fn wm_class() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::gimp_wm_class())
    }
}
