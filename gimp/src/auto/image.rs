// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Channel,ChannelOps,ChannelType,ColorProfile,ColorRenderingIntent,ConvertDitherType,ConvertPaletteType,Drawable,GridStyle,ImageBaseType,Item,Layer,LayerMode,MergeType,Metadata,MetadataSaveFlags,OrientationType,Palette,Parasite,Path,PixbufTransparency,Precision,RotationType,Selection,Unit};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "GimpImage")]
    pub struct Image(Object<ffi::GimpImage, ffi::GimpImageClass>);

    match fn {
        type_ => || ffi::gimp_image_get_type(),
    }
}

impl Image {
    #[doc(alias = "gimp_image_new")]
    pub fn new(width: i32, height: i32, type_: ImageBaseType) -> Image {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_image_new(width, height, type_.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_new_with_precision")]
    #[doc(alias = "new_with_precision")]
    pub fn with_precision(width: i32, height: i32, type_: ImageBaseType, precision: Precision) -> Image {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_image_new_with_precision(width, height, type_.into_glib(), precision.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_add_hguide")]
    pub fn add_hguide(&self, yposition: i32) -> u32 {
        unsafe {
            ffi::gimp_image_add_hguide(self.to_glib_none().0, yposition)
        }
    }

    #[doc(alias = "gimp_image_add_sample_point")]
    pub fn add_sample_point(&self, position_x: i32, position_y: i32) -> u32 {
        unsafe {
            ffi::gimp_image_add_sample_point(self.to_glib_none().0, position_x, position_y)
        }
    }

    #[doc(alias = "gimp_image_add_vguide")]
    pub fn add_vguide(&self, xposition: i32) -> u32 {
        unsafe {
            ffi::gimp_image_add_vguide(self.to_glib_none().0, xposition)
        }
    }

    #[doc(alias = "gimp_image_attach_parasite")]
    pub fn attach_parasite(&self, parasite: &Parasite) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_attach_parasite(self.to_glib_none().0, parasite.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_clean_all")]
    pub fn clean_all(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_clean_all(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_convert_color_profile")]
    pub fn convert_color_profile(&self, profile: &ColorProfile, intent: ColorRenderingIntent, bpc: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_convert_color_profile(self.to_glib_none().0, profile.to_glib_none().0, intent.into_glib(), bpc.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_convert_color_profile_from_file")]
    pub fn convert_color_profile_from_file(&self, file: &impl IsA<gio::File>, intent: ColorRenderingIntent, bpc: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_convert_color_profile_from_file(self.to_glib_none().0, file.as_ref().to_glib_none().0, intent.into_glib(), bpc.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_convert_grayscale")]
    pub fn convert_grayscale(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_convert_grayscale(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_convert_indexed")]
    pub fn convert_indexed(&self, dither_type: ConvertDitherType, palette_type: ConvertPaletteType, num_cols: i32, alpha_dither: bool, remove_unused: bool, palette: &str) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_convert_indexed(self.to_glib_none().0, dither_type.into_glib(), palette_type.into_glib(), num_cols, alpha_dither.into_glib(), remove_unused.into_glib(), palette.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_convert_precision")]
    pub fn convert_precision(&self, precision: Precision) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_convert_precision(self.to_glib_none().0, precision.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_convert_rgb")]
    pub fn convert_rgb(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_convert_rgb(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_crop")]
    pub fn crop(&self, new_width: i32, new_height: i32, offx: i32, offy: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_crop(self.to_glib_none().0, new_width, new_height, offx, offy))
        }
    }

    #[doc(alias = "gimp_image_delete")]
    pub fn delete(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_delete(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_delete_guide")]
    pub fn delete_guide(&self, guide: u32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_delete_guide(self.to_glib_none().0, guide))
        }
    }

    #[doc(alias = "gimp_image_delete_sample_point")]
    pub fn delete_sample_point(&self, sample_point: u32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_delete_sample_point(self.to_glib_none().0, sample_point))
        }
    }

    #[doc(alias = "gimp_image_detach_parasite")]
    pub fn detach_parasite(&self, name: &str) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_detach_parasite(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_duplicate")]
#[must_use]
    pub fn duplicate(&self) -> Option<Image> {
        unsafe {
            from_glib_none(ffi::gimp_image_duplicate(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_export_path_to_file")]
    pub fn export_path_to_file(&self, file: &impl IsA<gio::File>, path: Option<&Path>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_export_path_to_file(self.to_glib_none().0, file.as_ref().to_glib_none().0, path.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_export_path_to_string")]
    pub fn export_path_to_string(&self, path: Option<&Path>) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gimp_image_export_path_to_string(self.to_glib_none().0, path.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_find_next_guide")]
    pub fn find_next_guide(&self, guide: i32) -> u32 {
        unsafe {
            ffi::gimp_image_find_next_guide(self.to_glib_none().0, guide)
        }
    }

    #[doc(alias = "gimp_image_find_next_sample_point")]
    pub fn find_next_sample_point(&self, sample_point: u32) -> u32 {
        unsafe {
            ffi::gimp_image_find_next_sample_point(self.to_glib_none().0, sample_point)
        }
    }

    #[doc(alias = "gimp_image_flatten")]
    pub fn flatten(&self) -> Option<Layer> {
        unsafe {
            from_glib_none(ffi::gimp_image_flatten(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_flip")]
    pub fn flip(&self, flip_type: OrientationType) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_flip(self.to_glib_none().0, flip_type.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_floating_sel_attached_to")]
    pub fn floating_sel_attached_to(&self) -> Option<Drawable> {
        unsafe {
            from_glib_none(ffi::gimp_image_floating_sel_attached_to(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_freeze_channels")]
    pub fn freeze_channels(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_freeze_channels(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_freeze_layers")]
    pub fn freeze_layers(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_freeze_layers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_freeze_paths")]
    pub fn freeze_paths(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_freeze_paths(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_base_type")]
    #[doc(alias = "get_base_type")]
    pub fn base_type(&self) -> ImageBaseType {
        unsafe {
            from_glib(ffi::gimp_image_get_base_type(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_channel_by_name")]
    #[doc(alias = "get_channel_by_name")]
    pub fn channel_by_name(&self, name: &str) -> Option<Channel> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_channel_by_name(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_channel_by_tattoo")]
    #[doc(alias = "get_channel_by_tattoo")]
    pub fn channel_by_tattoo(&self, tattoo: u32) -> Option<Channel> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_channel_by_tattoo(self.to_glib_none().0, tattoo))
        }
    }

    #[doc(alias = "gimp_image_get_channels")]
    #[doc(alias = "get_channels")]
    pub fn channels(&self) -> Vec<Channel> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_get_channels(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_color_profile")]
    #[doc(alias = "get_color_profile")]
    pub fn color_profile(&self) -> Option<ColorProfile> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_color_profile(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_component_active")]
    #[doc(alias = "get_component_active")]
    pub fn is_component_active(&self, component: ChannelType) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_get_component_active(self.to_glib_none().0, component.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_get_component_visible")]
    #[doc(alias = "get_component_visible")]
    pub fn is_component_visible(&self, component: ChannelType) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_get_component_visible(self.to_glib_none().0, component.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_get_default_new_layer_mode")]
    #[doc(alias = "get_default_new_layer_mode")]
    pub fn default_new_layer_mode(&self) -> LayerMode {
        unsafe {
            from_glib(ffi::gimp_image_get_default_new_layer_mode(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_effective_color_profile")]
    #[doc(alias = "get_effective_color_profile")]
    pub fn effective_color_profile(&self) -> Option<ColorProfile> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_effective_color_profile(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_exported_file")]
    #[doc(alias = "get_exported_file")]
    pub fn exported_file(&self) -> Option<gio::File> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_exported_file(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_file")]
    #[doc(alias = "get_file")]
    pub fn file(&self) -> Option<gio::File> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_file(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_floating_sel")]
    #[doc(alias = "get_floating_sel")]
    pub fn floating_sel(&self) -> Option<Layer> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_floating_sel(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_guide_orientation")]
    #[doc(alias = "get_guide_orientation")]
    pub fn guide_orientation(&self, guide: u32) -> OrientationType {
        unsafe {
            from_glib(ffi::gimp_image_get_guide_orientation(self.to_glib_none().0, guide))
        }
    }

    #[doc(alias = "gimp_image_get_guide_position")]
    #[doc(alias = "get_guide_position")]
    pub fn guide_position(&self, guide: u32) -> i32 {
        unsafe {
            ffi::gimp_image_get_guide_position(self.to_glib_none().0, guide)
        }
    }

    #[doc(alias = "gimp_image_get_height")]
    #[doc(alias = "get_height")]
    pub fn height(&self) -> i32 {
        unsafe {
            ffi::gimp_image_get_height(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_image_get_id")]
    #[doc(alias = "get_id")]
    pub fn id(&self) -> i32 {
        unsafe {
            ffi::gimp_image_get_id(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_image_get_imported_file")]
    #[doc(alias = "get_imported_file")]
    pub fn imported_file(&self) -> Option<gio::File> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_imported_file(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_item_position")]
    #[doc(alias = "get_item_position")]
    pub fn item_position(&self, item: &impl IsA<Item>) -> i32 {
        unsafe {
            ffi::gimp_image_get_item_position(self.to_glib_none().0, item.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_image_get_layer_by_name")]
    #[doc(alias = "get_layer_by_name")]
    pub fn layer_by_name(&self, name: &str) -> Option<Layer> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_layer_by_name(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_layer_by_tattoo")]
    #[doc(alias = "get_layer_by_tattoo")]
    pub fn layer_by_tattoo(&self, tattoo: u32) -> Option<Layer> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_layer_by_tattoo(self.to_glib_none().0, tattoo))
        }
    }

    #[doc(alias = "gimp_image_get_layers")]
    #[doc(alias = "get_layers")]
    pub fn layers(&self) -> Vec<Layer> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_get_layers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_metadata")]
    #[doc(alias = "get_metadata")]
    pub fn metadata(&self) -> Option<Metadata> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_metadata(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_name")]
    #[doc(alias = "get_name")]
    pub fn name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_palette")]
    #[doc(alias = "get_palette")]
    pub fn palette(&self) -> Option<Palette> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_palette(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_parasite")]
    #[doc(alias = "get_parasite")]
    pub fn parasite(&self, name: &str) -> Option<Parasite> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_parasite(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_parasite_list")]
    #[doc(alias = "get_parasite_list")]
    pub fn parasite_list(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::gimp_image_get_parasite_list(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_path_by_name")]
    #[doc(alias = "get_path_by_name")]
    pub fn path_by_name(&self, name: &str) -> Option<Path> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_path_by_name(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_path_by_tattoo")]
    #[doc(alias = "get_path_by_tattoo")]
    pub fn path_by_tattoo(&self, tattoo: u32) -> Option<Path> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_path_by_tattoo(self.to_glib_none().0, tattoo))
        }
    }

    #[doc(alias = "gimp_image_get_paths")]
    #[doc(alias = "get_paths")]
    pub fn paths(&self) -> Vec<Path> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_get_paths(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_precision")]
    #[doc(alias = "get_precision")]
    pub fn precision(&self) -> Precision {
        unsafe {
            from_glib(ffi::gimp_image_get_precision(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_resolution")]
    #[doc(alias = "get_resolution")]
    pub fn resolution(&self) -> Option<(f64, f64)> {
        unsafe {
            let mut xresolution = std::mem::MaybeUninit::uninit();
            let mut yresolution = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_image_get_resolution(self.to_glib_none().0, xresolution.as_mut_ptr(), yresolution.as_mut_ptr()));
            if ret { Some((xresolution.assume_init(), yresolution.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_image_get_sample_point_position")]
    #[doc(alias = "get_sample_point_position")]
    pub fn sample_point_position(&self, sample_point: u32) -> (i32, i32) {
        unsafe {
            let mut position_y = std::mem::MaybeUninit::uninit();
            let ret = ffi::gimp_image_get_sample_point_position(self.to_glib_none().0, sample_point, position_y.as_mut_ptr());
            (ret, position_y.assume_init())
        }
    }

    #[doc(alias = "gimp_image_get_selected_channels")]
    #[doc(alias = "get_selected_channels")]
    pub fn selected_channels(&self) -> Vec<Channel> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_get_selected_channels(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_selected_drawables")]
    #[doc(alias = "get_selected_drawables")]
    pub fn selected_drawables(&self) -> Vec<Drawable> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_get_selected_drawables(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_selected_layers")]
    #[doc(alias = "get_selected_layers")]
    pub fn selected_layers(&self) -> Vec<Layer> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_get_selected_layers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_selected_paths")]
    #[doc(alias = "get_selected_paths")]
    pub fn selected_paths(&self) -> Vec<Path> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_get_selected_paths(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_selection")]
    #[doc(alias = "get_selection")]
    pub fn selection(&self) -> Option<Selection> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_selection(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_simulation_bpc")]
    #[doc(alias = "get_simulation_bpc")]
    pub fn is_simulation_bpc(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_get_simulation_bpc(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_simulation_intent")]
    #[doc(alias = "get_simulation_intent")]
    pub fn simulation_intent(&self) -> ColorRenderingIntent {
        unsafe {
            from_glib(ffi::gimp_image_get_simulation_intent(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_simulation_profile")]
    #[doc(alias = "get_simulation_profile")]
    pub fn simulation_profile(&self) -> Option<ColorProfile> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_simulation_profile(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_tattoo_state")]
    #[doc(alias = "get_tattoo_state")]
    pub fn tattoo_state(&self) -> u32 {
        unsafe {
            ffi::gimp_image_get_tattoo_state(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_image_get_thumbnail")]
    #[doc(alias = "get_thumbnail")]
    pub fn thumbnail(&self, width: i32, height: i32, alpha: PixbufTransparency) -> Option<gdk_pixbuf::Pixbuf> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_thumbnail(self.to_glib_none().0, width, height, alpha.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_get_thumbnail_data")]
    #[doc(alias = "get_thumbnail_data")]
    pub fn thumbnail_data(&self, width: &mut i32, height: &mut i32) -> (glib::Bytes, i32) {
        unsafe {
            let mut bpp = std::mem::MaybeUninit::uninit();
            let ret = from_glib_full(ffi::gimp_image_get_thumbnail_data(self.to_glib_none().0, width, height, bpp.as_mut_ptr()));
            (ret, bpp.assume_init())
        }
    }

    #[doc(alias = "gimp_image_get_unit")]
    #[doc(alias = "get_unit")]
    pub fn unit(&self) -> Option<Unit> {
        unsafe {
            from_glib_none(ffi::gimp_image_get_unit(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_width")]
    #[doc(alias = "get_width")]
    pub fn width(&self) -> i32 {
        unsafe {
            ffi::gimp_image_get_width(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_image_get_xcf_file")]
    #[doc(alias = "get_xcf_file")]
    pub fn xcf_file(&self) -> Option<gio::File> {
        unsafe {
            from_glib_full(ffi::gimp_image_get_xcf_file(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_grid_get_background_color")]
    pub fn grid_get_background_color(&self) -> Option<gegl::Color> {
        unsafe {
            from_glib_full(ffi::gimp_image_grid_get_background_color(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_grid_get_foreground_color")]
    pub fn grid_get_foreground_color(&self) -> Option<gegl::Color> {
        unsafe {
            from_glib_full(ffi::gimp_image_grid_get_foreground_color(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_grid_get_offset")]
    pub fn grid_get_offset(&self) -> Option<(f64, f64)> {
        unsafe {
            let mut xoffset = std::mem::MaybeUninit::uninit();
            let mut yoffset = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_image_grid_get_offset(self.to_glib_none().0, xoffset.as_mut_ptr(), yoffset.as_mut_ptr()));
            if ret { Some((xoffset.assume_init(), yoffset.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_image_grid_get_spacing")]
    pub fn grid_get_spacing(&self) -> Option<(f64, f64)> {
        unsafe {
            let mut xspacing = std::mem::MaybeUninit::uninit();
            let mut yspacing = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_image_grid_get_spacing(self.to_glib_none().0, xspacing.as_mut_ptr(), yspacing.as_mut_ptr()));
            if ret { Some((xspacing.assume_init(), yspacing.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gimp_image_grid_get_style")]
    pub fn grid_get_style(&self) -> GridStyle {
        unsafe {
            from_glib(ffi::gimp_image_grid_get_style(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_grid_set_background_color")]
    pub fn grid_set_background_color(&self, bgcolor: &impl IsA<gegl::Color>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_grid_set_background_color(self.to_glib_none().0, bgcolor.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_grid_set_foreground_color")]
    pub fn grid_set_foreground_color(&self, fgcolor: &impl IsA<gegl::Color>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_grid_set_foreground_color(self.to_glib_none().0, fgcolor.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_grid_set_offset")]
    pub fn grid_set_offset(&self, xoffset: f64, yoffset: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_grid_set_offset(self.to_glib_none().0, xoffset, yoffset))
        }
    }

    #[doc(alias = "gimp_image_grid_set_spacing")]
    pub fn grid_set_spacing(&self, xspacing: f64, yspacing: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_grid_set_spacing(self.to_glib_none().0, xspacing, yspacing))
        }
    }

    #[doc(alias = "gimp_image_grid_set_style")]
    pub fn grid_set_style(&self, style: GridStyle) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_grid_set_style(self.to_glib_none().0, style.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_import_paths_from_file")]
    pub fn import_paths_from_file(&self, file: &impl IsA<gio::File>, merge: bool, scale: bool) -> Option<Vec<Path>> {
        unsafe {
            let mut paths = std::ptr::null_mut();
            let ret = from_glib(ffi::gimp_image_import_paths_from_file(self.to_glib_none().0, file.as_ref().to_glib_none().0, merge.into_glib(), scale.into_glib(), &mut paths));
            if ret { Some(FromGlibPtrContainer::from_glib_container(paths)) } else { None }
        }
    }

    #[doc(alias = "gimp_image_import_paths_from_string")]
    pub fn import_paths_from_string(&self, string: &str, merge: bool, scale: bool) -> Option<Vec<Path>> {
        let length = string.len() as _;
        unsafe {
            let mut paths = std::ptr::null_mut();
            let ret = from_glib(ffi::gimp_image_import_paths_from_string(self.to_glib_none().0, string.to_glib_none().0, length, merge.into_glib(), scale.into_glib(), &mut paths));
            if ret { Some(FromGlibPtrContainer::from_glib_container(paths)) } else { None }
        }
    }

    #[doc(alias = "gimp_image_insert_channel")]
    pub fn insert_channel(&self, channel: &impl IsA<Channel>, parent: Option<&impl IsA<Channel>>, position: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_insert_channel(self.to_glib_none().0, channel.as_ref().to_glib_none().0, parent.map(|p| p.as_ref()).to_glib_none().0, position))
        }
    }

    #[doc(alias = "gimp_image_insert_layer")]
    pub fn insert_layer(&self, layer: &impl IsA<Layer>, parent: Option<&impl IsA<Layer>>, position: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_insert_layer(self.to_glib_none().0, layer.as_ref().to_glib_none().0, parent.map(|p| p.as_ref()).to_glib_none().0, position))
        }
    }

    #[doc(alias = "gimp_image_insert_path")]
    pub fn insert_path(&self, path: &Path, parent: Option<&Path>, position: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_insert_path(self.to_glib_none().0, path.to_glib_none().0, parent.to_glib_none().0, position))
        }
    }

    #[doc(alias = "gimp_image_is_dirty")]
    pub fn is_dirty(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_is_dirty(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_is_valid")]
    pub fn is_valid(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_is_valid(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_list_channels")]
    pub fn list_channels(&self) -> Vec<Channel> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_list_channels(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_list_layers")]
    pub fn list_layers(&self) -> Vec<Layer> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_list_layers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_list_paths")]
    pub fn list_paths(&self) -> Vec<Path> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_list_paths(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_list_selected_channels")]
    pub fn list_selected_channels(&self) -> Vec<Channel> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_list_selected_channels(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_list_selected_drawables")]
    pub fn list_selected_drawables(&self) -> Vec<Item> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_list_selected_drawables(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_list_selected_layers")]
    pub fn list_selected_layers(&self) -> Vec<Layer> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_list_selected_layers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_list_selected_paths")]
    pub fn list_selected_paths(&self) -> Vec<Path> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::gimp_image_list_selected_paths(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_lower_item")]
    pub fn lower_item(&self, item: &impl IsA<Item>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_lower_item(self.to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_lower_item_to_bottom")]
    pub fn lower_item_to_bottom(&self, item: &impl IsA<Item>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_lower_item_to_bottom(self.to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_merge_down")]
    pub fn merge_down(&self, merge_layer: &impl IsA<Layer>, merge_type: MergeType) -> Option<Layer> {
        unsafe {
            from_glib_none(ffi::gimp_image_merge_down(self.to_glib_none().0, merge_layer.as_ref().to_glib_none().0, merge_type.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_merge_visible_layers")]
    pub fn merge_visible_layers(&self, merge_type: MergeType) -> Option<Layer> {
        unsafe {
            from_glib_none(ffi::gimp_image_merge_visible_layers(self.to_glib_none().0, merge_type.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_metadata_save_filter")]
    pub fn metadata_save_filter(&self, mime_type: &str, metadata: &Metadata, flags: MetadataSaveFlags, file: &impl IsA<gio::File>) -> Result<Metadata, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::gimp_image_metadata_save_filter(self.to_glib_none().0, mime_type.to_glib_none().0, metadata.to_glib_none().0, flags.into_glib(), file.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "gimp_image_pick_correlate_layer")]
    pub fn pick_correlate_layer(&self, x: i32, y: i32) -> Option<Layer> {
        unsafe {
            from_glib_none(ffi::gimp_image_pick_correlate_layer(self.to_glib_none().0, x, y))
        }
    }

    #[doc(alias = "gimp_image_policy_color_profile")]
    pub fn policy_color_profile(&self, interactive: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_policy_color_profile(self.to_glib_none().0, interactive.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_policy_rotate")]
    pub fn policy_rotate(&self, interactive: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_policy_rotate(self.to_glib_none().0, interactive.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_raise_item")]
    pub fn raise_item(&self, item: &impl IsA<Item>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_raise_item(self.to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_raise_item_to_top")]
    pub fn raise_item_to_top(&self, item: &impl IsA<Item>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_raise_item_to_top(self.to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_remove_channel")]
    pub fn remove_channel(&self, channel: &impl IsA<Channel>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_remove_channel(self.to_glib_none().0, channel.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_remove_layer")]
    pub fn remove_layer(&self, layer: &impl IsA<Layer>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_remove_layer(self.to_glib_none().0, layer.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_remove_path")]
    pub fn remove_path(&self, path: &Path) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_remove_path(self.to_glib_none().0, path.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_reorder_item")]
    pub fn reorder_item(&self, item: &impl IsA<Item>, parent: Option<&impl IsA<Item>>, position: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_reorder_item(self.to_glib_none().0, item.as_ref().to_glib_none().0, parent.map(|p| p.as_ref()).to_glib_none().0, position))
        }
    }

    #[doc(alias = "gimp_image_resize")]
    pub fn resize(&self, new_width: i32, new_height: i32, offx: i32, offy: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_resize(self.to_glib_none().0, new_width, new_height, offx, offy))
        }
    }

    #[doc(alias = "gimp_image_resize_to_layers")]
    pub fn resize_to_layers(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_resize_to_layers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_rotate")]
    pub fn rotate(&self, rotate_type: RotationType) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_rotate(self.to_glib_none().0, rotate_type.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_scale")]
    pub fn scale(&self, new_width: i32, new_height: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_scale(self.to_glib_none().0, new_width, new_height))
        }
    }

    #[doc(alias = "gimp_image_select_color")]
    pub fn select_color(&self, operation: ChannelOps, drawable: &impl IsA<Drawable>, color: &impl IsA<gegl::Color>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_select_color(self.to_glib_none().0, operation.into_glib(), drawable.as_ref().to_glib_none().0, color.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_select_contiguous_color")]
    pub fn select_contiguous_color(&self, operation: ChannelOps, drawable: &impl IsA<Drawable>, x: f64, y: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_select_contiguous_color(self.to_glib_none().0, operation.into_glib(), drawable.as_ref().to_glib_none().0, x, y))
        }
    }

    #[doc(alias = "gimp_image_select_ellipse")]
    pub fn select_ellipse(&self, operation: ChannelOps, x: f64, y: f64, width: f64, height: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_select_ellipse(self.to_glib_none().0, operation.into_glib(), x, y, width, height))
        }
    }

    #[doc(alias = "gimp_image_select_item")]
    pub fn select_item(&self, operation: ChannelOps, item: &impl IsA<Item>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_select_item(self.to_glib_none().0, operation.into_glib(), item.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_select_polygon")]
    pub fn select_polygon(&self, operation: ChannelOps, segs: &[f64]) -> bool {
        let num_segs = segs.len() as _;
        unsafe {
            from_glib(ffi::gimp_image_select_polygon(self.to_glib_none().0, operation.into_glib(), num_segs, segs.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_select_rectangle")]
    pub fn select_rectangle(&self, operation: ChannelOps, x: f64, y: f64, width: f64, height: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_select_rectangle(self.to_glib_none().0, operation.into_glib(), x, y, width, height))
        }
    }

    #[doc(alias = "gimp_image_select_round_rectangle")]
    pub fn select_round_rectangle(&self, operation: ChannelOps, x: f64, y: f64, width: f64, height: f64, corner_radius_x: f64, corner_radius_y: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_select_round_rectangle(self.to_glib_none().0, operation.into_glib(), x, y, width, height, corner_radius_x, corner_radius_y))
        }
    }

    #[doc(alias = "gimp_image_set_color_profile")]
    pub fn set_color_profile(&self, profile: Option<&ColorProfile>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_color_profile(self.to_glib_none().0, profile.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_set_color_profile_from_file")]
    pub fn set_color_profile_from_file(&self, file: &impl IsA<gio::File>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_color_profile_from_file(self.to_glib_none().0, file.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_set_component_active")]
    pub fn set_component_active(&self, component: ChannelType, active: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_component_active(self.to_glib_none().0, component.into_glib(), active.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_set_component_visible")]
    pub fn set_component_visible(&self, component: ChannelType, visible: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_component_visible(self.to_glib_none().0, component.into_glib(), visible.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_set_file")]
    pub fn set_file(&self, file: &impl IsA<gio::File>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_file(self.to_glib_none().0, file.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_set_metadata")]
    pub fn set_metadata(&self, metadata: &Metadata) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_metadata(self.to_glib_none().0, metadata.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_set_palette")]
    pub fn set_palette(&self, new_palette: &Palette) -> Option<Palette> {
        unsafe {
            from_glib_none(ffi::gimp_image_set_palette(self.to_glib_none().0, new_palette.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_set_resolution")]
    pub fn set_resolution(&self, xresolution: f64, yresolution: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_resolution(self.to_glib_none().0, xresolution, yresolution))
        }
    }

    #[doc(alias = "gimp_image_set_simulation_bpc")]
    pub fn set_simulation_bpc(&self, bpc: bool) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_simulation_bpc(self.to_glib_none().0, bpc.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_set_simulation_intent")]
    pub fn set_simulation_intent(&self, intent: ColorRenderingIntent) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_simulation_intent(self.to_glib_none().0, intent.into_glib()))
        }
    }

    #[doc(alias = "gimp_image_set_simulation_profile")]
    pub fn set_simulation_profile(&self, profile: Option<&ColorProfile>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_simulation_profile(self.to_glib_none().0, profile.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_set_simulation_profile_from_file")]
    pub fn set_simulation_profile_from_file(&self, file: &impl IsA<gio::File>) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_simulation_profile_from_file(self.to_glib_none().0, file.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_set_tattoo_state")]
    pub fn set_tattoo_state(&self, tattoo_state: u32) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_tattoo_state(self.to_glib_none().0, tattoo_state))
        }
    }

    #[doc(alias = "gimp_image_set_unit")]
    pub fn set_unit(&self, unit: &Unit) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_set_unit(self.to_glib_none().0, unit.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_take_selected_channels")]
    pub fn take_selected_channels(&self, channels: &[Channel]) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_take_selected_channels(self.to_glib_none().0, channels.to_glib_container().0))
        }
    }

    #[doc(alias = "gimp_image_take_selected_layers")]
    pub fn take_selected_layers(&self, layers: &[Layer]) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_take_selected_layers(self.to_glib_none().0, layers.to_glib_container().0))
        }
    }

    #[doc(alias = "gimp_image_take_selected_paths")]
    pub fn take_selected_paths(&self, paths: &[Path]) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_take_selected_paths(self.to_glib_none().0, paths.to_glib_container().0))
        }
    }

    #[doc(alias = "gimp_image_thaw_channels")]
    pub fn thaw_channels(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_thaw_channels(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_thaw_layers")]
    pub fn thaw_layers(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_thaw_layers(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_thaw_paths")]
    pub fn thaw_paths(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_thaw_paths(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_undo_disable")]
    pub fn undo_disable(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_undo_disable(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_undo_enable")]
    pub fn undo_enable(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_undo_enable(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_undo_freeze")]
    pub fn undo_freeze(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_undo_freeze(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_undo_group_end")]
    pub fn undo_group_end(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_undo_group_end(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_undo_group_start")]
    pub fn undo_group_start(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_undo_group_start(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_undo_is_enabled")]
    pub fn undo_is_enabled(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_undo_is_enabled(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_undo_thaw")]
    pub fn undo_thaw(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_undo_thaw(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_unset_active_channel")]
    pub fn unset_active_channel(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_image_unset_active_channel(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_convert_set_dither_matrix")]
    pub fn convert_set_dither_matrix(width: i32, height: i32, matrix: &glib::Bytes) -> bool {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::gimp_image_convert_set_dither_matrix(width, height, matrix.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_image_get_by_id")]
    #[doc(alias = "get_by_id")]
    pub fn by_id(image_id: i32) -> Option<Image> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_image_get_by_id(image_id))
        }
    }

    #[doc(alias = "gimp_image_id_is_valid")]
    pub fn id_is_valid(image_id: i32) -> bool {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::gimp_image_id_is_valid(image_id))
        }
    }

    #[doc(alias = "gimp_image_metadata_load_thumbnail")]
    pub fn metadata_load_thumbnail(file: &impl IsA<gio::File>) -> Result<Option<Image>, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::gimp_image_metadata_load_thumbnail(file.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_none(ret)) } else { Err(from_glib_full(error)) }
        }
    }
}
