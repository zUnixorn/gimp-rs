// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{translate::*};

glib::wrapper! {
    /// A three by three matrix.
    #[derive(Debug, PartialOrd, Ord, Hash)]
    pub struct Matrix3(Boxed<ffi::GimpMatrix3>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::gimp_matrix3_get_type(), ptr as *mut _) as *mut ffi::GimpMatrix3,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::gimp_matrix3_get_type(), ptr as *mut _),
        type_ => || ffi::gimp_matrix3_get_type(),
    }
}

impl Matrix3 {
    /// Applies the affine transformation given by six values to `self`.
    /// The six values form define an affine transformation matrix as
    /// illustrated below:
    ///
    ///  ( a c e )
    ///  ( b d f )
    ///  ( 0 0 1 )
    /// ## `a`
    /// the 'a' coefficient
    /// ## `b`
    /// the 'b' coefficient
    /// ## `c`
    /// the 'c' coefficient
    /// ## `d`
    /// the 'd' coefficient
    /// ## `e`
    /// the 'e' coefficient
    /// ## `f`
    /// the 'f' coefficient
    #[doc(alias = "gimp_matrix3_affine")]
    pub fn affine(&mut self, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64) {
        unsafe {
            ffi::gimp_matrix3_affine(self.to_glib_none_mut().0, a, b, c, d, e, f);
        }
    }

    /// Calculates the determinant of the given matrix.
    ///
    /// # Returns
    ///
    /// The determinant.
    #[doc(alias = "gimp_matrix3_determinant")]
    pub fn determinant(&self) -> f64 {
        unsafe {
            ffi::gimp_matrix3_determinant(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_matrix3_equal")]
     fn equal(&self, matrix2: &Matrix3) -> bool {
        unsafe {
            from_glib(ffi::gimp_matrix3_equal(self.to_glib_none().0, matrix2.to_glib_none().0))
        }
    }

    /// Sets the matrix to the identity matrix.
    #[doc(alias = "gimp_matrix3_identity")]
    pub fn identity(&mut self) {
        unsafe {
            ffi::gimp_matrix3_identity(self.to_glib_none_mut().0);
        }
    }

    /// Inverts the given matrix.
    #[doc(alias = "gimp_matrix3_invert")]
    pub fn invert(&mut self) {
        unsafe {
            ffi::gimp_matrix3_invert(self.to_glib_none_mut().0);
        }
    }

    /// Checks if the given matrix defines an affine transformation.
    ///
    /// # Returns
    ///
    /// [`true`] if the matrix defines an affine transformation,
    ///  [`false`] otherwise
    #[doc(alias = "gimp_matrix3_is_affine")]
    pub fn is_affine(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_matrix3_is_affine(self.to_glib_none().0))
        }
    }

    /// Checks if the given matrix is diagonal.
    ///
    /// # Returns
    ///
    /// [`true`] if the matrix is diagonal, [`false`] otherwise
    #[doc(alias = "gimp_matrix3_is_diagonal")]
    pub fn is_diagonal(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_matrix3_is_diagonal(self.to_glib_none().0))
        }
    }

    /// Checks if the given matrix is the identity matrix.
    ///
    /// # Returns
    ///
    /// [`true`] if the matrix is the identity matrix, [`false`] otherwise
    #[doc(alias = "gimp_matrix3_is_identity")]
    pub fn is_identity(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_matrix3_is_identity(self.to_glib_none().0))
        }
    }

    /// Checks if we'll need to interpolate when applying this matrix as
    /// a transformation.
    ///
    /// # Returns
    ///
    /// [`true`] if all entries of the upper left 2x2 matrix are
    ///  either 0 or 1, [`false`] otherwise
    #[doc(alias = "gimp_matrix3_is_simple")]
    pub fn is_simple(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_matrix3_is_simple(self.to_glib_none().0))
        }
    }

    /// Multiplies two matrices and puts the result into the second one.
    /// ## `right`
    /// The second input matrix which will be overwritten by the result.
    #[doc(alias = "gimp_matrix3_mult")]
    pub fn mult(&self, right: &mut Matrix3) {
        unsafe {
            ffi::gimp_matrix3_mult(self.to_glib_none().0, right.to_glib_none_mut().0);
        }
    }

    /// Rotates the matrix by theta degrees.
    /// ## `theta`
    /// The angle of rotation (in radians).
    #[doc(alias = "gimp_matrix3_rotate")]
    pub fn rotate(&mut self, theta: f64) {
        unsafe {
            ffi::gimp_matrix3_rotate(self.to_glib_none_mut().0, theta);
        }
    }

    /// Scales the matrix by x and y
    /// ## `x`
    /// X scale factor.
    /// ## `y`
    /// Y scale factor.
    #[doc(alias = "gimp_matrix3_scale")]
    pub fn scale(&mut self, x: f64, y: f64) {
        unsafe {
            ffi::gimp_matrix3_scale(self.to_glib_none_mut().0, x, y);
        }
    }

    /// Transforms a point in 2D as specified by the transformation matrix.
    /// ## `x`
    /// The source X coordinate.
    /// ## `y`
    /// The source Y coordinate.
    ///
    /// # Returns
    ///
    ///
    /// ## `newx`
    /// The transformed X coordinate.
    ///
    /// ## `newy`
    /// The transformed Y coordinate.
    #[doc(alias = "gimp_matrix3_transform_point")]
    pub fn transform_point(&self, x: f64, y: f64) -> (f64, f64) {
        unsafe {
            let mut newx = std::mem::MaybeUninit::uninit();
            let mut newy = std::mem::MaybeUninit::uninit();
            ffi::gimp_matrix3_transform_point(self.to_glib_none().0, x, y, newx.as_mut_ptr(), newy.as_mut_ptr());
            (newx.assume_init(), newy.assume_init())
        }
    }

    /// Translates the matrix by x and y.
    /// ## `x`
    /// Translation in X direction.
    /// ## `y`
    /// Translation in Y direction.
    #[doc(alias = "gimp_matrix3_translate")]
    pub fn translate(&mut self, x: f64, y: f64) {
        unsafe {
            ffi::gimp_matrix3_translate(self.to_glib_none_mut().0, x, y);
        }
    }

    /// Shears the matrix in the X direction.
    /// ## `amount`
    /// X shear amount.
    #[doc(alias = "gimp_matrix3_xshear")]
    pub fn xshear(&mut self, amount: f64) {
        unsafe {
            ffi::gimp_matrix3_xshear(self.to_glib_none_mut().0, amount);
        }
    }

    /// Shears the matrix in the Y direction.
    /// ## `amount`
    /// Y shear amount.
    #[doc(alias = "gimp_matrix3_yshear")]
    pub fn yshear(&mut self, amount: f64) {
        unsafe {
            ffi::gimp_matrix3_yshear(self.to_glib_none_mut().0, amount);
        }
    }
}

impl PartialEq for Matrix3 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.equal(other)
    }
}

impl Eq for Matrix3 {}
