// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Unit};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    /// Basic functions for handling [`Metadata`][crate::Metadata] objects.
    #[doc(alias = "GimpMetadata")]
    pub struct Metadata(Object<ffi::GimpMetadata, ffi::GimpMetadataClass>);

    match fn {
        type_ => || ffi::gimp_metadata_get_type(),
    }
}

impl Metadata {
    /// Creates a new [`Metadata`][crate::Metadata] instance.
    ///
    /// # Returns
    ///
    /// The new [`Metadata`][crate::Metadata].
    #[doc(alias = "gimp_metadata_new")]
    pub fn new() -> Metadata {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_metadata_new())
        }
    }

    #[doc(alias = "gimp_metadata_add_xmp_history")]
    pub fn add_xmp_history(&self, state_status: &str) {
        unsafe {
            ffi::gimp_metadata_add_xmp_history(self.to_glib_none().0, state_status.to_glib_none().0);
        }
    }

    /// Duplicates a [`Metadata`][crate::Metadata] instance.
    ///
    /// # Returns
    ///
    ///
    ///  The new [`Metadata`][crate::Metadata], or [`None`] if `self` is [`None`].
    #[doc(alias = "gimp_metadata_duplicate")]
#[must_use]
    pub fn duplicate(&self) -> Option<Metadata> {
        unsafe {
            from_glib_full(ffi::gimp_metadata_duplicate(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_metadata_get_colorspace")]
    //#[doc(alias = "get_colorspace")]
    //pub fn colorspace(&self) -> /*Ignored*/MetadataColorspace {
    //    unsafe { TODO: call ffi:gimp_metadata_get_colorspace() }
    //}

    /// Returns values based on Exif.Image.XResolution,
    /// Exif.Image.YResolution and Exif.Image.ResolutionUnit of `self`.
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] otherwise.
    ///
    /// ## `xres`
    /// Return location for the X Resolution, in ppi
    ///
    /// ## `yres`
    /// Return location for the Y Resolution, in ppi
    ///
    /// ## `unit`
    /// Return location for the unit unit
    #[doc(alias = "gimp_metadata_get_resolution")]
    #[doc(alias = "get_resolution")]
    pub fn resolution(&self) -> Option<(f64, f64, Unit)> {
        unsafe {
            let mut xres = std::mem::MaybeUninit::uninit();
            let mut yres = std::mem::MaybeUninit::uninit();
            let mut unit = std::ptr::null_mut();
            let ret = from_glib(ffi::gimp_metadata_get_resolution(self.to_glib_none().0, xres.as_mut_ptr(), yres.as_mut_ptr(), &mut unit));
            if ret { Some((xres.assume_init(), yres.assume_init(), from_glib_full(unit))) } else { None }
        }
    }

    /// Saves `self` to `file`.
    /// ## `file`
    /// The file to save the metadata to
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] otherwise.
    #[doc(alias = "gimp_metadata_save_to_file")]
    pub fn save_to_file(&self, file: &impl IsA<gio::File>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_save_to_file(self.to_glib_none().0, file.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Serializes `self` into an XML string that can later be deserialized
    /// using [`deserialize()`][Self::deserialize()].
    ///
    /// # Returns
    ///
    /// The serialized XML string.
    #[doc(alias = "gimp_metadata_serialize")]
    pub fn serialize(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gimp_metadata_serialize(self.to_glib_none().0))
        }
    }

    /// Sets Exif.Image.BitsPerSample on `self`.
    /// ## `bits_per_sample`
    /// Bits per pixel, per component
    #[doc(alias = "gimp_metadata_set_bits_per_sample")]
    pub fn set_bits_per_sample(&self, bits_per_sample: i32) {
        unsafe {
            ffi::gimp_metadata_set_bits_per_sample(self.to_glib_none().0, bits_per_sample);
        }
    }

    //#[doc(alias = "gimp_metadata_set_colorspace")]
    //pub fn set_colorspace(&self, colorspace: /*Ignored*/MetadataColorspace) {
    //    unsafe { TODO: call ffi:gimp_metadata_set_colorspace() }
    //}

    /// Sets the tags from a piece of Exif data on `self`.
    /// ## `exif_data`
    /// The blob of Exif data to set
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] otherwise.
    #[doc(alias = "gimp_metadata_set_from_exif")]
    pub fn set_from_exif(&self, exif_data: &[u8]) -> Result<(), glib::Error> {
        let exif_data_length = exif_data.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_set_from_exif(self.to_glib_none().0, exif_data.to_glib_none().0, exif_data_length, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Sets the tags from a piece of IPTC data on `self`.
    /// ## `iptc_data`
    /// The blob of Iptc data to set
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] otherwise.
    #[doc(alias = "gimp_metadata_set_from_iptc")]
    pub fn set_from_iptc(&self, iptc_data: &[u8]) -> Result<(), glib::Error> {
        let iptc_data_length = iptc_data.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_set_from_iptc(self.to_glib_none().0, iptc_data.to_glib_none().0, iptc_data_length, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Sets the tags from a piece of XMP data on `self`.
    /// ## `xmp_data`
    /// The blob of XMP data to set
    ///
    /// # Returns
    ///
    /// [`true`] on success, [`false`] otherwise.
    #[doc(alias = "gimp_metadata_set_from_xmp")]
    pub fn set_from_xmp(&self, xmp_data: &[u8]) -> Result<(), glib::Error> {
        let xmp_data_length = xmp_data.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_set_from_xmp(self.to_glib_none().0, xmp_data.to_glib_none().0, xmp_data_length, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Sets Exif.Image.ImageWidth and Exif.Image.ImageLength on `self`.
    /// If already present, also sets Exif.Photo.PixelXDimension and
    /// Exif.Photo.PixelYDimension.
    /// ## `width`
    /// Width in pixels
    /// ## `height`
    /// Height in pixels
    #[doc(alias = "gimp_metadata_set_pixel_size")]
    pub fn set_pixel_size(&self, width: i32, height: i32) {
        unsafe {
            ffi::gimp_metadata_set_pixel_size(self.to_glib_none().0, width, height);
        }
    }

    /// Sets Exif.Image.XResolution, Exif.Image.YResolution and
    /// Exif.Image.ResolutionUnit of `self`.
    /// ## `xres`
    /// The image's X Resolution, in ppi
    /// ## `yres`
    /// The image's Y Resolution, in ppi
    /// ## `unit`
    /// The image's unit
    #[doc(alias = "gimp_metadata_set_resolution")]
    pub fn set_resolution(&self, xres: f64, yres: f64, unit: &Unit) {
        unsafe {
            ffi::gimp_metadata_set_resolution(self.to_glib_none().0, xres, yres, unit.to_glib_none().0);
        }
    }

    /// Deserializes a string of XML that has been created by
    /// [`serialize()`][Self::serialize()].
    /// ## `metadata_xml`
    /// A string of serialized metadata XML.
    ///
    /// # Returns
    ///
    /// The new [`Metadata`][crate::Metadata].
    #[doc(alias = "gimp_metadata_deserialize")]
    pub fn deserialize(metadata_xml: &str) -> Option<Metadata> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_metadata_deserialize(metadata_xml.to_glib_none().0))
        }
    }

    /// Generate Version 4 UUID/GUID.
    ///
    /// # Returns
    ///
    /// The new GUID/UUID string.
    #[doc(alias = "gimp_metadata_get_guid")]
    #[doc(alias = "get_guid")]
    pub fn guid() -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_metadata_get_guid())
        }
    }

    /// Returns whether `tag` is supported in a file of type `mime_type`.
    /// ## `tag`
    /// A metadata tag name
    /// ## `mime_type`
    /// A mime type
    ///
    /// # Returns
    ///
    /// [`true`] if the `tag` supported with `mime_type`, [`false`] otherwise.
    #[doc(alias = "gimp_metadata_is_tag_supported")]
    pub fn is_tag_supported(tag: &str, mime_type: &str) -> bool {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::gimp_metadata_is_tag_supported(tag.to_glib_none().0, mime_type.to_glib_none().0))
        }
    }

    /// Loads [`Metadata`][crate::Metadata] from `file`.
    /// ## `file`
    /// The [`gio::File`][crate::gio::File] to load the metadata from
    ///
    /// # Returns
    ///
    /// The loaded [`Metadata`][crate::Metadata].
    #[doc(alias = "gimp_metadata_load_from_file")]
    pub fn load_from_file(file: &impl IsA<gio::File>) -> Result<Metadata, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::gimp_metadata_load_from_file(file.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }
}

impl Default for Metadata {
                     fn default() -> Self {
                         Self::new()
                     }
                 }
