// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,MetadataColorspace,Unit};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "GimpMetadata")]
    pub struct Metadata(Object<ffi::GimpMetadata, ffi::GimpMetadataClass>);

    match fn {
        type_ => || ffi::gimp_metadata_get_type(),
    }
}

impl Metadata {
    #[doc(alias = "gimp_metadata_new")]
    pub fn new() -> Metadata {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_metadata_new())
        }
    }

    #[doc(alias = "gimp_metadata_add_xmp_history")]
    pub fn add_xmp_history(&self, state_status: &str) {
        unsafe {
            ffi::gimp_metadata_add_xmp_history(self.to_glib_none().0, state_status.to_glib_none().0);
        }
    }

    #[doc(alias = "gimp_metadata_duplicate")]
#[must_use]
    pub fn duplicate(&self) -> Option<Metadata> {
        unsafe {
            from_glib_full(ffi::gimp_metadata_duplicate(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_metadata_get_colorspace")]
    #[doc(alias = "get_colorspace")]
    pub fn colorspace(&self) -> MetadataColorspace {
        unsafe {
            from_glib(ffi::gimp_metadata_get_colorspace(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_metadata_get_resolution")]
    #[doc(alias = "get_resolution")]
    pub fn resolution(&self) -> Option<(f64, f64, Unit)> {
        unsafe {
            let mut xres = std::mem::MaybeUninit::uninit();
            let mut yres = std::mem::MaybeUninit::uninit();
            let mut unit = std::ptr::null_mut();
            let ret = from_glib(ffi::gimp_metadata_get_resolution(self.to_glib_none().0, xres.as_mut_ptr(), yres.as_mut_ptr(), &mut unit));
            if ret { Some((xres.assume_init(), yres.assume_init(), from_glib_full(unit))) } else { None }
        }
    }

    #[doc(alias = "gimp_metadata_save_to_file")]
    pub fn save_to_file(&self, file: &impl IsA<gio::File>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_save_to_file(self.to_glib_none().0, file.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "gimp_metadata_serialize")]
    pub fn serialize(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gimp_metadata_serialize(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_metadata_set_bits_per_sample")]
    pub fn set_bits_per_sample(&self, bits_per_sample: i32) {
        unsafe {
            ffi::gimp_metadata_set_bits_per_sample(self.to_glib_none().0, bits_per_sample);
        }
    }

    #[doc(alias = "gimp_metadata_set_colorspace")]
    pub fn set_colorspace(&self, colorspace: MetadataColorspace) {
        unsafe {
            ffi::gimp_metadata_set_colorspace(self.to_glib_none().0, colorspace.into_glib());
        }
    }

    #[doc(alias = "gimp_metadata_set_from_exif")]
    pub fn set_from_exif(&self, exif_data: &[u8]) -> Result<(), glib::Error> {
        let exif_data_length = exif_data.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_set_from_exif(self.to_glib_none().0, exif_data.to_glib_none().0, exif_data_length, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "gimp_metadata_set_from_iptc")]
    pub fn set_from_iptc(&self, iptc_data: &[u8]) -> Result<(), glib::Error> {
        let iptc_data_length = iptc_data.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_set_from_iptc(self.to_glib_none().0, iptc_data.to_glib_none().0, iptc_data_length, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "gimp_metadata_set_from_xmp")]
    pub fn set_from_xmp(&self, xmp_data: &[u8]) -> Result<(), glib::Error> {
        let xmp_data_length = xmp_data.len() as _;
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gimp_metadata_set_from_xmp(self.to_glib_none().0, xmp_data.to_glib_none().0, xmp_data_length, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "gimp_metadata_set_pixel_size")]
    pub fn set_pixel_size(&self, width: i32, height: i32) {
        unsafe {
            ffi::gimp_metadata_set_pixel_size(self.to_glib_none().0, width, height);
        }
    }

    #[doc(alias = "gimp_metadata_set_resolution")]
    pub fn set_resolution(&self, xres: f64, yres: f64, unit: &Unit) {
        unsafe {
            ffi::gimp_metadata_set_resolution(self.to_glib_none().0, xres, yres, unit.to_glib_none().0);
        }
    }

    #[doc(alias = "gimp_metadata_deserialize")]
    pub fn deserialize(metadata_xml: &str) -> Option<Metadata> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_metadata_deserialize(metadata_xml.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_metadata_get_guid")]
    #[doc(alias = "get_guid")]
    pub fn guid() -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_metadata_get_guid())
        }
    }

    #[doc(alias = "gimp_metadata_is_tag_supported")]
    pub fn is_tag_supported(tag: &str, mime_type: &str) -> bool {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::gimp_metadata_is_tag_supported(tag.to_glib_none().0, mime_type.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_metadata_load_from_file")]
    pub fn load_from_file(file: &impl IsA<gio::File>) -> Result<Metadata, glib::Error> {
        assert_initialized_main_thread!();
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::gimp_metadata_load_from_file(file.as_ref().to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }
}

impl Default for Metadata {
                     fn default() -> Self {
                         Self::new()
                     }
                 }
