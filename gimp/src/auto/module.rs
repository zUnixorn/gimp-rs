// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,ModuleState};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    /// [`Module`][crate::Module] is a generic mechanism to dynamically load modules into
    /// GIMP. It is a `GTypeModule` subclass, implementing module loading
    /// using `GModule`. [`Module`][crate::Module] does not know which functionality is
    /// implemented by the modules, it just provides a framework to get
    /// arbitrary `GType` implementations loaded from disk.
    ///
    /// ## Properties
    ///
    ///
    /// #### `auto-load`
    ///  Readable | Writeable
    ///
    ///
    /// #### `on-disk`
    ///  Readable
    ///
    /// # Implements
    ///
    /// [`ModuleExt`][trait@crate::prelude::ModuleExt], [`trait@glib::ObjectExt`]
    #[doc(alias = "GimpModule")]
    pub struct Module(Object<ffi::GimpModule, ffi::GimpModuleClass>);

    match fn {
        type_ => || ffi::gimp_module_get_type(),
    }
}

impl Module {
        pub const NONE: Option<&'static Module> = None;
    

    /// Creates a new [`Module`][crate::Module] instance.
    /// ## `file`
    /// A [`gio::File`][crate::gio::File] pointing to a loadable module.
    /// ## `auto_load`
    /// Pass [`true`] to exclude this module from auto-loading.
    /// ## `verbose`
    /// Pass [`true`] to enable debugging output.
    ///
    /// # Returns
    ///
    /// The new [`Module`][crate::Module] object.
    #[doc(alias = "gimp_module_new")]
    pub fn new(file: &impl IsA<gio::File>, auto_load: bool, verbose: bool) -> Module {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_module_new(file.as_ref().to_glib_none().0, auto_load.into_glib(), verbose.into_glib()))
        }
    }

    /// This function is never called directly. Use GIMP_MODULE_ERROR() instead.
    ///
    /// # Returns
    ///
    /// the `GQuark` that defines the GIMP module error domain.
    #[doc(alias = "gimp_module_error_quark")]
    pub fn error_quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::gimp_module_error_quark())
        }
    }

    //#[doc(alias = "gimp_module_query")]
    //pub fn query(module: /*Ignored*/&glib::TypeModule) -> /*Ignored*/Option<ModuleInfo> {
    //    unsafe { TODO: call ffi:gimp_module_query() }
    //}

    //#[doc(alias = "gimp_module_register")]
    //pub fn register(module: /*Ignored*/&glib::TypeModule) -> bool {
    //    unsafe { TODO: call ffi:gimp_module_register() }
    //}
}

/// Trait containing all [`struct@Module`] methods.
///
/// # Implementors
///
/// [`Module`][struct@crate::Module]
pub trait ModuleExt: IsA<Module> + 'static {
    /// Returns whether this `self` in automatically loaded at startup.
    ///
    /// # Returns
    ///
    /// The `self`'s 'auto_load' property.
    #[doc(alias = "gimp_module_get_auto_load")]
    #[doc(alias = "get_auto_load")]
    #[doc(alias = "auto-load")]
    fn is_auto_load(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_module_get_auto_load(self.as_ref().to_glib_none().0))
        }
    }

    /// Returns [`gio::File`][crate::gio::File] of the `self`,
    ///
    /// # Returns
    ///
    /// The `self`'s [`gio::File`][crate::gio::File].
    #[doc(alias = "gimp_module_get_file")]
    #[doc(alias = "get_file")]
    fn file(&self) -> Option<gio::File> {
        unsafe {
            from_glib_none(ffi::gimp_module_get_file(self.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_module_get_info")]
    //#[doc(alias = "get_info")]
    //fn info(&self) -> /*Ignored*/Option<ModuleInfo> {
    //    unsafe { TODO: call ffi:gimp_module_get_info() }
    //}

    ///
    /// # Returns
    ///
    /// The `self`'s last error message.
    #[doc(alias = "gimp_module_get_last_error")]
    #[doc(alias = "get_last_error")]
    fn last_error(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gimp_module_get_last_error(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// The `self`'s state.
    #[doc(alias = "gimp_module_get_state")]
    #[doc(alias = "get_state")]
    fn state(&self) -> ModuleState {
        unsafe {
            from_glib(ffi::gimp_module_get_state(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// Whether the `self` is currently loaded.
    #[doc(alias = "gimp_module_is_loaded")]
    fn is_loaded(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_module_is_loaded(self.as_ref().to_glib_none().0))
        }
    }

    ///
    /// # Returns
    ///
    /// Whether the `self` is present on diak.
    #[doc(alias = "gimp_module_is_on_disk")]
    #[doc(alias = "on-disk")]
    fn is_on_disk(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_module_is_on_disk(self.as_ref().to_glib_none().0))
        }
    }

    /// Queries the module without actually registering any of the types it
    /// may implement. After successful query, `gimp_module_get_info()` can be
    /// used to get further about the module.
    ///
    /// # Returns
    ///
    /// [`true`] on success.
    #[doc(alias = "gimp_module_query_module")]
    fn query_module(&self) -> bool {
        unsafe {
            from_glib(ffi::gimp_module_query_module(self.as_ref().to_glib_none().0))
        }
    }

    /// Sets the `auto_load` property of the module
    /// ## `auto_load`
    /// Pass [`false`] to exclude this module from auto-loading
    #[doc(alias = "gimp_module_set_auto_load")]
    #[doc(alias = "auto-load")]
    fn set_auto_load(&self, auto_load: bool) {
        unsafe {
            ffi::gimp_module_set_auto_load(self.as_ref().to_glib_none().0, auto_load.into_glib());
        }
    }

    #[doc(alias = "auto-load")]
    fn connect_auto_load_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auto_load_trampoline<P: IsA<Module>, F: Fn(&P) + 'static>(this: *mut ffi::GimpModule, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Module::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::auto-load".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_auto_load_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "on-disk")]
    fn connect_on_disk_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_on_disk_trampoline<P: IsA<Module>, F: Fn(&P) + 'static>(this: *mut ffi::GimpModule, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Module::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::on-disk".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_on_disk_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Module>> ModuleExt for O {}
