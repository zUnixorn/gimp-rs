// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Resource};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "GimpPalette")]
    pub struct Palette(Object<ffi::GimpPalette, ffi::GimpPaletteClass>) @extends Resource;

    match fn {
        type_ => || ffi::gimp_palette_get_type(),
    }
}

impl Palette {
    #[doc(alias = "gimp_palette_new")]
    pub fn new(name: &str) -> Palette {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_palette_new(name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_palette_add_entry")]
    pub fn add_entry(&self, entry_name: &str, color: &impl IsA<gegl::Color>) -> Option<i32> {
        unsafe {
            let mut entry_num = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_palette_add_entry(self.to_glib_none().0, entry_name.to_glib_none().0, color.as_ref().to_glib_none().0, entry_num.as_mut_ptr()));
            if ret { Some(entry_num.assume_init()) } else { None }
        }
    }

    #[doc(alias = "gimp_palette_delete_entry")]
    pub fn delete_entry(&self, entry_num: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_palette_delete_entry(self.to_glib_none().0, entry_num))
        }
    }

    #[doc(alias = "gimp_palette_get_color_count")]
    #[doc(alias = "get_color_count")]
    pub fn color_count(&self) -> i32 {
        unsafe {
            ffi::gimp_palette_get_color_count(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_palette_get_colormap")]
    #[doc(alias = "get_colormap")]
    pub fn colormap(&self, format: &babl::Object) -> (Vec<u8>, i32) {
        unsafe {
            let mut num_colors = std::mem::MaybeUninit::uninit();
            let mut num_bytes = std::mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_full_num(ffi::gimp_palette_get_colormap(self.to_glib_none().0, format.to_glib_none().0, num_colors.as_mut_ptr(), num_bytes.as_mut_ptr()), num_bytes.assume_init() as _);
            (ret, num_colors.assume_init())
        }
    }

    #[doc(alias = "gimp_palette_get_colors")]
    #[doc(alias = "get_colors")]
    pub fn colors(&self) -> Vec<gegl::Color> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::gimp_palette_get_colors(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_palette_get_columns")]
    #[doc(alias = "get_columns")]
    pub fn columns(&self) -> i32 {
        unsafe {
            ffi::gimp_palette_get_columns(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gimp_palette_get_entry_color")]
    #[doc(alias = "get_entry_color")]
    pub fn entry_color(&self, entry_num: i32) -> Option<gegl::Color> {
        unsafe {
            from_glib_full(ffi::gimp_palette_get_entry_color(self.to_glib_none().0, entry_num))
        }
    }

    #[doc(alias = "gimp_palette_get_entry_name")]
    #[doc(alias = "get_entry_name")]
    pub fn entry_name(&self, entry_num: i32) -> Option<glib::GString> {
        unsafe {
            let mut entry_name = std::ptr::null_mut();
            let ret = from_glib(ffi::gimp_palette_get_entry_name(self.to_glib_none().0, entry_num, &mut entry_name));
            if ret { Some(from_glib_full(entry_name)) } else { None }
        }
    }

    #[doc(alias = "gimp_palette_set_columns")]
    pub fn set_columns(&self, columns: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_palette_set_columns(self.to_glib_none().0, columns))
        }
    }

    #[doc(alias = "gimp_palette_set_entry_color")]
    pub fn set_entry_color(&self, entry_num: i32, color: &impl IsA<gegl::Color>) -> bool {
        unsafe {
            from_glib(ffi::gimp_palette_set_entry_color(self.to_glib_none().0, entry_num, color.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_palette_set_entry_name")]
    pub fn set_entry_name(&self, entry_num: i32, entry_name: &str) -> bool {
        unsafe {
            from_glib(ffi::gimp_palette_set_entry_name(self.to_glib_none().0, entry_num, entry_name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_palette_get_by_name")]
    #[doc(alias = "get_by_name")]
    pub fn by_name(name: &str) -> Option<Palette> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_palette_get_by_name(name.to_glib_none().0))
        }
    }
}
