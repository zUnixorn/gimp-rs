// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Image,Item,Layer,OrientationType,PathStrokeType};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "GimpPath")]
    pub struct Path(Object<ffi::GimpPath, ffi::GimpPathClass>) @extends Item;

    match fn {
        type_ => || ffi::gimp_path_get_type(),
    }
}

impl Path {
    #[doc(alias = "gimp_path_new")]
    pub fn new(image: &Image, name: &str) -> Path {
        skip_assert_initialized!();
        unsafe {
            from_glib_none(ffi::gimp_path_new(image.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_path_new_from_text_layer")]
    #[doc(alias = "new_from_text_layer")]
    pub fn from_text_layer(image: &Image, layer: &impl IsA<Layer>) -> Path {
        skip_assert_initialized!();
        unsafe {
            from_glib_none(ffi::gimp_path_new_from_text_layer(image.to_glib_none().0, layer.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_path_bezier_stroke_conicto")]
    pub fn bezier_stroke_conicto(&self, stroke_id: i32, x0: f64, y0: f64, x1: f64, y1: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_bezier_stroke_conicto(self.to_glib_none().0, stroke_id, x0, y0, x1, y1))
        }
    }

    #[doc(alias = "gimp_path_bezier_stroke_cubicto")]
    pub fn bezier_stroke_cubicto(&self, stroke_id: i32, x0: f64, y0: f64, x1: f64, y1: f64, x2: f64, y2: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_bezier_stroke_cubicto(self.to_glib_none().0, stroke_id, x0, y0, x1, y1, x2, y2))
        }
    }

    #[doc(alias = "gimp_path_bezier_stroke_lineto")]
    pub fn bezier_stroke_lineto(&self, stroke_id: i32, x0: f64, y0: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_bezier_stroke_lineto(self.to_glib_none().0, stroke_id, x0, y0))
        }
    }

    #[doc(alias = "gimp_path_bezier_stroke_new_ellipse")]
    pub fn bezier_stroke_new_ellipse(&self, x0: f64, y0: f64, radius_x: f64, radius_y: f64, angle: f64) -> i32 {
        unsafe {
            ffi::gimp_path_bezier_stroke_new_ellipse(self.to_glib_none().0, x0, y0, radius_x, radius_y, angle)
        }
    }

    #[doc(alias = "gimp_path_bezier_stroke_new_moveto")]
    pub fn bezier_stroke_new_moveto(&self, x0: f64, y0: f64) -> i32 {
        unsafe {
            ffi::gimp_path_bezier_stroke_new_moveto(self.to_glib_none().0, x0, y0)
        }
    }

    #[doc(alias = "gimp_path_copy")]
#[must_use]
    pub fn copy(&self) -> Option<Path> {
        unsafe {
            from_glib_none(ffi::gimp_path_copy(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gimp_path_get_strokes")]
    #[doc(alias = "get_strokes")]
    pub fn strokes(&self) -> Vec<i32> {
        unsafe {
            let mut num_strokes = std::mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_full_num(ffi::gimp_path_get_strokes(self.to_glib_none().0, num_strokes.as_mut_ptr()), num_strokes.assume_init() as _);
            ret
        }
    }

    #[doc(alias = "gimp_path_remove_stroke")]
    pub fn remove_stroke(&self, stroke_id: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_remove_stroke(self.to_glib_none().0, stroke_id))
        }
    }

    #[doc(alias = "gimp_path_stroke_close")]
    pub fn stroke_close(&self, stroke_id: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_stroke_close(self.to_glib_none().0, stroke_id))
        }
    }

    #[doc(alias = "gimp_path_stroke_flip")]
    pub fn stroke_flip(&self, stroke_id: i32, flip_type: OrientationType, axis: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_stroke_flip(self.to_glib_none().0, stroke_id, flip_type.into_glib(), axis))
        }
    }

    #[doc(alias = "gimp_path_stroke_flip_free")]
    pub fn stroke_flip_free(&self, stroke_id: i32, x1: f64, y1: f64, x2: f64, y2: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_stroke_flip_free(self.to_glib_none().0, stroke_id, x1, y1, x2, y2))
        }
    }

    #[doc(alias = "gimp_path_stroke_get_length")]
    pub fn stroke_get_length(&self, stroke_id: i32, precision: f64) -> f64 {
        unsafe {
            ffi::gimp_path_stroke_get_length(self.to_glib_none().0, stroke_id, precision)
        }
    }

    #[doc(alias = "gimp_path_stroke_get_point_at_dist")]
    pub fn stroke_get_point_at_dist(&self, stroke_id: i32, dist: f64, precision: f64) -> Option<(f64, f64, f64, bool)> {
        unsafe {
            let mut x_point = std::mem::MaybeUninit::uninit();
            let mut y_point = std::mem::MaybeUninit::uninit();
            let mut slope = std::mem::MaybeUninit::uninit();
            let mut valid = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_path_stroke_get_point_at_dist(self.to_glib_none().0, stroke_id, dist, precision, x_point.as_mut_ptr(), y_point.as_mut_ptr(), slope.as_mut_ptr(), valid.as_mut_ptr()));
            if ret { Some((x_point.assume_init(), y_point.assume_init(), slope.assume_init(), from_glib(valid.assume_init()))) } else { None }
        }
    }

    #[doc(alias = "gimp_path_stroke_get_points")]
    pub fn stroke_get_points(&self, stroke_id: i32) -> (PathStrokeType, Vec<f64>, bool) {
        unsafe {
            let mut num_points = std::mem::MaybeUninit::uninit();
            let mut controlpoints = std::ptr::null_mut();
            let mut closed = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gimp_path_stroke_get_points(self.to_glib_none().0, stroke_id, num_points.as_mut_ptr(), &mut controlpoints, closed.as_mut_ptr()));
            (ret, FromGlibContainer::from_glib_full_num(controlpoints, num_points.assume_init() as _), from_glib(closed.assume_init()))
        }
    }

    #[doc(alias = "gimp_path_stroke_interpolate")]
    pub fn stroke_interpolate(&self, stroke_id: i32, precision: f64) -> (Vec<f64>, bool) {
        unsafe {
            let mut num_coords = std::mem::MaybeUninit::uninit();
            let mut closed = std::mem::MaybeUninit::uninit();
            let ret = FromGlibContainer::from_glib_full_num(ffi::gimp_path_stroke_interpolate(self.to_glib_none().0, stroke_id, precision, num_coords.as_mut_ptr(), closed.as_mut_ptr()), num_coords.assume_init() as _);
            (ret, from_glib(closed.assume_init()))
        }
    }

    #[doc(alias = "gimp_path_stroke_new_from_points")]
    pub fn stroke_new_from_points(&self, type_: PathStrokeType, controlpoints: &[f64], closed: bool) -> i32 {
        let num_points = controlpoints.len() as _;
        unsafe {
            ffi::gimp_path_stroke_new_from_points(self.to_glib_none().0, type_.into_glib(), num_points, controlpoints.to_glib_none().0, closed.into_glib())
        }
    }

    #[doc(alias = "gimp_path_stroke_reverse")]
    pub fn stroke_reverse(&self, stroke_id: i32) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_stroke_reverse(self.to_glib_none().0, stroke_id))
        }
    }

    #[doc(alias = "gimp_path_stroke_rotate")]
    pub fn stroke_rotate(&self, stroke_id: i32, center_x: f64, center_y: f64, angle: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_stroke_rotate(self.to_glib_none().0, stroke_id, center_x, center_y, angle))
        }
    }

    #[doc(alias = "gimp_path_stroke_scale")]
    pub fn stroke_scale(&self, stroke_id: i32, scale_x: f64, scale_y: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_stroke_scale(self.to_glib_none().0, stroke_id, scale_x, scale_y))
        }
    }

    #[doc(alias = "gimp_path_stroke_translate")]
    pub fn stroke_translate(&self, stroke_id: i32, off_x: f64, off_y: f64) -> bool {
        unsafe {
            from_glib(ffi::gimp_path_stroke_translate(self.to_glib_none().0, stroke_id, off_x, off_y))
        }
    }

    #[doc(alias = "gimp_path_get_by_id")]
    #[doc(alias = "get_by_id")]
    pub fn by_id(path_id: i32) -> Option<Path> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_path_get_by_id(path_id))
        }
    }

    #[doc(alias = "gimp_path_get_user_writable_dir")]
    #[doc(alias = "get_user_writable_dir")]
    pub fn user_writable_dir(path: &[&std::path::Path]) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_path_get_user_writable_dir(path.to_glib_none().0))
        }
    }

    //#[doc(alias = "gimp_path_parse")]
    //pub fn parse(path: &str, max_paths: i32, check: bool, check_failed: /*Unimplemented*/Vec<std::path::PathBuf>) -> Vec<std::path::PathBuf> {
    //    unsafe { TODO: call ffi:gimp_path_parse() }
    //}

    #[doc(alias = "gimp_path_to_str")]
    pub fn to_str(path: &[&std::path::Path]) -> Option<std::path::PathBuf> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gimp_path_to_str(path.to_glib_none().0))
        }
    }
}
