// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,PDBErrorHandler,Procedure};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    /// The base class for plug-ins to derive from.
    ///
    /// GimpPlugIn manages the plug-in's [class`Procedure`] objects. The procedures a
    /// plug-in implements are registered with GIMP by returning a list of their
    /// names from either [vfunc[`PlugIn`][crate::PlugIn]] or
    /// [vfunc[`PlugIn`][crate::PlugIn]].
    ///
    /// Every GIMP plug-in has to be implemented as a subclass and make it known to
    /// the libgimp infrastructure and the main GIMP application by passing its
    /// `GType` to [func`MAIN`].
    ///
    /// [func`MAIN`] passes the 'argc' and 'argv' of the platform's `main()` function,
    /// along with the `GType`, to [func`main`], which creates an instance of the
    /// plug-in's `GimpPlugIn` subclass and calls its virtual functions, depending
    /// on how the plug-in was called by GIMP.
    ///
    /// There are 3 different ways GIMP calls a plug-in: "query", "init" and "run".
    ///
    /// The plug-in is called in "query" mode once after it was installed, or when
    /// the cached plug-in information in the config file "pluginrc" needs to be
    /// recreated. In "query" mode, [vfunc[`PlugIn`][crate::PlugIn]] is called
    /// and returns a list of procedure names the plug-in implements. This is the
    /// "normal" place to register procedures, because the existence of most
    /// procedures doesn't depend on things that change between GIMP sessions.
    ///
    /// The plug-in is called in "init" mode at each GIMP startup, and
    /// [vfunc`PlugIn`] is called and returns a list of procedure
    /// names this plug-in implements. This only happens if the plug-in actually
    /// implements [vfunc[`PlugIn`][crate::PlugIn]]. A plug-in only needs to
    /// implement init_procedures if the existence of its procedures can change
    /// between GIMP sessions, for example if they depend on the presence of
    /// external tools, or hardware like scanners, or online services, or whatever
    /// variable circumstances.
    ///
    /// In order to register the plug-in's procedures with the main GIMP application
    /// in the plug-in's "query" and "init" modes, [class`PlugIn`] calls
    /// [vfunc`PlugIn`] on all procedure names in the exact order of
    /// the list returned by [vfunc`PlugIn`] or
    /// [vfunc`PlugIn`] and then registers the returned
    /// [class`Procedure`].
    ///
    /// The plug-in is called in "run" mode whenever one of the procedures it
    /// implements is called by either the main GIMP application or any other
    /// plug-in. In "run" mode, one of the procedure names returned by
    /// [vfunc`PlugIn`] or [vfunc`PlugIn`] is passed
    /// to [vfunc`PlugIn`] which must return a [class`Procedure`] for
    /// the passed name. The procedure is then executed by calling
    /// [method`Procedure`].
    ///
    /// In any of the three modes, [vfunc`PlugIn`] is called before the plug-in
    /// process exits, so the plug-in can perform whatever cleanup necessary.
    ///
    /// ## Properties
    ///
    ///
    /// #### `program-name`
    ///  The program name as usually found on argv[0]
    ///
    /// Writeable | Construct Only
    ///
    ///
    /// #### `read-channel`
    ///  The [struct`GLib`] to read from GIMP
    ///
    /// Readable | Writeable | Construct Only
    ///
    ///
    /// #### `write-channel`
    ///  The [struct`GLib`] to write to GIMP
    ///
    /// Readable | Writeable | Construct Only
    ///
    /// # Implements
    ///
    /// [`PlugInExt`][trait@crate::prelude::PlugInExt]
    #[doc(alias = "GimpPlugIn")]
    pub struct PlugIn(Object<ffi::GimpPlugIn, ffi::GimpPlugInClass>);

    match fn {
        type_ => || ffi::gimp_plug_in_get_type(),
    }
}

impl PlugIn {
        pub const NONE: Option<&'static PlugIn> = None;
    

    /// Returns the default top directory for GIMP plug-ins and modules. If
    /// the environment variable GIMP3_PLUGINDIR exists, that is used. It
    /// should be an absolute pathname. Otherwise, on Unix the compile-time
    /// defined directory is used. On Windows, the installation directory
    /// as deduced from the executable's full filename is used.
    ///
    /// Note that the actual directories used for GIMP plug-ins and modules
    /// can be overridden by the user in the preferences dialog.
    ///
    /// In config files such as gimprc, the string ${gimp_plug_in_dir}
    /// expands to this directory.
    ///
    /// The returned string is owned by GIMP and must not be modified or
    /// freed. The returned string is in the encoding used for filenames by
    /// GLib, which isn't necessarily UTF-8. (On Windows it always is
    /// UTF-8.)
    ///
    /// # Returns
    ///
    /// The top directory for GIMP plug_ins and modules.
    #[doc(alias = "gimp_plug_in_directory")]
    pub fn directory() -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::gimp_plug_in_directory())
        }
    }

    //#[doc(alias = "gimp_plug_in_directory_file")]
    //pub fn directory_file(first_element: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<gio::File> {
    //    unsafe { TODO: call ffi:gimp_plug_in_directory_file() }
    //}

    /// Generic `GQuark` error domain for plug-ins. Plug-ins are welcome to
    /// create their own domain when they want to handle advanced error
    /// handling. Often, you just want to pass an error message to the core.
    /// This domain can be used for such simple usage.
    ///
    /// See [`glib::Error`][crate::glib::Error] for information on error domains.
    #[doc(alias = "gimp_plug_in_error_quark")]
    pub fn error_quark() -> glib::Quark {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(ffi::gimp_plug_in_error_quark())
        }
    }
}

/// Trait containing all [`struct@PlugIn`] methods.
///
/// # Implementors
///
/// [`PlugIn`][struct@crate::PlugIn]
pub trait PlugInExt: IsA<PlugIn> + 'static {
    /// Add a new sub-menu to the GIMP menus.
    ///
    /// This function installs a sub-menu which does not belong to any
    /// procedure at the location `menu_path`.
    ///
    /// For translations of `menu_label` to work properly, `menu_label`
    /// should only be marked for translation but passed to this function
    /// untranslated, for example using N_("Submenu"). GIMP will look up
    /// the translation in the textdomain registered for the plug-in.
    ///
    /// See also: [`ProcedureExt::add_menu_path()`][crate::prelude::ProcedureExt::add_menu_path()].
    /// ## `menu_path`
    /// The sub-menu's menu path.
    /// ## `menu_label`
    /// The menu label of the sub-menu.
    #[doc(alias = "gimp_plug_in_add_menu_branch")]
    fn add_menu_branch(&self, menu_path: &str, menu_label: &str) {
        unsafe {
            ffi::gimp_plug_in_add_menu_branch(self.as_ref().to_glib_none().0, menu_path.to_glib_none().0, menu_label.to_glib_none().0);
        }
    }

    /// This function adds a temporary procedure to `self`. It is usually
    /// called from a [`PDBProcType::Persistent`][crate::PDBProcType::Persistent] procedure's
    /// [vfunc`Procedure`].
    ///
    /// A temporary procedure is a procedure which is only available while
    /// one of your plug-in's "real" procedures is running.
    ///
    /// The procedure's type _must_ be
    /// [`PDBProcType::Temporary`][crate::PDBProcType::Temporary] or the function will fail.
    ///
    /// NOTE: Normally, plug-in communication is triggered by the plug-in
    /// and the GIMP core only responds to the plug-in's requests. You must
    /// explicitly enable receiving of temporary procedure run requests
    /// using either [method`PlugIn`] or
    /// [method`PlugIn`]. See their respective
    /// documentation for details.
    /// ## `procedure`
    /// A [`Procedure`][crate::Procedure] of type [`PDBProcType::Temporary`][crate::PDBProcType::Temporary].
    #[doc(alias = "gimp_plug_in_add_temp_procedure")]
    fn add_temp_procedure(&self, procedure: &impl IsA<Procedure>) {
        unsafe {
            ffi::gimp_plug_in_add_temp_procedure(self.as_ref().to_glib_none().0, procedure.as_ref().to_glib_none().0);
        }
    }

    /// Retrieves the active error handler for procedure calls.
    ///
    /// This procedure retrieves the currently active error handler for
    /// procedure calls made by the calling plug-in. See
    /// `gimp_plugin_set_pdb_error_handler()` for details.
    ///
    /// # Returns
    ///
    /// Who is responsible for handling procedure call errors.
    #[doc(alias = "gimp_plug_in_get_pdb_error_handler")]
    #[doc(alias = "get_pdb_error_handler")]
    fn pdb_error_handler(&self) -> PDBErrorHandler {
        unsafe {
            from_glib(ffi::gimp_plug_in_get_pdb_error_handler(self.as_ref().to_glib_none().0))
        }
    }

    /// This function retrieves a temporary procedure from `self` by the
    /// procedure's `procedure_name`.
    /// ## `procedure_name`
    /// The name of a [class`Procedure`] added to `self`.
    ///
    /// # Returns
    ///
    /// The procedure if registered, or [`None`].
    #[doc(alias = "gimp_plug_in_get_temp_procedure")]
    #[doc(alias = "get_temp_procedure")]
    fn temp_procedure(&self, procedure_name: &str) -> Option<Procedure> {
        unsafe {
            from_glib_none(ffi::gimp_plug_in_get_temp_procedure(self.as_ref().to_glib_none().0, procedure_name.to_glib_none().0))
        }
    }

    /// This function retrieves the list of temporary procedure of `self` as
    /// added with [method`PlugIn`].
    ///
    /// # Returns
    ///
    /// The list of
    ///  procedures.
    #[doc(alias = "gimp_plug_in_get_temp_procedures")]
    #[doc(alias = "get_temp_procedures")]
    fn temp_procedures(&self) -> Vec<Procedure> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::gimp_plug_in_get_temp_procedures(self.as_ref().to_glib_none().0))
        }
    }

    /// Enables asynchronous processing of messages from the main GIMP
    /// application.
    ///
    /// Normally, a plug-in is not called by GIMP except for the call to
    /// the procedure it implements. All subsequent communication is
    /// triggered by the plug-in and all messages sent from GIMP to the
    /// plug-in are just answers to requests the plug-in made.
    ///
    /// If the plug-in however registered temporary procedures using
    /// [method`PlugIn`], it needs to be able to receive
    /// requests to execute them. Usually this will be done by running
    /// [method`PlugIn`] in an endless loop.
    ///
    /// If the plug-in cannot use [method`PlugIn`], i.e. if
    /// it has a GUI and is hanging around in a [struct`GLib`], it
    /// must call [method`PlugIn`].
    ///
    /// Note that the plug-in does not need to be a
    /// [enum`Gimp`.PERSISTENT] to register temporary procedures.
    ///
    /// See also: [method`PlugIn`].
    #[doc(alias = "gimp_plug_in_persistent_enable")]
    fn persistent_enable(&self) {
        unsafe {
            ffi::gimp_plug_in_persistent_enable(self.as_ref().to_glib_none().0);
        }
    }

    /// Processes one message sent by GIMP and returns.
    ///
    /// Call this function in an endless loop after calling
    /// [method`Gimp`.persistent_ready] to process requests for
    /// running temporary procedures.
    ///
    /// See [method`PlugIn`] for an asynchronous way of
    /// doing the same if running an endless loop is not an option.
    ///
    /// See also: [method`PlugIn`].
    /// ## `timeout`
    /// The timeout (in ms) to use for the `select()` call.
    #[doc(alias = "gimp_plug_in_persistent_process")]
    fn persistent_process(&self, timeout: u32) {
        unsafe {
            ffi::gimp_plug_in_persistent_process(self.as_ref().to_glib_none().0, timeout);
        }
    }

    /// This function removes a temporary procedure from `self` by the
    /// procedure's `procedure_name`.
    /// ## `procedure_name`
    /// The name of a [class`Procedure`] added to `self`.
    #[doc(alias = "gimp_plug_in_remove_temp_procedure")]
    fn remove_temp_procedure(&self, procedure_name: &str) {
        unsafe {
            ffi::gimp_plug_in_remove_temp_procedure(self.as_ref().to_glib_none().0, procedure_name.to_glib_none().0);
        }
    }

    /// Set a help domain and path for the `self`.
    ///
    /// This function registers user documentation for the calling plug-in
    /// with the GIMP help system. The `domain_uri` parameter points to the
    /// root directory where the plug-in help is installed. For each
    /// supported language there should be a file called 'gimp-help.xml'
    /// that maps the help IDs to the actual help files.
    ///
    /// This function can only be called in the
    /// [vfunc`PlugIn`] function of a plug-in.
    /// ## `domain_name`
    /// The XML namespace of the plug-in's help pages.
    /// ## `domain_uri`
    /// The root URI of the plug-in's help pages.
    #[doc(alias = "gimp_plug_in_set_help_domain")]
    fn set_help_domain(&self, domain_name: &str, domain_uri: &impl IsA<gio::File>) {
        unsafe {
            ffi::gimp_plug_in_set_help_domain(self.as_ref().to_glib_none().0, domain_name.to_glib_none().0, domain_uri.as_ref().to_glib_none().0);
        }
    }

    /// Sets an error handler for procedure calls.
    ///
    /// This procedure changes the way that errors in procedure calls are
    /// handled. By default GIMP will raise an error dialog if a procedure
    /// call made by a plug-in fails. Using this procedure the plug-in can
    /// change this behavior. If the error handler is set to
    /// [`PDBErrorHandler::Plugin`][crate::PDBErrorHandler::Plugin], then the plug-in is responsible for
    /// calling `gimp_pdb_get_last_error()` and handling the error whenever
    /// one if its procedure calls fails. It can do this by displaying the
    /// error message or by forwarding it in its own return values.
    /// ## `handler`
    /// Who is responsible for handling procedure call errors.
    #[doc(alias = "gimp_plug_in_set_pdb_error_handler")]
    fn set_pdb_error_handler(&self, handler: PDBErrorHandler) {
        unsafe {
            ffi::gimp_plug_in_set_pdb_error_handler(self.as_ref().to_glib_none().0, handler.into_glib());
        }
    }
}

impl<O: IsA<PlugIn>> PlugInExt for O {}
