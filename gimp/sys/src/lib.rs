// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../..
// from ../../gir-files
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use glib_sys as glib;
use gobject_sys as gobject;
use gio_sys as gio;
use babl_sys as babl;
use gdk_pixbuf_sys as gdk_pixbuf;
use gegl_sys as gegl;
use cairo_sys as cairo;
use pango_sys as pango;

#[allow(unused_imports)]
use std::ffi::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong, c_void};
#[allow(unused_imports)]
use libc::{size_t, ssize_t, time_t, off_t, intptr_t, uintptr_t, FILE};
#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type GimpBablFormat = *const babl::Babl;
pub type GimpColorArray = *mut *mut gegl::GeglColor;
pub type GimpCoreObjectArray = *mut *mut gobject::GObject;

// Enums
pub type GimpAddMaskType = c_int;
pub const GIMP_ADD_MASK_WHITE: GimpAddMaskType = 0;
pub const GIMP_ADD_MASK_BLACK: GimpAddMaskType = 1;
pub const GIMP_ADD_MASK_ALPHA: GimpAddMaskType = 2;
pub const GIMP_ADD_MASK_ALPHA_TRANSFER: GimpAddMaskType = 3;
pub const GIMP_ADD_MASK_SELECTION: GimpAddMaskType = 4;
pub const GIMP_ADD_MASK_COPY: GimpAddMaskType = 5;
pub const GIMP_ADD_MASK_CHANNEL: GimpAddMaskType = 6;

pub type GimpArgumentSync = c_int;
pub const GIMP_ARGUMENT_SYNC_NONE: GimpArgumentSync = 0;
pub const GIMP_ARGUMENT_SYNC_PARASITE: GimpArgumentSync = 1;

pub type GimpBrushApplicationMode = c_int;
pub const GIMP_BRUSH_HARD: GimpBrushApplicationMode = 0;
pub const GIMP_BRUSH_SOFT: GimpBrushApplicationMode = 1;

pub type GimpBrushGeneratedShape = c_int;
pub const GIMP_BRUSH_GENERATED_CIRCLE: GimpBrushGeneratedShape = 0;
pub const GIMP_BRUSH_GENERATED_SQUARE: GimpBrushGeneratedShape = 1;
pub const GIMP_BRUSH_GENERATED_DIAMOND: GimpBrushGeneratedShape = 2;

pub type GimpCapStyle = c_int;
pub const GIMP_CAP_BUTT: GimpCapStyle = 0;
pub const GIMP_CAP_ROUND: GimpCapStyle = 1;
pub const GIMP_CAP_SQUARE: GimpCapStyle = 2;

pub type GimpChannelOps = c_int;
pub const GIMP_CHANNEL_OP_ADD: GimpChannelOps = 0;
pub const GIMP_CHANNEL_OP_SUBTRACT: GimpChannelOps = 1;
pub const GIMP_CHANNEL_OP_REPLACE: GimpChannelOps = 2;
pub const GIMP_CHANNEL_OP_INTERSECT: GimpChannelOps = 3;

pub type GimpChannelType = c_int;
pub const GIMP_CHANNEL_RED: GimpChannelType = 0;
pub const GIMP_CHANNEL_GREEN: GimpChannelType = 1;
pub const GIMP_CHANNEL_BLUE: GimpChannelType = 2;
pub const GIMP_CHANNEL_GRAY: GimpChannelType = 3;
pub const GIMP_CHANNEL_INDEXED: GimpChannelType = 4;
pub const GIMP_CHANNEL_ALPHA: GimpChannelType = 5;

pub type GimpCheckSize = c_int;
pub const GIMP_CHECK_SIZE_SMALL_CHECKS: GimpCheckSize = 0;
pub const GIMP_CHECK_SIZE_MEDIUM_CHECKS: GimpCheckSize = 1;
pub const GIMP_CHECK_SIZE_LARGE_CHECKS: GimpCheckSize = 2;

pub type GimpCheckType = c_int;
pub const GIMP_CHECK_TYPE_LIGHT_CHECKS: GimpCheckType = 0;
pub const GIMP_CHECK_TYPE_GRAY_CHECKS: GimpCheckType = 1;
pub const GIMP_CHECK_TYPE_DARK_CHECKS: GimpCheckType = 2;
pub const GIMP_CHECK_TYPE_WHITE_ONLY: GimpCheckType = 3;
pub const GIMP_CHECK_TYPE_GRAY_ONLY: GimpCheckType = 4;
pub const GIMP_CHECK_TYPE_BLACK_ONLY: GimpCheckType = 5;
pub const GIMP_CHECK_TYPE_CUSTOM_CHECKS: GimpCheckType = 6;

pub type GimpCloneType = c_int;
pub const GIMP_CLONE_IMAGE: GimpCloneType = 0;
pub const GIMP_CLONE_PATTERN: GimpCloneType = 1;

pub type GimpColorManagementMode = c_int;
pub const GIMP_COLOR_MANAGEMENT_OFF: GimpColorManagementMode = 0;
pub const GIMP_COLOR_MANAGEMENT_DISPLAY: GimpColorManagementMode = 1;
pub const GIMP_COLOR_MANAGEMENT_SOFTPROOF: GimpColorManagementMode = 2;

pub type GimpColorRenderingIntent = c_int;
pub const GIMP_COLOR_RENDERING_INTENT_PERCEPTUAL: GimpColorRenderingIntent = 0;
pub const GIMP_COLOR_RENDERING_INTENT_RELATIVE_COLORIMETRIC: GimpColorRenderingIntent = 1;
pub const GIMP_COLOR_RENDERING_INTENT_SATURATION: GimpColorRenderingIntent = 2;
pub const GIMP_COLOR_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC: GimpColorRenderingIntent = 3;

pub type GimpColorTag = c_int;
pub const GIMP_COLOR_TAG_NONE: GimpColorTag = 0;
pub const GIMP_COLOR_TAG_BLUE: GimpColorTag = 1;
pub const GIMP_COLOR_TAG_GREEN: GimpColorTag = 2;
pub const GIMP_COLOR_TAG_YELLOW: GimpColorTag = 3;
pub const GIMP_COLOR_TAG_ORANGE: GimpColorTag = 4;
pub const GIMP_COLOR_TAG_BROWN: GimpColorTag = 5;
pub const GIMP_COLOR_TAG_RED: GimpColorTag = 6;
pub const GIMP_COLOR_TAG_VIOLET: GimpColorTag = 7;
pub const GIMP_COLOR_TAG_GRAY: GimpColorTag = 8;

pub type GimpColorTransformFlags = c_int;
pub const GIMP_COLOR_TRANSFORM_FLAGS_NOOPTIMIZE: GimpColorTransformFlags = 256;
pub const GIMP_COLOR_TRANSFORM_FLAGS_GAMUT_CHECK: GimpColorTransformFlags = 4096;
pub const GIMP_COLOR_TRANSFORM_FLAGS_BLACK_POINT_COMPENSATION: GimpColorTransformFlags = 8192;

pub type GimpComponentType = c_int;
pub const GIMP_COMPONENT_TYPE_U8: GimpComponentType = 100;
pub const GIMP_COMPONENT_TYPE_U16: GimpComponentType = 200;
pub const GIMP_COMPONENT_TYPE_U32: GimpComponentType = 300;
pub const GIMP_COMPONENT_TYPE_HALF: GimpComponentType = 500;
pub const GIMP_COMPONENT_TYPE_FLOAT: GimpComponentType = 600;
pub const GIMP_COMPONENT_TYPE_DOUBLE: GimpComponentType = 700;

pub type GimpConfigError = c_int;
pub const GIMP_CONFIG_ERROR_OPEN: GimpConfigError = 0;
pub const GIMP_CONFIG_ERROR_OPEN_ENOENT: GimpConfigError = 1;
pub const GIMP_CONFIG_ERROR_WRITE: GimpConfigError = 2;
pub const GIMP_CONFIG_ERROR_PARSE: GimpConfigError = 3;
pub const GIMP_CONFIG_ERROR_VERSION: GimpConfigError = 4;

pub type GimpConfigPathType = c_int;
pub const GIMP_CONFIG_PATH_FILE: GimpConfigPathType = 0;
pub const GIMP_CONFIG_PATH_FILE_LIST: GimpConfigPathType = 1;
pub const GIMP_CONFIG_PATH_DIR: GimpConfigPathType = 2;
pub const GIMP_CONFIG_PATH_DIR_LIST: GimpConfigPathType = 3;

pub type GimpConvertDitherType = c_int;
pub const GIMP_CONVERT_DITHER_NONE: GimpConvertDitherType = 0;
pub const GIMP_CONVERT_DITHER_FS: GimpConvertDitherType = 1;
pub const GIMP_CONVERT_DITHER_FS_LOWBLEED: GimpConvertDitherType = 2;
pub const GIMP_CONVERT_DITHER_FIXED: GimpConvertDitherType = 3;

pub type GimpConvertPaletteType = c_int;
pub const GIMP_CONVERT_PALETTE_GENERATE: GimpConvertPaletteType = 0;
pub const GIMP_CONVERT_PALETTE_WEB: GimpConvertPaletteType = 1;
pub const GIMP_CONVERT_PALETTE_MONO: GimpConvertPaletteType = 2;
pub const GIMP_CONVERT_PALETTE_CUSTOM: GimpConvertPaletteType = 3;

pub type GimpConvolveType = c_int;
pub const GIMP_CONVOLVE_BLUR: GimpConvolveType = 0;
pub const GIMP_CONVOLVE_SHARPEN: GimpConvolveType = 1;

pub type GimpDesaturateMode = c_int;
pub const GIMP_DESATURATE_LIGHTNESS: GimpDesaturateMode = 0;
pub const GIMP_DESATURATE_LUMA: GimpDesaturateMode = 1;
pub const GIMP_DESATURATE_AVERAGE: GimpDesaturateMode = 2;
pub const GIMP_DESATURATE_LUMINANCE: GimpDesaturateMode = 3;
pub const GIMP_DESATURATE_VALUE: GimpDesaturateMode = 4;

pub type GimpDodgeBurnType = c_int;
pub const GIMP_DODGE_BURN_TYPE_DODGE: GimpDodgeBurnType = 0;
pub const GIMP_DODGE_BURN_TYPE_BURN: GimpDodgeBurnType = 1;

pub type GimpExportReturn = c_int;
pub const GIMP_EXPORT_IGNORE: GimpExportReturn = 0;
pub const GIMP_EXPORT_EXPORT: GimpExportReturn = 1;

pub type GimpFillType = c_int;
pub const GIMP_FILL_FOREGROUND: GimpFillType = 0;
pub const GIMP_FILL_BACKGROUND: GimpFillType = 1;
pub const GIMP_FILL_CIELAB_MIDDLE_GRAY: GimpFillType = 2;
pub const GIMP_FILL_WHITE: GimpFillType = 3;
pub const GIMP_FILL_TRANSPARENT: GimpFillType = 4;
pub const GIMP_FILL_PATTERN: GimpFillType = 5;

pub type GimpForegroundExtractMode = c_int;
pub const GIMP_FOREGROUND_EXTRACT_MATTING: GimpForegroundExtractMode = 0;

pub type GimpGradientBlendColorSpace = c_int;
pub const GIMP_GRADIENT_BLEND_RGB_PERCEPTUAL: GimpGradientBlendColorSpace = 0;
pub const GIMP_GRADIENT_BLEND_RGB_LINEAR: GimpGradientBlendColorSpace = 1;
pub const GIMP_GRADIENT_BLEND_CIE_LAB: GimpGradientBlendColorSpace = 2;

pub type GimpGradientSegmentColor = c_int;
pub const GIMP_GRADIENT_SEGMENT_RGB: GimpGradientSegmentColor = 0;
pub const GIMP_GRADIENT_SEGMENT_HSV_CCW: GimpGradientSegmentColor = 1;
pub const GIMP_GRADIENT_SEGMENT_HSV_CW: GimpGradientSegmentColor = 2;

pub type GimpGradientSegmentType = c_int;
pub const GIMP_GRADIENT_SEGMENT_LINEAR: GimpGradientSegmentType = 0;
pub const GIMP_GRADIENT_SEGMENT_CURVED: GimpGradientSegmentType = 1;
pub const GIMP_GRADIENT_SEGMENT_SINE: GimpGradientSegmentType = 2;
pub const GIMP_GRADIENT_SEGMENT_SPHERE_INCREASING: GimpGradientSegmentType = 3;
pub const GIMP_GRADIENT_SEGMENT_SPHERE_DECREASING: GimpGradientSegmentType = 4;
pub const GIMP_GRADIENT_SEGMENT_STEP: GimpGradientSegmentType = 5;

pub type GimpGradientType = c_int;
pub const GIMP_GRADIENT_LINEAR: GimpGradientType = 0;
pub const GIMP_GRADIENT_BILINEAR: GimpGradientType = 1;
pub const GIMP_GRADIENT_RADIAL: GimpGradientType = 2;
pub const GIMP_GRADIENT_SQUARE: GimpGradientType = 3;
pub const GIMP_GRADIENT_CONICAL_SYMMETRIC: GimpGradientType = 4;
pub const GIMP_GRADIENT_CONICAL_ASYMMETRIC: GimpGradientType = 5;
pub const GIMP_GRADIENT_SHAPEBURST_ANGULAR: GimpGradientType = 6;
pub const GIMP_GRADIENT_SHAPEBURST_SPHERICAL: GimpGradientType = 7;
pub const GIMP_GRADIENT_SHAPEBURST_DIMPLED: GimpGradientType = 8;
pub const GIMP_GRADIENT_SPIRAL_CLOCKWISE: GimpGradientType = 9;
pub const GIMP_GRADIENT_SPIRAL_ANTICLOCKWISE: GimpGradientType = 10;

pub type GimpGridStyle = c_int;
pub const GIMP_GRID_DOTS: GimpGridStyle = 0;
pub const GIMP_GRID_INTERSECTIONS: GimpGridStyle = 1;
pub const GIMP_GRID_ON_OFF_DASH: GimpGridStyle = 2;
pub const GIMP_GRID_DOUBLE_DASH: GimpGridStyle = 3;
pub const GIMP_GRID_SOLID: GimpGridStyle = 4;

pub type GimpHistogramChannel = c_int;
pub const GIMP_HISTOGRAM_VALUE: GimpHistogramChannel = 0;
pub const GIMP_HISTOGRAM_RED: GimpHistogramChannel = 1;
pub const GIMP_HISTOGRAM_GREEN: GimpHistogramChannel = 2;
pub const GIMP_HISTOGRAM_BLUE: GimpHistogramChannel = 3;
pub const GIMP_HISTOGRAM_ALPHA: GimpHistogramChannel = 4;
pub const GIMP_HISTOGRAM_LUMINANCE: GimpHistogramChannel = 5;

pub type GimpHueRange = c_int;
pub const GIMP_HUE_RANGE_ALL: GimpHueRange = 0;
pub const GIMP_HUE_RANGE_RED: GimpHueRange = 1;
pub const GIMP_HUE_RANGE_YELLOW: GimpHueRange = 2;
pub const GIMP_HUE_RANGE_GREEN: GimpHueRange = 3;
pub const GIMP_HUE_RANGE_CYAN: GimpHueRange = 4;
pub const GIMP_HUE_RANGE_BLUE: GimpHueRange = 5;
pub const GIMP_HUE_RANGE_MAGENTA: GimpHueRange = 6;

pub type GimpIconType = c_int;
pub const GIMP_ICON_TYPE_ICON_NAME: GimpIconType = 0;
pub const GIMP_ICON_TYPE_PIXBUF: GimpIconType = 1;
pub const GIMP_ICON_TYPE_IMAGE_FILE: GimpIconType = 2;

pub type GimpImageBaseType = c_int;
pub const GIMP_RGB: GimpImageBaseType = 0;
pub const GIMP_GRAY: GimpImageBaseType = 1;
pub const GIMP_INDEXED: GimpImageBaseType = 2;

pub type GimpImageType = c_int;
pub const GIMP_RGB_IMAGE: GimpImageType = 0;
pub const GIMP_RGBA_IMAGE: GimpImageType = 1;
pub const GIMP_GRAY_IMAGE: GimpImageType = 2;
pub const GIMP_GRAYA_IMAGE: GimpImageType = 3;
pub const GIMP_INDEXED_IMAGE: GimpImageType = 4;
pub const GIMP_INDEXEDA_IMAGE: GimpImageType = 5;

pub type GimpInkBlobType = c_int;
pub const GIMP_INK_BLOB_TYPE_CIRCLE: GimpInkBlobType = 0;
pub const GIMP_INK_BLOB_TYPE_SQUARE: GimpInkBlobType = 1;
pub const GIMP_INK_BLOB_TYPE_DIAMOND: GimpInkBlobType = 2;

pub type GimpInterpolationType = c_int;
pub const GIMP_INTERPOLATION_NONE: GimpInterpolationType = 0;
pub const GIMP_INTERPOLATION_LINEAR: GimpInterpolationType = 1;
pub const GIMP_INTERPOLATION_CUBIC: GimpInterpolationType = 2;
pub const GIMP_INTERPOLATION_NOHALO: GimpInterpolationType = 3;
pub const GIMP_INTERPOLATION_LOHALO: GimpInterpolationType = 4;

pub type GimpJoinStyle = c_int;
pub const GIMP_JOIN_MITER: GimpJoinStyle = 0;
pub const GIMP_JOIN_ROUND: GimpJoinStyle = 1;
pub const GIMP_JOIN_BEVEL: GimpJoinStyle = 2;

pub type GimpLayerColorSpace = c_int;
pub const GIMP_LAYER_COLOR_SPACE_AUTO: GimpLayerColorSpace = 0;
pub const GIMP_LAYER_COLOR_SPACE_RGB_LINEAR: GimpLayerColorSpace = 1;
pub const GIMP_LAYER_COLOR_SPACE_RGB_NON_LINEAR: GimpLayerColorSpace = 2;
pub const GIMP_LAYER_COLOR_SPACE_LAB: GimpLayerColorSpace = 3;
pub const GIMP_LAYER_COLOR_SPACE_RGB_PERCEPTUAL: GimpLayerColorSpace = 4;

pub type GimpLayerCompositeMode = c_int;
pub const GIMP_LAYER_COMPOSITE_AUTO: GimpLayerCompositeMode = 0;
pub const GIMP_LAYER_COMPOSITE_UNION: GimpLayerCompositeMode = 1;
pub const GIMP_LAYER_COMPOSITE_CLIP_TO_BACKDROP: GimpLayerCompositeMode = 2;
pub const GIMP_LAYER_COMPOSITE_CLIP_TO_LAYER: GimpLayerCompositeMode = 3;
pub const GIMP_LAYER_COMPOSITE_INTERSECTION: GimpLayerCompositeMode = 4;

pub type GimpLayerMode = c_int;
pub const GIMP_LAYER_MODE_NORMAL_LEGACY: GimpLayerMode = 0;
pub const GIMP_LAYER_MODE_DISSOLVE: GimpLayerMode = 1;
pub const GIMP_LAYER_MODE_BEHIND_LEGACY: GimpLayerMode = 2;
pub const GIMP_LAYER_MODE_MULTIPLY_LEGACY: GimpLayerMode = 3;
pub const GIMP_LAYER_MODE_SCREEN_LEGACY: GimpLayerMode = 4;
pub const GIMP_LAYER_MODE_OVERLAY_LEGACY: GimpLayerMode = 5;
pub const GIMP_LAYER_MODE_DIFFERENCE_LEGACY: GimpLayerMode = 6;
pub const GIMP_LAYER_MODE_ADDITION_LEGACY: GimpLayerMode = 7;
pub const GIMP_LAYER_MODE_SUBTRACT_LEGACY: GimpLayerMode = 8;
pub const GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY: GimpLayerMode = 9;
pub const GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY: GimpLayerMode = 10;
pub const GIMP_LAYER_MODE_HSV_HUE_LEGACY: GimpLayerMode = 11;
pub const GIMP_LAYER_MODE_HSV_SATURATION_LEGACY: GimpLayerMode = 12;
pub const GIMP_LAYER_MODE_HSL_COLOR_LEGACY: GimpLayerMode = 13;
pub const GIMP_LAYER_MODE_HSV_VALUE_LEGACY: GimpLayerMode = 14;
pub const GIMP_LAYER_MODE_DIVIDE_LEGACY: GimpLayerMode = 15;
pub const GIMP_LAYER_MODE_DODGE_LEGACY: GimpLayerMode = 16;
pub const GIMP_LAYER_MODE_BURN_LEGACY: GimpLayerMode = 17;
pub const GIMP_LAYER_MODE_HARDLIGHT_LEGACY: GimpLayerMode = 18;
pub const GIMP_LAYER_MODE_SOFTLIGHT_LEGACY: GimpLayerMode = 19;
pub const GIMP_LAYER_MODE_GRAIN_EXTRACT_LEGACY: GimpLayerMode = 20;
pub const GIMP_LAYER_MODE_GRAIN_MERGE_LEGACY: GimpLayerMode = 21;
pub const GIMP_LAYER_MODE_COLOR_ERASE_LEGACY: GimpLayerMode = 22;
pub const GIMP_LAYER_MODE_OVERLAY: GimpLayerMode = 23;
pub const GIMP_LAYER_MODE_LCH_HUE: GimpLayerMode = 24;
pub const GIMP_LAYER_MODE_LCH_CHROMA: GimpLayerMode = 25;
pub const GIMP_LAYER_MODE_LCH_COLOR: GimpLayerMode = 26;
pub const GIMP_LAYER_MODE_LCH_LIGHTNESS: GimpLayerMode = 27;
pub const GIMP_LAYER_MODE_NORMAL: GimpLayerMode = 28;
pub const GIMP_LAYER_MODE_BEHIND: GimpLayerMode = 29;
pub const GIMP_LAYER_MODE_MULTIPLY: GimpLayerMode = 30;
pub const GIMP_LAYER_MODE_SCREEN: GimpLayerMode = 31;
pub const GIMP_LAYER_MODE_DIFFERENCE: GimpLayerMode = 32;
pub const GIMP_LAYER_MODE_ADDITION: GimpLayerMode = 33;
pub const GIMP_LAYER_MODE_SUBTRACT: GimpLayerMode = 34;
pub const GIMP_LAYER_MODE_DARKEN_ONLY: GimpLayerMode = 35;
pub const GIMP_LAYER_MODE_LIGHTEN_ONLY: GimpLayerMode = 36;
pub const GIMP_LAYER_MODE_HSV_HUE: GimpLayerMode = 37;
pub const GIMP_LAYER_MODE_HSV_SATURATION: GimpLayerMode = 38;
pub const GIMP_LAYER_MODE_HSL_COLOR: GimpLayerMode = 39;
pub const GIMP_LAYER_MODE_HSV_VALUE: GimpLayerMode = 40;
pub const GIMP_LAYER_MODE_DIVIDE: GimpLayerMode = 41;
pub const GIMP_LAYER_MODE_DODGE: GimpLayerMode = 42;
pub const GIMP_LAYER_MODE_BURN: GimpLayerMode = 43;
pub const GIMP_LAYER_MODE_HARDLIGHT: GimpLayerMode = 44;
pub const GIMP_LAYER_MODE_SOFTLIGHT: GimpLayerMode = 45;
pub const GIMP_LAYER_MODE_GRAIN_EXTRACT: GimpLayerMode = 46;
pub const GIMP_LAYER_MODE_GRAIN_MERGE: GimpLayerMode = 47;
pub const GIMP_LAYER_MODE_VIVID_LIGHT: GimpLayerMode = 48;
pub const GIMP_LAYER_MODE_PIN_LIGHT: GimpLayerMode = 49;
pub const GIMP_LAYER_MODE_LINEAR_LIGHT: GimpLayerMode = 50;
pub const GIMP_LAYER_MODE_HARD_MIX: GimpLayerMode = 51;
pub const GIMP_LAYER_MODE_EXCLUSION: GimpLayerMode = 52;
pub const GIMP_LAYER_MODE_LINEAR_BURN: GimpLayerMode = 53;
pub const GIMP_LAYER_MODE_LUMA_DARKEN_ONLY: GimpLayerMode = 54;
pub const GIMP_LAYER_MODE_LUMA_LIGHTEN_ONLY: GimpLayerMode = 55;
pub const GIMP_LAYER_MODE_LUMINANCE: GimpLayerMode = 56;
pub const GIMP_LAYER_MODE_COLOR_ERASE: GimpLayerMode = 57;
pub const GIMP_LAYER_MODE_ERASE: GimpLayerMode = 58;
pub const GIMP_LAYER_MODE_MERGE: GimpLayerMode = 59;
pub const GIMP_LAYER_MODE_SPLIT: GimpLayerMode = 60;
pub const GIMP_LAYER_MODE_PASS_THROUGH: GimpLayerMode = 61;
pub const GIMP_LAYER_MODE_REPLACE: GimpLayerMode = 62;

pub type GimpMaskApplyMode = c_int;
pub const GIMP_MASK_APPLY: GimpMaskApplyMode = 0;
pub const GIMP_MASK_DISCARD: GimpMaskApplyMode = 1;

pub type GimpMergeType = c_int;
pub const GIMP_EXPAND_AS_NECESSARY: GimpMergeType = 0;
pub const GIMP_CLIP_TO_IMAGE: GimpMergeType = 1;
pub const GIMP_CLIP_TO_BOTTOM_LAYER: GimpMergeType = 2;
pub const GIMP_FLATTEN_IMAGE: GimpMergeType = 3;

pub type GimpMessageHandlerType = c_int;
pub const GIMP_MESSAGE_BOX: GimpMessageHandlerType = 0;
pub const GIMP_CONSOLE: GimpMessageHandlerType = 1;
pub const GIMP_ERROR_CONSOLE: GimpMessageHandlerType = 2;

pub type GimpMetadataColorspace = c_int;
pub const GIMP_METADATA_COLORSPACE_UNSPECIFIED: GimpMetadataColorspace = 0;
pub const GIMP_METADATA_COLORSPACE_UNCALIBRATED: GimpMetadataColorspace = 1;
pub const GIMP_METADATA_COLORSPACE_SRGB: GimpMetadataColorspace = 2;
pub const GIMP_METADATA_COLORSPACE_ADOBERGB: GimpMetadataColorspace = 3;

pub type GimpModuleError = c_int;
pub const GIMP_MODULE_FAILED: GimpModuleError = 0;

pub type GimpModuleState = c_int;
pub const GIMP_MODULE_STATE_ERROR: GimpModuleState = 0;
pub const GIMP_MODULE_STATE_LOADED: GimpModuleState = 1;
pub const GIMP_MODULE_STATE_LOAD_FAILED: GimpModuleState = 2;
pub const GIMP_MODULE_STATE_NOT_LOADED: GimpModuleState = 3;

pub type GimpOffsetType = c_int;
pub const GIMP_OFFSET_COLOR: GimpOffsetType = 0;
pub const GIMP_OFFSET_TRANSPARENT: GimpOffsetType = 1;
pub const GIMP_OFFSET_WRAP_AROUND: GimpOffsetType = 2;

pub type GimpOrientationType = c_int;
pub const GIMP_ORIENTATION_HORIZONTAL: GimpOrientationType = 0;
pub const GIMP_ORIENTATION_VERTICAL: GimpOrientationType = 1;
pub const GIMP_ORIENTATION_UNKNOWN: GimpOrientationType = 2;

pub type GimpPDBErrorHandler = c_int;
pub const GIMP_PDB_ERROR_HANDLER_INTERNAL: GimpPDBErrorHandler = 0;
pub const GIMP_PDB_ERROR_HANDLER_PLUGIN: GimpPDBErrorHandler = 1;

pub type GimpPDBProcType = c_int;
pub const GIMP_PDB_PROC_TYPE_INTERNAL: GimpPDBProcType = 0;
pub const GIMP_PDB_PROC_TYPE_PLUGIN: GimpPDBProcType = 1;
pub const GIMP_PDB_PROC_TYPE_PERSISTENT: GimpPDBProcType = 2;
pub const GIMP_PDB_PROC_TYPE_TEMPORARY: GimpPDBProcType = 3;

pub type GimpPDBStatusType = c_int;
pub const GIMP_PDB_EXECUTION_ERROR: GimpPDBStatusType = 0;
pub const GIMP_PDB_CALLING_ERROR: GimpPDBStatusType = 1;
pub const GIMP_PDB_PASS_THROUGH: GimpPDBStatusType = 2;
pub const GIMP_PDB_SUCCESS: GimpPDBStatusType = 3;
pub const GIMP_PDB_CANCEL: GimpPDBStatusType = 4;

pub type GimpPaintApplicationMode = c_int;
pub const GIMP_PAINT_CONSTANT: GimpPaintApplicationMode = 0;
pub const GIMP_PAINT_INCREMENTAL: GimpPaintApplicationMode = 1;

pub type GimpPathStrokeType = c_int;
pub const GIMP_PATH_STROKE_TYPE_BEZIER: GimpPathStrokeType = 0;

pub type GimpPixbufTransparency = c_int;
pub const GIMP_PIXBUF_KEEP_ALPHA: GimpPixbufTransparency = 0;
pub const GIMP_PIXBUF_SMALL_CHECKS: GimpPixbufTransparency = 1;
pub const GIMP_PIXBUF_LARGE_CHECKS: GimpPixbufTransparency = 2;

pub type GimpPrecision = c_int;
pub const GIMP_PRECISION_U8_LINEAR: GimpPrecision = 100;
pub const GIMP_PRECISION_U8_NON_LINEAR: GimpPrecision = 150;
pub const GIMP_PRECISION_U8_PERCEPTUAL: GimpPrecision = 175;
pub const GIMP_PRECISION_U16_LINEAR: GimpPrecision = 200;
pub const GIMP_PRECISION_U16_NON_LINEAR: GimpPrecision = 250;
pub const GIMP_PRECISION_U16_PERCEPTUAL: GimpPrecision = 275;
pub const GIMP_PRECISION_U32_LINEAR: GimpPrecision = 300;
pub const GIMP_PRECISION_U32_NON_LINEAR: GimpPrecision = 350;
pub const GIMP_PRECISION_U32_PERCEPTUAL: GimpPrecision = 375;
pub const GIMP_PRECISION_HALF_LINEAR: GimpPrecision = 500;
pub const GIMP_PRECISION_HALF_NON_LINEAR: GimpPrecision = 550;
pub const GIMP_PRECISION_HALF_PERCEPTUAL: GimpPrecision = 575;
pub const GIMP_PRECISION_FLOAT_LINEAR: GimpPrecision = 600;
pub const GIMP_PRECISION_FLOAT_NON_LINEAR: GimpPrecision = 650;
pub const GIMP_PRECISION_FLOAT_PERCEPTUAL: GimpPrecision = 675;
pub const GIMP_PRECISION_DOUBLE_LINEAR: GimpPrecision = 700;
pub const GIMP_PRECISION_DOUBLE_NON_LINEAR: GimpPrecision = 750;
pub const GIMP_PRECISION_DOUBLE_PERCEPTUAL: GimpPrecision = 775;

pub type GimpProgressCommand = c_int;
pub const GIMP_PROGRESS_COMMAND_START: GimpProgressCommand = 0;
pub const GIMP_PROGRESS_COMMAND_END: GimpProgressCommand = 1;
pub const GIMP_PROGRESS_COMMAND_SET_TEXT: GimpProgressCommand = 2;
pub const GIMP_PROGRESS_COMMAND_SET_VALUE: GimpProgressCommand = 3;
pub const GIMP_PROGRESS_COMMAND_PULSE: GimpProgressCommand = 4;
pub const GIMP_PROGRESS_COMMAND_GET_WINDOW: GimpProgressCommand = 5;

pub type GimpRepeatMode = c_int;
pub const GIMP_REPEAT_NONE: GimpRepeatMode = 0;
pub const GIMP_REPEAT_TRUNCATE: GimpRepeatMode = 1;
pub const GIMP_REPEAT_SAWTOOTH: GimpRepeatMode = 2;
pub const GIMP_REPEAT_TRIANGULAR: GimpRepeatMode = 3;

pub type GimpRotationType = c_int;
pub const GIMP_ROTATE_DEGREES90: GimpRotationType = 0;
pub const GIMP_ROTATE_DEGREES180: GimpRotationType = 1;
pub const GIMP_ROTATE_DEGREES270: GimpRotationType = 2;

pub type GimpRunMode = c_int;
pub const GIMP_RUN_INTERACTIVE: GimpRunMode = 0;
pub const GIMP_RUN_NONINTERACTIVE: GimpRunMode = 1;
pub const GIMP_RUN_WITH_LAST_VALS: GimpRunMode = 2;

pub type GimpSelectCriterion = c_int;
pub const GIMP_SELECT_CRITERION_COMPOSITE: GimpSelectCriterion = 0;
pub const GIMP_SELECT_CRITERION_RGB_RED: GimpSelectCriterion = 1;
pub const GIMP_SELECT_CRITERION_RGB_GREEN: GimpSelectCriterion = 2;
pub const GIMP_SELECT_CRITERION_RGB_BLUE: GimpSelectCriterion = 3;
pub const GIMP_SELECT_CRITERION_HSV_HUE: GimpSelectCriterion = 4;
pub const GIMP_SELECT_CRITERION_HSV_SATURATION: GimpSelectCriterion = 5;
pub const GIMP_SELECT_CRITERION_HSV_VALUE: GimpSelectCriterion = 6;
pub const GIMP_SELECT_CRITERION_LCH_LIGHTNESS: GimpSelectCriterion = 7;
pub const GIMP_SELECT_CRITERION_LCH_CHROMA: GimpSelectCriterion = 8;
pub const GIMP_SELECT_CRITERION_LCH_HUE: GimpSelectCriterion = 9;
pub const GIMP_SELECT_CRITERION_ALPHA: GimpSelectCriterion = 10;

pub type GimpSizeType = c_int;
pub const GIMP_PIXELS: GimpSizeType = 0;
pub const GIMP_POINTS: GimpSizeType = 1;

pub type GimpStackTraceMode = c_int;
pub const GIMP_STACK_TRACE_NEVER: GimpStackTraceMode = 0;
pub const GIMP_STACK_TRACE_QUERY: GimpStackTraceMode = 1;
pub const GIMP_STACK_TRACE_ALWAYS: GimpStackTraceMode = 2;

pub type GimpStrokeMethod = c_int;
pub const GIMP_STROKE_LINE: GimpStrokeMethod = 0;
pub const GIMP_STROKE_PAINT_METHOD: GimpStrokeMethod = 1;

pub type GimpTextDirection = c_int;
pub const GIMP_TEXT_DIRECTION_LTR: GimpTextDirection = 0;
pub const GIMP_TEXT_DIRECTION_RTL: GimpTextDirection = 1;
pub const GIMP_TEXT_DIRECTION_TTB_RTL: GimpTextDirection = 2;
pub const GIMP_TEXT_DIRECTION_TTB_RTL_UPRIGHT: GimpTextDirection = 3;
pub const GIMP_TEXT_DIRECTION_TTB_LTR: GimpTextDirection = 4;
pub const GIMP_TEXT_DIRECTION_TTB_LTR_UPRIGHT: GimpTextDirection = 5;

pub type GimpTextHintStyle = c_int;
pub const GIMP_TEXT_HINT_STYLE_NONE: GimpTextHintStyle = 0;
pub const GIMP_TEXT_HINT_STYLE_SLIGHT: GimpTextHintStyle = 1;
pub const GIMP_TEXT_HINT_STYLE_MEDIUM: GimpTextHintStyle = 2;
pub const GIMP_TEXT_HINT_STYLE_FULL: GimpTextHintStyle = 3;

pub type GimpTextJustification = c_int;
pub const GIMP_TEXT_JUSTIFY_LEFT: GimpTextJustification = 0;
pub const GIMP_TEXT_JUSTIFY_RIGHT: GimpTextJustification = 1;
pub const GIMP_TEXT_JUSTIFY_CENTER: GimpTextJustification = 2;
pub const GIMP_TEXT_JUSTIFY_FILL: GimpTextJustification = 3;

pub type GimpTransferMode = c_int;
pub const GIMP_TRANSFER_SHADOWS: GimpTransferMode = 0;
pub const GIMP_TRANSFER_MIDTONES: GimpTransferMode = 1;
pub const GIMP_TRANSFER_HIGHLIGHTS: GimpTransferMode = 2;

pub type GimpTransformDirection = c_int;
pub const GIMP_TRANSFORM_FORWARD: GimpTransformDirection = 0;
pub const GIMP_TRANSFORM_BACKWARD: GimpTransformDirection = 1;

pub type GimpTransformResize = c_int;
pub const GIMP_TRANSFORM_RESIZE_ADJUST: GimpTransformResize = 0;
pub const GIMP_TRANSFORM_RESIZE_CLIP: GimpTransformResize = 1;
pub const GIMP_TRANSFORM_RESIZE_CROP: GimpTransformResize = 2;
pub const GIMP_TRANSFORM_RESIZE_CROP_WITH_ASPECT: GimpTransformResize = 3;

pub type GimpUnitID = c_int;
pub const GIMP_UNIT_PIXEL: GimpUnitID = 0;
pub const GIMP_UNIT_INCH: GimpUnitID = 1;
pub const GIMP_UNIT_MM: GimpUnitID = 2;
pub const GIMP_UNIT_POINT: GimpUnitID = 3;
pub const GIMP_UNIT_PICA: GimpUnitID = 4;
pub const GIMP_UNIT_END: GimpUnitID = 5;
pub const GIMP_UNIT_PERCENT: GimpUnitID = 65536;

// Constants
pub const GIMP_API_VERSION: &[u8] = b"3.0\0";
pub const GIMP_CHECK_DARK: c_double = 0.400000;
pub const GIMP_CHECK_LIGHT: c_double = 0.600000;
pub const GIMP_CHECK_SIZE: c_int = 8;
pub const GIMP_CHECK_SIZE_SM: c_int = 4;
pub const GIMP_CONFIG_PARAM_AGGREGATE: c_int = 2;
pub const GIMP_CONFIG_PARAM_CONFIRM: c_int = 8;
pub const GIMP_CONFIG_PARAM_DEFAULTS: c_int = 16;
pub const GIMP_CONFIG_PARAM_DONT_COMPARE: c_int = 64;
pub const GIMP_CONFIG_PARAM_FLAGS: c_int = 7;
pub const GIMP_CONFIG_PARAM_FLAG_SHIFT: c_int = 7;
pub const GIMP_CONFIG_PARAM_IGNORE: c_int = 32;
pub const GIMP_CONFIG_PARAM_RESTART: c_int = 4;
pub const GIMP_CONFIG_PARAM_SERIALIZE: c_int = 1;
pub const GIMP_MAJOR_VERSION: c_int = 3;
pub const GIMP_MAX_IMAGE_SIZE: c_int = 524288;
pub const GIMP_MAX_RESOLUTION: c_double = 1048576.000000;
pub const GIMP_MICRO_VERSION: c_int = 0;
pub const GIMP_MINOR_VERSION: c_int = 0;
pub const GIMP_MIN_IMAGE_SIZE: c_int = 1;
pub const GIMP_MIN_RESOLUTION: c_double = 0.005000;
pub const GIMP_MODULE_ABI_VERSION: c_int = 5;
pub const GIMP_PARAM_DONT_SERIALIZE: c_int = 2;
pub const GIMP_PARAM_FLAG_SHIFT: c_int = 2;
pub const GIMP_PARAM_NO_VALIDATE: c_int = 1;
pub const GIMP_PARAM_READABLE: c_int = 1;
pub const GIMP_PARAM_READWRITE: c_int = 3;
pub const GIMP_PARAM_STATIC_STRINGS: c_int = 224;
pub const GIMP_PARAM_WRITABLE: c_int = 2;
pub const GIMP_PARASITE_ATTACH_GRANDPARENT: c_int = 8388608;
pub const GIMP_PARASITE_ATTACH_PARENT: c_int = 32768;
pub const GIMP_PARASITE_GRANDPARENT_PERSISTENT: c_int = 0;
pub const GIMP_PARASITE_GRANDPARENT_UNDOABLE: c_int = 0;
pub const GIMP_PARASITE_PARENT_PERSISTENT: c_int = 0;
pub const GIMP_PARASITE_PARENT_UNDOABLE: c_int = 0;
pub const GIMP_PARASITE_PERSISTENT: c_int = 1;
pub const GIMP_PARASITE_UNDOABLE: c_int = 2;
pub const GIMP_PIXPIPE_MAXDIM: c_int = 4;
pub const GIMP_VERSION: &[u8] = b"3.0.0-RC2\0";

// Flags
pub type GimpExportCapabilities = c_uint;
pub const GIMP_EXPORT_CAN_HANDLE_RGB: GimpExportCapabilities = 1;
pub const GIMP_EXPORT_CAN_HANDLE_GRAY: GimpExportCapabilities = 2;
pub const GIMP_EXPORT_CAN_HANDLE_INDEXED: GimpExportCapabilities = 4;
pub const GIMP_EXPORT_CAN_HANDLE_BITMAP: GimpExportCapabilities = 8;
pub const GIMP_EXPORT_CAN_HANDLE_ALPHA: GimpExportCapabilities = 16;
pub const GIMP_EXPORT_CAN_HANDLE_LAYERS: GimpExportCapabilities = 32;
pub const GIMP_EXPORT_CAN_HANDLE_LAYERS_AS_ANIMATION: GimpExportCapabilities = 64;
pub const GIMP_EXPORT_CAN_HANDLE_LAYER_MASKS: GimpExportCapabilities = 128;
pub const GIMP_EXPORT_CAN_HANDLE_LAYER_EFFECTS: GimpExportCapabilities = 256;
pub const GIMP_EXPORT_NEEDS_ALPHA: GimpExportCapabilities = 512;
pub const GIMP_EXPORT_NEEDS_CROP: GimpExportCapabilities = 1024;

pub type GimpMetadataLoadFlags = c_uint;
pub const GIMP_METADATA_LOAD_NONE: GimpMetadataLoadFlags = 0;
pub const GIMP_METADATA_LOAD_COMMENT: GimpMetadataLoadFlags = 1;
pub const GIMP_METADATA_LOAD_RESOLUTION: GimpMetadataLoadFlags = 2;
pub const GIMP_METADATA_LOAD_ORIENTATION: GimpMetadataLoadFlags = 4;
pub const GIMP_METADATA_LOAD_COLORSPACE: GimpMetadataLoadFlags = 8;
pub const GIMP_METADATA_LOAD_ALL: GimpMetadataLoadFlags = 4294967295;

pub type GimpMetadataSaveFlags = c_uint;
pub const GIMP_METADATA_SAVE_EXIF: GimpMetadataSaveFlags = 1;
pub const GIMP_METADATA_SAVE_XMP: GimpMetadataSaveFlags = 2;
pub const GIMP_METADATA_SAVE_IPTC: GimpMetadataSaveFlags = 4;
pub const GIMP_METADATA_SAVE_THUMBNAIL: GimpMetadataSaveFlags = 8;
pub const GIMP_METADATA_SAVE_COLOR_PROFILE: GimpMetadataSaveFlags = 16;
pub const GIMP_METADATA_SAVE_COMMENT: GimpMetadataSaveFlags = 32;
pub const GIMP_METADATA_SAVE_ALL: GimpMetadataSaveFlags = 4294967295;

pub type GimpProcedureSensitivityMask = c_uint;
pub const GIMP_PROCEDURE_SENSITIVE_DRAWABLE: GimpProcedureSensitivityMask = 1;
pub const GIMP_PROCEDURE_SENSITIVE_DRAWABLES: GimpProcedureSensitivityMask = 4;
pub const GIMP_PROCEDURE_SENSITIVE_NO_DRAWABLES: GimpProcedureSensitivityMask = 8;
pub const GIMP_PROCEDURE_SENSITIVE_NO_IMAGE: GimpProcedureSensitivityMask = 16;
pub const GIMP_PROCEDURE_SENSITIVE_ALWAYS: GimpProcedureSensitivityMask = 2147483647;

// Callbacks
pub type GimpBatchFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, GimpRunMode, *const c_char, *mut GimpProcedureConfig, gpointer) -> *mut GimpValueArray>;
pub type GimpExportGetCapabilitiesFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, *mut GimpProcedureConfig, *mut GimpExportOptions, gpointer) -> GimpExportCapabilities>;
pub type GimpExtractVectorFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, GimpRunMode, *mut gio::GFile, *mut GimpMetadata, *mut GimpProcedureConfig, *mut GimpVectorLoadData, *mut gpointer, *mut glib::GDestroyNotify, gpointer, *mut *mut glib::GError) -> gboolean>;
pub type GimpModuleQueryFunc = Option<unsafe extern "C" fn(*mut gobject::GTypeModule) -> *const GimpModuleInfo>;
pub type GimpModuleRegisterFunc = Option<unsafe extern "C" fn(*mut gobject::GTypeModule) -> gboolean>;
pub type GimpProgressFunc = Option<unsafe extern "C" fn(c_int, c_int, c_int, gpointer)>;
pub type GimpProgressVtableEndFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GimpProgressVtableGetWindowFunc = Option<unsafe extern "C" fn(gpointer) -> *mut glib::GBytes>;
pub type GimpProgressVtablePulseFunc = Option<unsafe extern "C" fn(gpointer)>;
pub type GimpProgressVtableSetTextFunc = Option<unsafe extern "C" fn(*const c_char, gpointer)>;
pub type GimpProgressVtableSetValueFunc = Option<unsafe extern "C" fn(c_double, gpointer)>;
pub type GimpProgressVtableStartFunc = Option<unsafe extern "C" fn(*const c_char, gboolean, gpointer)>;
pub type GimpPutPixelFunc = Option<unsafe extern "C" fn(c_int, c_int, *mut c_double, gpointer)>;
pub type GimpRenderFunc = Option<unsafe extern "C" fn(c_double, c_double, *mut c_double, gpointer)>;
pub type GimpRunExportFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, GimpRunMode, *mut GimpImage, *mut gio::GFile, *mut GimpExportOptions, *mut GimpMetadata, *mut GimpProcedureConfig, gpointer) -> *mut GimpValueArray>;
pub type GimpRunFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, *mut GimpProcedureConfig, gpointer) -> *mut GimpValueArray>;
pub type GimpRunImageFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, GimpRunMode, *mut GimpImage, *mut *mut GimpDrawable, *mut GimpProcedureConfig, gpointer) -> *mut GimpValueArray>;
pub type GimpRunLoadFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, GimpRunMode, *mut gio::GFile, *mut GimpMetadata, *mut GimpMetadataLoadFlags, *mut GimpProcedureConfig, gpointer) -> *mut GimpValueArray>;
pub type GimpRunThumbnailFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, *mut gio::GFile, c_int, *mut GimpProcedureConfig, gpointer) -> *mut GimpValueArray>;
pub type GimpRunVectorLoadFunc = Option<unsafe extern "C" fn(*mut GimpProcedure, GimpRunMode, *mut gio::GFile, c_int, c_int, GimpVectorLoadData, *mut GimpMetadata, *mut GimpMetadataLoadFlags, *mut GimpProcedureConfig, gpointer, gpointer) -> *mut GimpValueArray>;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpArray {
    pub data: *mut u8,
    pub length: size_t,
    pub static_data: gboolean,
}

impl ::std::fmt::Debug for GimpArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpArray @ {self:p}"))
         .field("data", &self.data)
         .field("length", &self.length)
         .field("static_data", &self.static_data)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpBatchProcedureClass {
    pub parent_class: GimpProcedureClass,
}

impl ::std::fmt::Debug for GimpBatchProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpBatchProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpBrushClass {
    pub parent_class: GimpResourceClass,
}

impl ::std::fmt::Debug for GimpBrushClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpBrushClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpChannelClass {
    pub parent_class: GimpDrawableClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpChannelClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpChannelClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpChoiceClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpChoiceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpChoiceClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpColorConfigClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpColorConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpColorConfigClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpColorManagedInterface {
    pub base_iface: gobject::GTypeInterface,
    pub get_icc_profile: Option<unsafe extern "C" fn(*mut GimpColorManaged, *mut size_t) -> *const u8>,
    pub profile_changed: Option<unsafe extern "C" fn(*mut GimpColorManaged)>,
    pub simulation_profile_changed: Option<unsafe extern "C" fn(*mut GimpColorManaged)>,
    pub simulation_intent_changed: Option<unsafe extern "C" fn(*mut GimpColorManaged)>,
    pub simulation_bpc_changed: Option<unsafe extern "C" fn(*mut GimpColorManaged)>,
    pub get_color_profile: Option<unsafe extern "C" fn(*mut GimpColorManaged) -> *mut GimpColorProfile>,
    pub get_simulation_profile: Option<unsafe extern "C" fn(*mut GimpColorManaged) -> *mut GimpColorProfile>,
    pub get_simulation_intent: Option<unsafe extern "C" fn(*mut GimpColorManaged) -> GimpColorRenderingIntent>,
    pub get_simulation_bpc: Option<unsafe extern "C" fn(*mut GimpColorManaged) -> gboolean>,
}

impl ::std::fmt::Debug for GimpColorManagedInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpColorManagedInterface @ {self:p}"))
         .field("base_iface", &self.base_iface)
         .field("get_icc_profile", &self.get_icc_profile)
         .field("profile_changed", &self.profile_changed)
         .field("simulation_profile_changed", &self.simulation_profile_changed)
         .field("simulation_intent_changed", &self.simulation_intent_changed)
         .field("simulation_bpc_changed", &self.simulation_bpc_changed)
         .field("get_color_profile", &self.get_color_profile)
         .field("get_simulation_profile", &self.get_simulation_profile)
         .field("get_simulation_intent", &self.get_simulation_intent)
         .field("get_simulation_bpc", &self.get_simulation_bpc)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpColorProfileClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpColorProfileClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpColorProfileClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpColorTransformClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpColorTransformClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpColorTransformClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GimpConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GimpConfig = _GimpConfig;

#[repr(C)]
#[allow(dead_code)]
pub struct GimpConfigWriter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpConfigWriter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpConfigWriter @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpDisplayClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpDisplayClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDisplayClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpDrawableClass {
    pub parent_class: GimpItemClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpDrawableClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDrawableClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpDrawableFilterClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpDrawableFilterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDrawableFilterClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpDrawableFilterConfigClass {
    pub parent_class: gobject::GObjectClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpDrawableFilterConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDrawableFilterConfigClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpEnumDesc {
    pub value: c_int,
    pub value_desc: *const c_char,
    pub value_help: *const c_char,
}

impl ::std::fmt::Debug for GimpEnumDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpEnumDesc @ {self:p}"))
         .field("value", &self.value)
         .field("value_desc", &self.value_desc)
         .field("value_help", &self.value_help)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpExportOptionsClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpExportOptionsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpExportOptionsClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpExportProcedureClass {
    pub parent_class: GimpFileProcedureClass,
}

impl ::std::fmt::Debug for GimpExportProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpExportProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpFileProcedureClass {
    pub parent_class: GimpProcedureClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpFileProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpFileProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpFlagsDesc {
    pub value: c_uint,
    pub value_desc: *const c_char,
    pub value_help: *const c_char,
}

impl ::std::fmt::Debug for GimpFlagsDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpFlagsDesc @ {self:p}"))
         .field("value", &self.value)
         .field("value_desc", &self.value_desc)
         .field("value_help", &self.value_help)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpFontClass {
    pub parent_class: GimpResourceClass,
}

impl ::std::fmt::Debug for GimpFontClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpFontClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpGradientClass {
    pub parent_class: GimpResourceClass,
}

impl ::std::fmt::Debug for GimpGradientClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpGradientClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpGroupLayerClass {
    pub parent_class: GimpLayerClass,
}

impl ::std::fmt::Debug for GimpGroupLayerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpGroupLayerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpImageClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpImageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpImageClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpImageProcedureClass {
    pub parent_class: GimpProcedureClass,
}

impl ::std::fmt::Debug for GimpImageProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpImageProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpItemClass {
    pub parent_class: gobject::GObjectClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpItemClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpItemClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpLayerClass {
    pub parent_class: GimpDrawableClass,
    pub copy: Option<unsafe extern "C" fn(*mut GimpLayer) -> *mut GimpLayer>,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpLayerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpLayerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("copy", &self.copy)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpLayerMaskClass {
    pub parent_class: GimpChannelClass,
}

impl ::std::fmt::Debug for GimpLayerMaskClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpLayerMaskClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpLoadProcedureClass {
    pub parent_class: GimpFileProcedureClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpLoadProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpLoadProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpMatrix2 {
    pub coeff: [c_double; 4],
}

impl ::std::fmt::Debug for GimpMatrix2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpMatrix2 @ {self:p}"))
         .field("coeff", &self.coeff)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpMatrix3 {
    pub coeff: [c_double; 9],
}

impl ::std::fmt::Debug for GimpMatrix3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpMatrix3 @ {self:p}"))
         .field("coeff", &self.coeff)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpMatrix4 {
    pub coeff: [c_double; 16],
}

impl ::std::fmt::Debug for GimpMatrix4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpMatrix4 @ {self:p}"))
         .field("coeff", &self.coeff)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpMetadataClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpMetadataClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpMetadataClass @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpModuleClass {
    pub parent_class: gobject::GTypeModuleClass,
    pub modified: Option<unsafe extern "C" fn(*mut GimpModule)>,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpModuleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpModuleClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("modified", &self.modified)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpModuleDBClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpModuleDBClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpModuleDBClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpModuleInfo {
    pub abi_version: u32,
    pub purpose: *mut c_char,
    pub author: *mut c_char,
    pub version: *mut c_char,
    pub copyright: *mut c_char,
    pub date: *mut c_char,
}

impl ::std::fmt::Debug for GimpModuleInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpModuleInfo @ {self:p}"))
         .field("abi_version", &self.abi_version)
         .field("purpose", &self.purpose)
         .field("author", &self.author)
         .field("version", &self.version)
         .field("copyright", &self.copyright)
         .field("date", &self.date)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpPDBClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpPDBClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPDBClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpPaletteClass {
    pub parent_class: GimpResourceClass,
}

impl ::std::fmt::Debug for GimpPaletteClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPaletteClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamSpecChoice {
    _truncated_record_marker: c_void,
    // /*Ignored*/field parent_instance has incomplete type
}

impl ::std::fmt::Debug for GimpParamSpecChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecChoice @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GimpParamSpecColor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GimpParamSpecColor = _GimpParamSpecColor;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecCoreObjectArray {
    pub parent_instance: gobject::GParamSpecBoxed,
    pub object_type: GType,
}

impl ::std::fmt::Debug for GimpParamSpecCoreObjectArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecCoreObjectArray @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("object_type", &self.object_type)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecDisplay {
    pub parent_instance: gobject::GParamSpecObject,
    pub none_ok: gboolean,
}

impl ::std::fmt::Debug for GimpParamSpecDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecDisplay @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("none_ok", &self.none_ok)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecDrawableFilter {
    pub parent_instance: gobject::GParamSpecObject,
    pub none_ok: gboolean,
}

impl ::std::fmt::Debug for GimpParamSpecDrawableFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecDrawableFilter @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("none_ok", &self.none_ok)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecImage {
    pub parent_instance: gobject::GParamSpecObject,
    pub none_ok: gboolean,
}

impl ::std::fmt::Debug for GimpParamSpecImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecImage @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("none_ok", &self.none_ok)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecItem {
    pub parent_instance: gobject::GParamSpecObject,
    pub none_ok: gboolean,
}

impl ::std::fmt::Debug for GimpParamSpecItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecItem @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("none_ok", &self.none_ok)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecObject {
    pub parent_instance: gobject::GParamSpecObject,
    pub _default_value: *mut gobject::GObject,
    pub _has_default: gboolean,
}

impl ::std::fmt::Debug for GimpParamSpecObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecObject @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecObjectClass {
    pub parent_class: gobject::GParamSpecClass,
    pub duplicate: Option<unsafe extern "C" fn(*mut gobject::GParamSpec) -> *mut gobject::GParamSpec>,
    pub get_default: Option<unsafe extern "C" fn(*mut gobject::GParamSpec) -> *mut gobject::GObject>,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpParamSpecObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecObjectClass @ {self:p}"))
         .field("duplicate", &self.duplicate)
         .field("get_default", &self.get_default)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecResource {
    pub parent_instance: GimpParamSpecObject,
    pub none_ok: gboolean,
    pub default_to_context: gboolean,
}

impl ::std::fmt::Debug for GimpParamSpecResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecResource @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("none_ok", &self.none_ok)
         .field("default_to_context", &self.default_to_context)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecUnit {
    pub parent_instance: GimpParamSpecObject,
    pub allow_pixel: gboolean,
    pub allow_percent: gboolean,
    pub default_value: *mut GimpUnit,
}

impl ::std::fmt::Debug for GimpParamSpecUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecUnit @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("allow_pixel", &self.allow_pixel)
         .field("allow_percent", &self.allow_percent)
         .field("default_value", &self.default_value)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParamSpecValueArray {
    pub parent_instance: gobject::GParamSpec,
    pub element_spec: *mut gobject::GParamSpec,
    pub fixed_n_elements: c_int,
}

impl ::std::fmt::Debug for GimpParamSpecValueArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSpecValueArray @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("element_spec", &self.element_spec)
         .field("fixed_n_elements", &self.fixed_n_elements)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpParasite {
    pub name: *mut c_char,
    pub flags: u32,
    pub size: u32,
    pub data: gpointer,
}

impl ::std::fmt::Debug for GimpParasite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParasite @ {self:p}"))
         .field("name", &self.name)
         .field("flags", &self.flags)
         .field("size", &self.size)
         .field("data", &self.data)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpPathClass {
    pub parent_class: GimpItemClass,
}

impl ::std::fmt::Debug for GimpPathClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPathClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpPatternClass {
    pub parent_class: GimpResourceClass,
}

impl ::std::fmt::Debug for GimpPatternClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPatternClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpPixPipeParams {
    pub step: c_int,
    pub ncells: c_int,
    pub dim: c_int,
    pub cols: c_int,
    pub rows: c_int,
    pub cellwidth: c_int,
    pub cellheight: c_int,
    pub placement: *mut c_char,
    pub rank: [c_int; 4],
    pub selection: [*mut c_char; 4],
}

impl ::std::fmt::Debug for GimpPixPipeParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPixPipeParams @ {self:p}"))
         .field("step", &self.step)
         .field("ncells", &self.ncells)
         .field("dim", &self.dim)
         .field("cols", &self.cols)
         .field("rows", &self.rows)
         .field("cellwidth", &self.cellwidth)
         .field("cellheight", &self.cellheight)
         .field("placement", &self.placement)
         .field("rank", &self.rank)
         .field("selection", &self.selection)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpPlugInClass {
    pub parent_class: gobject::GObjectClass,
    pub query_procedures: Option<unsafe extern "C" fn(*mut GimpPlugIn) -> *mut glib::GList>,
    pub init_procedures: Option<unsafe extern "C" fn(*mut GimpPlugIn) -> *mut glib::GList>,
    pub create_procedure: Option<unsafe extern "C" fn(*mut GimpPlugIn, *const c_char) -> *mut GimpProcedure>,
    pub quit: Option<unsafe extern "C" fn(*mut GimpPlugIn)>,
    pub set_i18n: Option<unsafe extern "C" fn(*mut GimpPlugIn, *const c_char, *mut *mut c_char, *mut *mut c_char) -> gboolean>,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpPlugInClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPlugInClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("query_procedures", &self.query_procedures)
         .field("init_procedures", &self.init_procedures)
         .field("create_procedure", &self.create_procedure)
         .field("quit", &self.quit)
         .field("set_i18n", &self.set_i18n)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpProcedureClass {
    pub parent_class: gobject::GObjectClass,
    pub install: Option<unsafe extern "C" fn(*mut GimpProcedure)>,
    pub uninstall: Option<unsafe extern "C" fn(*mut GimpProcedure)>,
    pub run: Option<unsafe extern "C" fn(*mut GimpProcedure, *const GimpValueArray) -> *mut GimpValueArray>,
    pub create_config: Option<unsafe extern "C" fn(*mut GimpProcedure, *mut *mut gobject::GParamSpec, c_int) -> *mut GimpProcedureConfig>,
    pub set_sensitivity: Option<unsafe extern "C" fn(*mut GimpProcedure, c_int) -> gboolean>,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("install", &self.install)
         .field("uninstall", &self.uninstall)
         .field("run", &self.run)
         .field("create_config", &self.create_config)
         .field("set_sensitivity", &self.set_sensitivity)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpProcedureConfigClass {
    pub parent_class: gobject::GObjectClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpProcedureConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpProcedureConfigClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpProgressVtable {
    pub start: GimpProgressVtableStartFunc,
    pub end: GimpProgressVtableEndFunc,
    pub set_text: GimpProgressVtableSetTextFunc,
    pub set_value: GimpProgressVtableSetValueFunc,
    pub pulse: GimpProgressVtablePulseFunc,
    pub get_window_handle: GimpProgressVtableGetWindowFunc,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpProgressVtable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpProgressVtable @ {self:p}"))
         .field("start", &self.start)
         .field("end", &self.end)
         .field("set_text", &self.set_text)
         .field("set_value", &self.set_value)
         .field("pulse", &self.pulse)
         .field("get_window_handle", &self.get_window_handle)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpResourceClass {
    pub parent_class: gobject::GObjectClass,
    pub _gimp_reserved0: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved1: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved2: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved3: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved4: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved5: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved6: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved7: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved8: Option<unsafe extern "C" fn()>,
    pub _gimp_reserved9: Option<unsafe extern "C" fn()>,
}

impl ::std::fmt::Debug for GimpResourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpResourceClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("_gimp_reserved0", &self._gimp_reserved0)
         .field("_gimp_reserved1", &self._gimp_reserved1)
         .field("_gimp_reserved2", &self._gimp_reserved2)
         .field("_gimp_reserved3", &self._gimp_reserved3)
         .field("_gimp_reserved4", &self._gimp_reserved4)
         .field("_gimp_reserved5", &self._gimp_reserved5)
         .field("_gimp_reserved6", &self._gimp_reserved6)
         .field("_gimp_reserved7", &self._gimp_reserved7)
         .field("_gimp_reserved8", &self._gimp_reserved8)
         .field("_gimp_reserved9", &self._gimp_reserved9)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpScanner {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpScanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpScanner @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpSelectionClass {
    pub parent_class: GimpChannelClass,
}

impl ::std::fmt::Debug for GimpSelectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpSelectionClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpTextLayerClass {
    pub parent_class: GimpLayerClass,
}

impl ::std::fmt::Debug for GimpTextLayerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpTextLayerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpThumbnailProcedureClass {
    pub parent_class: GimpProcedureClass,
}

impl ::std::fmt::Debug for GimpThumbnailProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpThumbnailProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpUnitClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GimpUnitClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpUnitClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpValueArray {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpValueArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpValueArray @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpVector2 {
    pub x: c_double,
    pub y: c_double,
}

impl ::std::fmt::Debug for GimpVector2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpVector2 @ {self:p}"))
         .field("x", &self.x)
         .field("y", &self.y)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpVector3 {
    pub x: c_double,
    pub y: c_double,
    pub z: c_double,
}

impl ::std::fmt::Debug for GimpVector3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpVector3 @ {self:p}"))
         .field("x", &self.x)
         .field("y", &self.y)
         .field("z", &self.z)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpVector4 {
    pub x: c_double,
    pub y: c_double,
    pub z: c_double,
    pub w: c_double,
}

impl ::std::fmt::Debug for GimpVector4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpVector4 @ {self:p}"))
         .field("x", &self.x)
         .field("y", &self.y)
         .field("z", &self.z)
         .field("w", &self.w)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpVectorLoadData {
    pub width: c_double,
    pub width_unit: *mut GimpUnit,
    pub exact_width: gboolean,
    pub height: c_double,
    pub height_unit: *mut GimpUnit,
    pub exact_height: gboolean,
    pub correct_ratio: gboolean,
    pub pixel_density: c_double,
    pub density_unit: *mut GimpUnit,
    pub exact_density: gboolean,
}

impl ::std::fmt::Debug for GimpVectorLoadData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpVectorLoadData @ {self:p}"))
         .field("width", &self.width)
         .field("width_unit", &self.width_unit)
         .field("exact_width", &self.exact_width)
         .field("height", &self.height)
         .field("height_unit", &self.height_unit)
         .field("exact_height", &self.exact_height)
         .field("correct_ratio", &self.correct_ratio)
         .field("pixel_density", &self.pixel_density)
         .field("density_unit", &self.density_unit)
         .field("exact_density", &self.exact_density)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpVectorLoadProcedureClass {
    pub parent_class: GimpLoadProcedureClass,
}

impl ::std::fmt::Debug for GimpVectorLoadProcedureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpVectorLoadProcedureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

// Classes
#[repr(C)]
#[allow(dead_code)]
pub struct GimpBatchProcedure {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpBatchProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpBatchProcedure @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpBrush {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpBrush {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpBrush @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpChannel {
    pub parent_instance: GimpDrawable,
}

impl ::std::fmt::Debug for GimpChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpChannel @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpChoice {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpChoice @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpColorConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpColorConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpColorConfig @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpColorProfile {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpColorProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpColorProfile @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpColorTransform {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpColorTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpColorTransform @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpConfigPath {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpConfigPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpConfigPath @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpDisplay {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDisplay @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpDrawable {
    pub parent_instance: GimpItem,
}

impl ::std::fmt::Debug for GimpDrawable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDrawable @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpDrawableFilter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpDrawableFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDrawableFilter @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpDrawableFilterConfig {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GimpDrawableFilterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpDrawableFilterConfig @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpExportOptions {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpExportOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpExportOptions @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpExportProcedure {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpExportProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpExportProcedure @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpFileProcedure {
    pub parent_instance: GimpProcedure,
}

impl ::std::fmt::Debug for GimpFileProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpFileProcedure @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpFont {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpFont {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpFont @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpGradient {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpGradient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpGradient @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpGroupLayer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpGroupLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpGroupLayer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpImage {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpImage @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpImageProcedure {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpImageProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpImageProcedure @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpItem {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GimpItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpItem @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpLayer {
    pub parent_instance: GimpDrawable,
}

impl ::std::fmt::Debug for GimpLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpLayer @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpLayerMask {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpLayerMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpLayerMask @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpLoadProcedure {
    pub parent_instance: GimpFileProcedure,
}

impl ::std::fmt::Debug for GimpLoadProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpLoadProcedure @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpMemsize {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpMemsize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpMemsize @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpMetadata {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpMetadata @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpModule {
    pub parent_instance: gobject::GTypeModule,
}

impl ::std::fmt::Debug for GimpModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpModule @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpModuleDB {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpModuleDB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpModuleDB @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpPDB {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpPDB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPDB @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpPalette {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpPalette {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPalette @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamArray {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamArray @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamBrush {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamBrush {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamBrush @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamChannel {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamChannel @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamChoice {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamChoice @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamColor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamColor @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamConfigPath {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamConfigPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamConfigPath @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamCoreObjectArray {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamCoreObjectArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamCoreObjectArray @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamDisplay {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamDisplay @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamDoubleArray {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamDoubleArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamDoubleArray @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamDrawable {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamDrawable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamDrawable @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamDrawableFilter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamDrawableFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamDrawableFilter @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamExportOptions {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamExportOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamExportOptions @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamFont {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamFont {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamFont @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamGradient {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamGradient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamGradient @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamGroupLayer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamGroupLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamGroupLayer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamImage {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamImage @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamInt32Array {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamInt32Array {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamInt32Array @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamItem {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamItem @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamLayer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamLayer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamLayerMask {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamLayerMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamLayerMask @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamMatrix2 {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamMatrix2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamMatrix2 @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamMatrix3 {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamMatrix3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamMatrix3 @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamMemsize {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamMemsize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamMemsize @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamObject {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamObject @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamPalette {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamPalette {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamPalette @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamParasite {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamParasite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamParasite @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamPath {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamPath @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamPattern {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamPattern {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamPattern @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamResource {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamResource @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamSelection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamSelection @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamTextLayer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamTextLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamTextLayer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamUnit {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamUnit @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpParamValueArray {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpParamValueArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpParamValueArray @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpPath {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPath @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpPattern {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpPattern {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPattern @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpPlugIn {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GimpPlugIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpPlugIn @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpProcedure {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GimpProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpProcedure @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpProcedureConfig {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GimpProcedureConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpProcedureConfig @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GimpResource {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GimpResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpResource @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpSelection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpSelection @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpTextLayer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpTextLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpTextLayer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpThumbnailProcedure {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpThumbnailProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpThumbnailProcedure @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpUnit {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpUnit @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpVectorLoadProcedure {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpVectorLoadProcedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GimpVectorLoadProcedure @ {self:p}"))
         .finish()
    }
}

// Interfaces
#[repr(C)]
#[allow(dead_code)]
pub struct GimpColorManaged {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpColorManaged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GimpColorManaged @ {self:p}")
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GimpConfigInterface {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GimpConfigInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GimpConfigInterface @ {self:p}")
    }
}


extern "C" {

    //=========================================================================
    // GimpAddMaskType
    //=========================================================================
    pub fn gimp_add_mask_type_get_type() -> GType;

    //=========================================================================
    // GimpBrushApplicationMode
    //=========================================================================
    pub fn gimp_brush_application_mode_get_type() -> GType;

    //=========================================================================
    // GimpBrushGeneratedShape
    //=========================================================================
    pub fn gimp_brush_generated_shape_get_type() -> GType;

    //=========================================================================
    // GimpCapStyle
    //=========================================================================
    pub fn gimp_cap_style_get_type() -> GType;

    //=========================================================================
    // GimpChannelOps
    //=========================================================================
    pub fn gimp_channel_ops_get_type() -> GType;

    //=========================================================================
    // GimpChannelType
    //=========================================================================
    pub fn gimp_channel_type_get_type() -> GType;

    //=========================================================================
    // GimpCheckSize
    //=========================================================================
    pub fn gimp_check_size_get_type() -> GType;

    //=========================================================================
    // GimpCheckType
    //=========================================================================
    pub fn gimp_check_type_get_type() -> GType;

    //=========================================================================
    // GimpCloneType
    //=========================================================================
    pub fn gimp_clone_type_get_type() -> GType;

    //=========================================================================
    // GimpColorManagementMode
    //=========================================================================
    pub fn gimp_color_management_mode_get_type() -> GType;

    //=========================================================================
    // GimpColorRenderingIntent
    //=========================================================================
    pub fn gimp_color_rendering_intent_get_type() -> GType;

    //=========================================================================
    // GimpColorTag
    //=========================================================================
    pub fn gimp_color_tag_get_type() -> GType;

    //=========================================================================
    // GimpComponentType
    //=========================================================================
    pub fn gimp_component_type_get_type() -> GType;

    //=========================================================================
    // GimpConvertDitherType
    //=========================================================================
    pub fn gimp_convert_dither_type_get_type() -> GType;

    //=========================================================================
    // GimpConvertPaletteType
    //=========================================================================
    pub fn gimp_convert_palette_type_get_type() -> GType;

    //=========================================================================
    // GimpConvolveType
    //=========================================================================
    pub fn gimp_convolve_type_get_type() -> GType;

    //=========================================================================
    // GimpDesaturateMode
    //=========================================================================
    pub fn gimp_desaturate_mode_get_type() -> GType;

    //=========================================================================
    // GimpDodgeBurnType
    //=========================================================================
    pub fn gimp_dodge_burn_type_get_type() -> GType;

    //=========================================================================
    // GimpFillType
    //=========================================================================
    pub fn gimp_fill_type_get_type() -> GType;

    //=========================================================================
    // GimpForegroundExtractMode
    //=========================================================================
    pub fn gimp_foreground_extract_mode_get_type() -> GType;

    //=========================================================================
    // GimpGradientBlendColorSpace
    //=========================================================================
    pub fn gimp_gradient_blend_color_space_get_type() -> GType;

    //=========================================================================
    // GimpGradientSegmentColor
    //=========================================================================
    pub fn gimp_gradient_segment_color_get_type() -> GType;

    //=========================================================================
    // GimpGradientSegmentType
    //=========================================================================
    pub fn gimp_gradient_segment_type_get_type() -> GType;

    //=========================================================================
    // GimpGradientType
    //=========================================================================
    pub fn gimp_gradient_type_get_type() -> GType;

    //=========================================================================
    // GimpGridStyle
    //=========================================================================
    pub fn gimp_grid_style_get_type() -> GType;

    //=========================================================================
    // GimpHistogramChannel
    //=========================================================================
    pub fn gimp_histogram_channel_get_type() -> GType;

    //=========================================================================
    // GimpHueRange
    //=========================================================================
    pub fn gimp_hue_range_get_type() -> GType;

    //=========================================================================
    // GimpIconType
    //=========================================================================
    pub fn gimp_icon_type_get_type() -> GType;

    //=========================================================================
    // GimpImageBaseType
    //=========================================================================
    pub fn gimp_image_base_type_get_type() -> GType;

    //=========================================================================
    // GimpImageType
    //=========================================================================
    pub fn gimp_image_type_get_type() -> GType;

    //=========================================================================
    // GimpInkBlobType
    //=========================================================================
    pub fn gimp_ink_blob_type_get_type() -> GType;

    //=========================================================================
    // GimpInterpolationType
    //=========================================================================
    pub fn gimp_interpolation_type_get_type() -> GType;

    //=========================================================================
    // GimpJoinStyle
    //=========================================================================
    pub fn gimp_join_style_get_type() -> GType;

    //=========================================================================
    // GimpLayerColorSpace
    //=========================================================================
    pub fn gimp_layer_color_space_get_type() -> GType;

    //=========================================================================
    // GimpLayerCompositeMode
    //=========================================================================
    pub fn gimp_layer_composite_mode_get_type() -> GType;

    //=========================================================================
    // GimpLayerMode
    //=========================================================================
    pub fn gimp_layer_mode_get_type() -> GType;

    //=========================================================================
    // GimpMaskApplyMode
    //=========================================================================
    pub fn gimp_mask_apply_mode_get_type() -> GType;

    //=========================================================================
    // GimpMergeType
    //=========================================================================
    pub fn gimp_merge_type_get_type() -> GType;

    //=========================================================================
    // GimpMessageHandlerType
    //=========================================================================
    pub fn gimp_message_handler_type_get_type() -> GType;

    //=========================================================================
    // GimpOffsetType
    //=========================================================================
    pub fn gimp_offset_type_get_type() -> GType;

    //=========================================================================
    // GimpOrientationType
    //=========================================================================
    pub fn gimp_orientation_type_get_type() -> GType;

    //=========================================================================
    // GimpPDBErrorHandler
    //=========================================================================
    pub fn gimp_pdb_error_handler_get_type() -> GType;

    //=========================================================================
    // GimpPDBProcType
    //=========================================================================
    pub fn gimp_pdb_proc_type_get_type() -> GType;

    //=========================================================================
    // GimpPDBStatusType
    //=========================================================================
    pub fn gimp_pdb_status_type_get_type() -> GType;

    //=========================================================================
    // GimpPaintApplicationMode
    //=========================================================================
    pub fn gimp_paint_application_mode_get_type() -> GType;

    //=========================================================================
    // GimpPathStrokeType
    //=========================================================================
    pub fn gimp_path_stroke_type_get_type() -> GType;

    //=========================================================================
    // GimpPrecision
    //=========================================================================
    pub fn gimp_precision_get_type() -> GType;

    //=========================================================================
    // GimpProgressCommand
    //=========================================================================
    pub fn gimp_progress_command_get_type() -> GType;

    //=========================================================================
    // GimpRepeatMode
    //=========================================================================
    pub fn gimp_repeat_mode_get_type() -> GType;

    //=========================================================================
    // GimpRotationType
    //=========================================================================
    pub fn gimp_rotation_type_get_type() -> GType;

    //=========================================================================
    // GimpRunMode
    //=========================================================================
    pub fn gimp_run_mode_get_type() -> GType;

    //=========================================================================
    // GimpSelectCriterion
    //=========================================================================
    pub fn gimp_select_criterion_get_type() -> GType;

    //=========================================================================
    // GimpSizeType
    //=========================================================================
    pub fn gimp_size_type_get_type() -> GType;

    //=========================================================================
    // GimpStackTraceMode
    //=========================================================================
    pub fn gimp_stack_trace_mode_get_type() -> GType;

    //=========================================================================
    // GimpStrokeMethod
    //=========================================================================
    pub fn gimp_stroke_method_get_type() -> GType;

    //=========================================================================
    // GimpTextDirection
    //=========================================================================
    pub fn gimp_text_direction_get_type() -> GType;

    //=========================================================================
    // GimpTextHintStyle
    //=========================================================================
    pub fn gimp_text_hint_style_get_type() -> GType;

    //=========================================================================
    // GimpTextJustification
    //=========================================================================
    pub fn gimp_text_justification_get_type() -> GType;

    //=========================================================================
    // GimpTransferMode
    //=========================================================================
    pub fn gimp_transfer_mode_get_type() -> GType;

    //=========================================================================
    // GimpTransformDirection
    //=========================================================================
    pub fn gimp_transform_direction_get_type() -> GType;

    //=========================================================================
    // GimpTransformResize
    //=========================================================================
    pub fn gimp_transform_resize_get_type() -> GType;

    //=========================================================================
    // GimpExportCapabilities
    //=========================================================================
    pub fn gimp_export_capabilities_get_type() -> GType;

    //=========================================================================
    // GimpProcedureSensitivityMask
    //=========================================================================
    pub fn gimp_procedure_sensitivity_mask_get_type() -> GType;

    //=========================================================================
    // GimpArray
    //=========================================================================
    pub fn gimp_array_get_type() -> GType;
    pub fn gimp_array_new(data: *const u8, length: size_t, static_data: gboolean) -> *mut GimpArray;
    pub fn gimp_array_copy(array: *const GimpArray) -> *mut GimpArray;
    pub fn gimp_array_free(array: *mut GimpArray);

    //=========================================================================
    // GimpConfig
    //=========================================================================
    pub fn gimp_config_copy(src: *mut GimpConfig, dest: *mut GimpConfig, flags: gobject::GParamFlags) -> gboolean;
    pub fn gimp_config_deserialize(config: *mut GimpConfig, scanner: *mut glib::GScanner, nest_level: c_int, data: gpointer) -> gboolean;
    pub fn gimp_config_deserialize_file(config: *mut GimpConfig, file: *mut gio::GFile, data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_config_deserialize_parasite(config: *mut GimpConfig, parasite: *const GimpParasite, data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_config_deserialize_properties(config: *mut GimpConfig, scanner: *mut glib::GScanner, nest_level: c_int) -> gboolean;
    pub fn gimp_config_deserialize_property(config: *mut GimpConfig, scanner: *mut glib::GScanner, nest_level: c_int) -> glib::GTokenType;
    pub fn gimp_config_deserialize_stream(config: *mut GimpConfig, input: *mut gio::GInputStream, data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_config_deserialize_string(config: *mut GimpConfig, text: *const c_char, text_len: c_int, data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_config_duplicate(config: *mut GimpConfig) -> gpointer;
    pub fn gimp_config_is_equal_to(a: *mut GimpConfig, b: *mut GimpConfig) -> gboolean;
    pub fn gimp_config_reset(config: *mut GimpConfig);
    pub fn gimp_config_serialize(config: *mut GimpConfig, writer: *mut GimpConfigWriter, data: gpointer) -> gboolean;
    pub fn gimp_config_serialize_changed_properties(config: *mut GimpConfig, writer: *mut GimpConfigWriter) -> gboolean;
    pub fn gimp_config_serialize_properties(config: *mut GimpConfig, writer: *mut GimpConfigWriter) -> gboolean;
    pub fn gimp_config_serialize_property(config: *mut GimpConfig, param_spec: *mut gobject::GParamSpec, writer: *mut GimpConfigWriter) -> gboolean;
    pub fn gimp_config_serialize_property_by_name(config: *mut GimpConfig, prop_name: *const c_char, writer: *mut GimpConfigWriter) -> gboolean;
    pub fn gimp_config_serialize_to_fd(config: *mut GimpConfig, fd: c_int, data: gpointer) -> gboolean;
    pub fn gimp_config_serialize_to_file(config: *mut GimpConfig, file: *mut gio::GFile, header: *const c_char, footer: *const c_char, data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_config_serialize_to_parasite(config: *mut GimpConfig, parasite_name: *const c_char, parasite_flags: c_uint, data: gpointer) -> *mut GimpParasite;
    pub fn gimp_config_serialize_to_stream(config: *mut GimpConfig, output: *mut gio::GOutputStream, header: *const c_char, footer: *const c_char, data: gpointer, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_config_serialize_to_string(config: *mut GimpConfig, data: gpointer) -> *mut c_char;

    //=========================================================================
    // GimpConfigWriter
    //=========================================================================
    pub fn gimp_config_writer_get_type() -> GType;
    pub fn gimp_config_writer_new_from_fd(fd: c_int) -> *mut GimpConfigWriter;
    pub fn gimp_config_writer_new_from_file(file: *mut gio::GFile, atomic: gboolean, header: *const c_char, error: *mut *mut glib::GError) -> *mut GimpConfigWriter;
    pub fn gimp_config_writer_new_from_stream(output: *mut gio::GOutputStream, header: *const c_char, error: *mut *mut glib::GError) -> *mut GimpConfigWriter;
    pub fn gimp_config_writer_new_from_string(string: *mut glib::GString) -> *mut GimpConfigWriter;
    pub fn gimp_config_writer_close(writer: *mut GimpConfigWriter);
    pub fn gimp_config_writer_comment(writer: *mut GimpConfigWriter, comment: *const c_char);
    pub fn gimp_config_writer_comment_mode(writer: *mut GimpConfigWriter, enable: gboolean);
    pub fn gimp_config_writer_data(writer: *mut GimpConfigWriter, length: c_int, data: *const u8);
    pub fn gimp_config_writer_finish(writer: *mut GimpConfigWriter, footer: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_config_writer_identifier(writer: *mut GimpConfigWriter, identifier: *const c_char);
    pub fn gimp_config_writer_linefeed(writer: *mut GimpConfigWriter);
    pub fn gimp_config_writer_open(writer: *mut GimpConfigWriter, name: *const c_char);
    pub fn gimp_config_writer_print(writer: *mut GimpConfigWriter, string: *const c_char, len: c_int);
    pub fn gimp_config_writer_printf(writer: *mut GimpConfigWriter, format: *const c_char, ...);
    pub fn gimp_config_writer_ref(writer: *mut GimpConfigWriter) -> *mut GimpConfigWriter;
    pub fn gimp_config_writer_revert(writer: *mut GimpConfigWriter);
    pub fn gimp_config_writer_string(writer: *mut GimpConfigWriter, string: *const c_char);
    pub fn gimp_config_writer_unref(writer: *mut GimpConfigWriter);

    //=========================================================================
    // GimpMatrix2
    //=========================================================================
    pub fn gimp_matrix2_get_type() -> GType;
    pub fn gimp_matrix2_determinant(matrix: *const GimpMatrix2) -> c_double;
    pub fn gimp_matrix2_identity(matrix: *mut GimpMatrix2);
    pub fn gimp_matrix2_invert(matrix: *mut GimpMatrix2);
    pub fn gimp_matrix2_mult(left: *const GimpMatrix2, right: *mut GimpMatrix2);
    pub fn gimp_matrix2_transform_point(matrix: *const GimpMatrix2, x: c_double, y: c_double, newx: *mut c_double, newy: *mut c_double);

    //=========================================================================
    // GimpMatrix3
    //=========================================================================
    pub fn gimp_matrix3_get_type() -> GType;
    pub fn gimp_matrix3_affine(matrix: *mut GimpMatrix3, a: c_double, b: c_double, c: c_double, d: c_double, e: c_double, f: c_double);
    pub fn gimp_matrix3_determinant(matrix: *const GimpMatrix3) -> c_double;
    pub fn gimp_matrix3_equal(matrix1: *const GimpMatrix3, matrix2: *const GimpMatrix3) -> gboolean;
    pub fn gimp_matrix3_identity(matrix: *mut GimpMatrix3);
    pub fn gimp_matrix3_invert(matrix: *mut GimpMatrix3);
    pub fn gimp_matrix3_is_affine(matrix: *const GimpMatrix3) -> gboolean;
    pub fn gimp_matrix3_is_diagonal(matrix: *const GimpMatrix3) -> gboolean;
    pub fn gimp_matrix3_is_identity(matrix: *const GimpMatrix3) -> gboolean;
    pub fn gimp_matrix3_is_simple(matrix: *const GimpMatrix3) -> gboolean;
    pub fn gimp_matrix3_mult(left: *const GimpMatrix3, right: *mut GimpMatrix3);
    pub fn gimp_matrix3_rotate(matrix: *mut GimpMatrix3, theta: c_double);
    pub fn gimp_matrix3_scale(matrix: *mut GimpMatrix3, x: c_double, y: c_double);
    pub fn gimp_matrix3_transform_point(matrix: *const GimpMatrix3, x: c_double, y: c_double, newx: *mut c_double, newy: *mut c_double);
    pub fn gimp_matrix3_translate(matrix: *mut GimpMatrix3, x: c_double, y: c_double);
    pub fn gimp_matrix3_xshear(matrix: *mut GimpMatrix3, amount: c_double);
    pub fn gimp_matrix3_yshear(matrix: *mut GimpMatrix3, amount: c_double);

    //=========================================================================
    // GimpMatrix4
    //=========================================================================
    pub fn gimp_matrix4_identity(matrix: *mut GimpMatrix4);
    pub fn gimp_matrix4_mult(left: *const GimpMatrix4, right: *mut GimpMatrix4);
    pub fn gimp_matrix4_to_deg(matrix: *const GimpMatrix4, a: *mut c_double, b: *mut c_double, c: *mut c_double);
    pub fn gimp_matrix4_transform_point(matrix: *const GimpMatrix4, x: c_double, y: c_double, z: c_double, newx: *mut c_double, newy: *mut c_double, newz: *mut c_double) -> c_double;

    //=========================================================================
    // GimpParamSpecColor
    //=========================================================================
    pub fn gimp_param_spec_color_from_string(name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, default_color_string: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_color_has_alpha(pspec: *mut gobject::GParamSpec) -> gboolean;

    //=========================================================================
    // GimpParamSpecObject
    //=========================================================================
    pub fn gimp_param_spec_object_duplicate(pspec: *mut gobject::GParamSpec) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_object_get_default(pspec: *mut gobject::GParamSpec) -> *mut gobject::GObject;
    pub fn gimp_param_spec_object_has_default(pspec: *mut gobject::GParamSpec) -> gboolean;
    pub fn gimp_param_spec_object_set_default(pspec: *mut gobject::GParamSpec, default_value: *mut gobject::GObject);

    //=========================================================================
    // GimpParasite
    //=========================================================================
    pub fn gimp_parasite_get_type() -> GType;
    pub fn gimp_parasite_new(name: *const c_char, flags: u32, size: u32, data: gconstpointer) -> *mut GimpParasite;
    pub fn gimp_parasite_compare(a: *const GimpParasite, b: *const GimpParasite) -> gboolean;
    pub fn gimp_parasite_copy(parasite: *const GimpParasite) -> *mut GimpParasite;
    pub fn gimp_parasite_free(parasite: *mut GimpParasite);
    pub fn gimp_parasite_get_data(parasite: *const GimpParasite, num_bytes: *mut u32) -> gconstpointer;
    pub fn gimp_parasite_get_flags(parasite: *const GimpParasite) -> c_ulong;
    pub fn gimp_parasite_get_name(parasite: *const GimpParasite) -> *const c_char;
    pub fn gimp_parasite_has_flag(parasite: *const GimpParasite, flag: c_ulong) -> gboolean;
    pub fn gimp_parasite_is_persistent(parasite: *const GimpParasite) -> gboolean;
    pub fn gimp_parasite_is_type(parasite: *const GimpParasite, name: *const c_char) -> gboolean;
    pub fn gimp_parasite_is_undoable(parasite: *const GimpParasite) -> gboolean;

    //=========================================================================
    // GimpScanner
    //=========================================================================
    pub fn gimp_scanner_get_type() -> GType;
    pub fn gimp_scanner_new_file(file: *mut gio::GFile, error: *mut *mut glib::GError) -> *mut GimpScanner;
    pub fn gimp_scanner_new_stream(input: *mut gio::GInputStream, error: *mut *mut glib::GError) -> *mut GimpScanner;
    pub fn gimp_scanner_new_string(text: *const c_char, text_len: c_int, error: *mut *mut glib::GError) -> *mut GimpScanner;
    pub fn gimp_scanner_parse_boolean(scanner: *mut GimpScanner, dest: *mut gboolean) -> gboolean;
    pub fn gimp_scanner_parse_color(scanner: *mut GimpScanner, color: *mut *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_scanner_parse_data(scanner: *mut GimpScanner, length: c_int, dest: *mut *mut u8) -> gboolean;
    pub fn gimp_scanner_parse_double(scanner: *mut GimpScanner, dest: *mut c_double) -> gboolean;
    pub fn gimp_scanner_parse_identifier(scanner: *mut GimpScanner, identifier: *const c_char) -> gboolean;
    pub fn gimp_scanner_parse_int(scanner: *mut GimpScanner, dest: *mut c_int) -> gboolean;
    pub fn gimp_scanner_parse_int64(scanner: *mut GimpScanner, dest: *mut i64) -> gboolean;
    pub fn gimp_scanner_parse_matrix2(scanner: *mut GimpScanner, dest: *mut GimpMatrix2) -> gboolean;
    pub fn gimp_scanner_parse_string(scanner: *mut GimpScanner, dest: *mut *mut c_char) -> gboolean;
    pub fn gimp_scanner_parse_string_no_validate(scanner: *mut GimpScanner, dest: *mut *mut c_char) -> gboolean;
    pub fn gimp_scanner_parse_token(scanner: *mut GimpScanner, token: glib::GTokenType) -> gboolean;
    pub fn gimp_scanner_ref(scanner: *mut GimpScanner) -> *mut GimpScanner;
    pub fn gimp_scanner_unref(scanner: *mut GimpScanner);

    //=========================================================================
    // GimpValueArray
    //=========================================================================
    pub fn gimp_value_array_get_type() -> GType;
    pub fn gimp_value_array_new(n_prealloced: c_int) -> *mut GimpValueArray;
    pub fn gimp_value_array_new_from_types(error_msg: *mut *mut c_char, first_type: GType, ...) -> *mut GimpValueArray;
    //pub fn gimp_value_array_new_from_types_valist(error_msg: *mut *mut c_char, first_type: GType, va_args: /*Unimplemented*/va_list) -> *mut GimpValueArray;
    pub fn gimp_value_array_new_from_values(values: *const gobject::GValue, n_values: c_int) -> *mut GimpValueArray;
    pub fn gimp_value_array_append(value_array: *mut GimpValueArray, value: *const gobject::GValue) -> *mut GimpValueArray;
    pub fn gimp_value_array_copy(value_array: *const GimpValueArray) -> *mut GimpValueArray;
    pub fn gimp_value_array_get_color_array(value_array: *const GimpValueArray, index: c_int) -> *mut *mut gegl::GeglColor;
    pub fn gimp_value_array_get_core_object_array(value_array: *const GimpValueArray, index: c_int) -> *mut *mut gobject::GObject;
    pub fn gimp_value_array_index(value_array: *const GimpValueArray, index: c_int) -> *mut gobject::GValue;
    pub fn gimp_value_array_insert(value_array: *mut GimpValueArray, index: c_int, value: *const gobject::GValue) -> *mut GimpValueArray;
    pub fn gimp_value_array_length(value_array: *const GimpValueArray) -> c_int;
    pub fn gimp_value_array_prepend(value_array: *mut GimpValueArray, value: *const gobject::GValue) -> *mut GimpValueArray;
    pub fn gimp_value_array_ref(value_array: *mut GimpValueArray) -> *mut GimpValueArray;
    pub fn gimp_value_array_remove(value_array: *mut GimpValueArray, index: c_int) -> *mut GimpValueArray;
    pub fn gimp_value_array_truncate(value_array: *mut GimpValueArray, n_values: c_int);
    pub fn gimp_value_array_unref(value_array: *mut GimpValueArray);

    //=========================================================================
    // GimpVector2
    //=========================================================================
    pub fn gimp_vector2_get_type() -> GType;
    pub fn gimp_vector2_new(x: c_double, y: c_double) -> GimpVector2;
    pub fn gimp_vector2_add_val(vector1: GimpVector2, vector2: GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_cross_product(vector1: *const GimpVector2, vector2: *const GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_cross_product_val(vector1: GimpVector2, vector2: GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_inner_product(vector1: *const GimpVector2, vector2: *const GimpVector2) -> c_double;
    pub fn gimp_vector2_inner_product_val(vector1: GimpVector2, vector2: GimpVector2) -> c_double;
    pub fn gimp_vector2_length(vector: *const GimpVector2) -> c_double;
    pub fn gimp_vector2_length_val(vector: GimpVector2) -> c_double;
    pub fn gimp_vector2_mul(vector: *mut GimpVector2, factor: c_double);
    pub fn gimp_vector2_mul_val(vector: GimpVector2, factor: c_double) -> GimpVector2;
    pub fn gimp_vector2_neg(vector: *mut GimpVector2);
    pub fn gimp_vector2_neg_val(vector: GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_normal(vector: *mut GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_normal_val(vector: GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_normalize(vector: *mut GimpVector2);
    pub fn gimp_vector2_normalize_val(vector: GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_rotate(vector: *mut GimpVector2, alpha: c_double);
    pub fn gimp_vector2_rotate_val(vector: GimpVector2, alpha: c_double) -> GimpVector2;
    pub fn gimp_vector2_set(vector: *mut GimpVector2, x: c_double, y: c_double);
    pub fn gimp_vector2_sub_val(vector1: GimpVector2, vector2: GimpVector2) -> GimpVector2;
    pub fn gimp_vector2_add(result: *mut GimpVector2, vector1: *const GimpVector2, vector2: *const GimpVector2);
    pub fn gimp_vector2_sub(result: *mut GimpVector2, vector1: *const GimpVector2, vector2: *const GimpVector2);

    //=========================================================================
    // GimpVector3
    //=========================================================================
    pub fn gimp_vector3_get_type() -> GType;
    pub fn gimp_vector3_new(x: c_double, y: c_double, z: c_double) -> GimpVector3;
    pub fn gimp_vector3_add_val(vector1: GimpVector3, vector2: GimpVector3) -> GimpVector3;
    pub fn gimp_vector3_cross_product(vector1: *const GimpVector3, vector2: *const GimpVector3) -> GimpVector3;
    pub fn gimp_vector3_cross_product_val(vector1: GimpVector3, vector2: GimpVector3) -> GimpVector3;
    pub fn gimp_vector3_inner_product(vector1: *const GimpVector3, vector2: *const GimpVector3) -> c_double;
    pub fn gimp_vector3_inner_product_val(vector1: GimpVector3, vector2: GimpVector3) -> c_double;
    pub fn gimp_vector3_length(vector: *const GimpVector3) -> c_double;
    pub fn gimp_vector3_length_val(vector: GimpVector3) -> c_double;
    pub fn gimp_vector3_mul(vector: *mut GimpVector3, factor: c_double);
    pub fn gimp_vector3_mul_val(vector: GimpVector3, factor: c_double) -> GimpVector3;
    pub fn gimp_vector3_neg(vector: *mut GimpVector3);
    pub fn gimp_vector3_neg_val(vector: GimpVector3) -> GimpVector3;
    pub fn gimp_vector3_normalize(vector: *mut GimpVector3);
    pub fn gimp_vector3_normalize_val(vector: GimpVector3) -> GimpVector3;
    pub fn gimp_vector3_rotate(vector: *mut GimpVector3, alpha: c_double, beta: c_double, gamma: c_double);
    pub fn gimp_vector3_rotate_val(vector: GimpVector3, alpha: c_double, beta: c_double, gamma: c_double) -> GimpVector3;
    pub fn gimp_vector3_set(vector: *mut GimpVector3, x: c_double, y: c_double, z: c_double);
    pub fn gimp_vector3_sub_val(vector1: GimpVector3, vector2: GimpVector3) -> GimpVector3;
    pub fn gimp_vector3_add(result: *mut GimpVector3, vector1: *const GimpVector3, vector2: *const GimpVector3);
    pub fn gimp_vector3_sub(result: *mut GimpVector3, vector1: *const GimpVector3, vector2: *const GimpVector3);

    //=========================================================================
    // GimpBatchProcedure
    //=========================================================================
    pub fn gimp_batch_procedure_get_type() -> GType;
    pub fn gimp_batch_procedure_new(plug_in: *mut GimpPlugIn, name: *const c_char, interpreter_name: *const c_char, proc_type: GimpPDBProcType, run_func: GimpBatchFunc, run_data: gpointer, run_data_destroy: glib::GDestroyNotify) -> *mut GimpProcedure;
    pub fn gimp_batch_procedure_get_interpreter_name(procedure: *mut GimpBatchProcedure) -> *const c_char;
    pub fn gimp_batch_procedure_set_interpreter_name(procedure: *mut GimpBatchProcedure, interpreter_name: *const c_char);

    //=========================================================================
    // GimpBrush
    //=========================================================================
    pub fn gimp_brush_get_type() -> GType;
    pub fn gimp_brush_new(name: *const c_char) -> *mut GimpBrush;
    pub fn gimp_brush_get_by_name(name: *const c_char) -> *mut GimpBrush;
    pub fn gimp_brush_get_angle(brush: *mut GimpBrush, angle: *mut c_double) -> gboolean;
    pub fn gimp_brush_get_aspect_ratio(brush: *mut GimpBrush, aspect_ratio: *mut c_double) -> gboolean;
    pub fn gimp_brush_get_buffer(brush: *mut GimpBrush, max_width: c_int, max_height: c_int, format: *const babl::Babl) -> *mut gegl::GeglBuffer;
    pub fn gimp_brush_get_hardness(brush: *mut GimpBrush, hardness: *mut c_double) -> gboolean;
    pub fn gimp_brush_get_info(brush: *mut GimpBrush, width: *mut c_int, height: *mut c_int, mask_bpp: *mut c_int, color_bpp: *mut c_int) -> gboolean;
    pub fn gimp_brush_get_mask(brush: *mut GimpBrush, max_width: c_int, max_height: c_int, format: *const babl::Babl) -> *mut gegl::GeglBuffer;
    pub fn gimp_brush_get_radius(brush: *mut GimpBrush, radius: *mut c_double) -> gboolean;
    pub fn gimp_brush_get_shape(brush: *mut GimpBrush, shape: *mut GimpBrushGeneratedShape) -> gboolean;
    pub fn gimp_brush_get_spacing(brush: *mut GimpBrush) -> c_int;
    pub fn gimp_brush_get_spikes(brush: *mut GimpBrush, spikes: *mut c_int) -> gboolean;
    pub fn gimp_brush_is_generated(brush: *mut GimpBrush) -> gboolean;
    pub fn gimp_brush_set_angle(brush: *mut GimpBrush, angle_in: c_double, angle_out: *mut c_double) -> gboolean;
    pub fn gimp_brush_set_aspect_ratio(brush: *mut GimpBrush, aspect_ratio_in: c_double, aspect_ratio_out: *mut c_double) -> gboolean;
    pub fn gimp_brush_set_hardness(brush: *mut GimpBrush, hardness_in: c_double, hardness_out: *mut c_double) -> gboolean;
    pub fn gimp_brush_set_radius(brush: *mut GimpBrush, radius_in: c_double, radius_out: *mut c_double) -> gboolean;
    pub fn gimp_brush_set_shape(brush: *mut GimpBrush, shape_in: GimpBrushGeneratedShape, shape_out: *mut GimpBrushGeneratedShape) -> gboolean;
    pub fn gimp_brush_set_spacing(brush: *mut GimpBrush, spacing: c_int) -> gboolean;
    pub fn gimp_brush_set_spikes(brush: *mut GimpBrush, spikes_in: c_int, spikes_out: *mut c_int) -> gboolean;

    //=========================================================================
    // GimpChannel
    //=========================================================================
    pub fn gimp_channel_get_type() -> GType;
    pub fn gimp_channel_new(image: *mut GimpImage, name: *const c_char, width: c_int, height: c_int, opacity: c_double, color: *mut gegl::GeglColor) -> *mut GimpChannel;
    pub fn gimp_channel_new_from_component(image: *mut GimpImage, component: GimpChannelType, name: *const c_char) -> *mut GimpChannel;
    pub fn gimp_channel_get_by_id(channel_id: i32) -> *mut GimpChannel;
    pub fn gimp_channel_combine_masks(channel1: *mut GimpChannel, channel2: *mut GimpChannel, operation: GimpChannelOps, offx: c_int, offy: c_int) -> gboolean;
    pub fn gimp_channel_copy(channel: *mut GimpChannel) -> *mut GimpChannel;
    pub fn gimp_channel_get_color(channel: *mut GimpChannel) -> *mut gegl::GeglColor;
    pub fn gimp_channel_get_opacity(channel: *mut GimpChannel) -> c_double;
    pub fn gimp_channel_get_show_masked(channel: *mut GimpChannel) -> gboolean;
    pub fn gimp_channel_set_color(channel: *mut GimpChannel, color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_channel_set_opacity(channel: *mut GimpChannel, opacity: c_double) -> gboolean;
    pub fn gimp_channel_set_show_masked(channel: *mut GimpChannel, show_masked: gboolean) -> gboolean;

    //=========================================================================
    // GimpChoice
    //=========================================================================
    pub fn gimp_choice_get_type() -> GType;
    pub fn gimp_choice_new() -> *mut GimpChoice;
    pub fn gimp_choice_new_with_values(nick: *const c_char, id: c_int, label: *const c_char, help: *const c_char, ...) -> *mut GimpChoice;
    pub fn gimp_choice_add(choice: *mut GimpChoice, nick: *const c_char, id: c_int, label: *const c_char, help: *const c_char);
    pub fn gimp_choice_get_documentation(choice: *mut GimpChoice, nick: *const c_char, label: *mut *const c_char, help: *mut *const c_char) -> gboolean;
    pub fn gimp_choice_get_help(choice: *mut GimpChoice, nick: *const c_char) -> *const c_char;
    pub fn gimp_choice_get_id(choice: *mut GimpChoice, nick: *const c_char) -> c_int;
    pub fn gimp_choice_get_label(choice: *mut GimpChoice, nick: *const c_char) -> *const c_char;
    pub fn gimp_choice_is_valid(choice: *mut GimpChoice, nick: *const c_char) -> gboolean;
    pub fn gimp_choice_list_nicks(choice: *mut GimpChoice) -> *mut glib::GList;
    pub fn gimp_choice_set_sensitive(choice: *mut GimpChoice, nick: *const c_char, sensitive: gboolean);

    //=========================================================================
    // GimpColorConfig
    //=========================================================================
    pub fn gimp_color_config_get_type() -> GType;
    pub fn gimp_color_config_get_cmyk_color_profile(config: *mut GimpColorConfig, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_config_get_display_bpc(config: *mut GimpColorConfig) -> gboolean;
    pub fn gimp_color_config_get_display_color_profile(config: *mut GimpColorConfig, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_config_get_display_intent(config: *mut GimpColorConfig) -> GimpColorRenderingIntent;
    pub fn gimp_color_config_get_display_optimize(config: *mut GimpColorConfig) -> gboolean;
    pub fn gimp_color_config_get_display_profile_from_gdk(config: *mut GimpColorConfig) -> gboolean;
    pub fn gimp_color_config_get_gray_color_profile(config: *mut GimpColorConfig, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_config_get_mode(config: *mut GimpColorConfig) -> GimpColorManagementMode;
    pub fn gimp_color_config_get_out_of_gamut_color(config: *mut GimpColorConfig) -> *mut gegl::GeglColor;
    pub fn gimp_color_config_get_rgb_color_profile(config: *mut GimpColorConfig, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_config_get_simulation_bpc(config: *mut GimpColorConfig) -> gboolean;
    pub fn gimp_color_config_get_simulation_color_profile(config: *mut GimpColorConfig, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_config_get_simulation_gamut_check(config: *mut GimpColorConfig) -> gboolean;
    pub fn gimp_color_config_get_simulation_intent(config: *mut GimpColorConfig) -> GimpColorRenderingIntent;
    pub fn gimp_color_config_get_simulation_optimize(config: *mut GimpColorConfig) -> gboolean;

    //=========================================================================
    // GimpColorProfile
    //=========================================================================
    pub fn gimp_color_profile_get_type() -> GType;
    pub fn gimp_color_profile_new_d50_gray_lab_trc() -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_d65_gray_linear() -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_d65_gray_srgb_trc() -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_from_file(file: *mut gio::GFile, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_from_icc_profile(data: *const u8, length: size_t, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_from_lcms_profile(lcms_profile: gpointer, error: *mut *mut glib::GError) -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_rgb_adobe() -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_rgb_srgb() -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_rgb_srgb_linear() -> *mut GimpColorProfile;
    pub fn gimp_color_profile_get_lcms_format(format: *const babl::Babl, lcms_format: *mut u32) -> *const babl::Babl;
    pub fn gimp_color_profile_get_copyright(profile: *mut GimpColorProfile) -> *const c_char;
    pub fn gimp_color_profile_get_description(profile: *mut GimpColorProfile) -> *const c_char;
    pub fn gimp_color_profile_get_format(profile: *mut GimpColorProfile, format: *const babl::Babl, intent: GimpColorRenderingIntent, error: *mut *mut glib::GError) -> *const babl::Babl;
    pub fn gimp_color_profile_get_icc_profile(profile: *mut GimpColorProfile, length: *mut size_t) -> *const u8;
    pub fn gimp_color_profile_get_label(profile: *mut GimpColorProfile) -> *const c_char;
    pub fn gimp_color_profile_get_lcms_profile(profile: *mut GimpColorProfile) -> gpointer;
    pub fn gimp_color_profile_get_manufacturer(profile: *mut GimpColorProfile) -> *const c_char;
    pub fn gimp_color_profile_get_model(profile: *mut GimpColorProfile) -> *const c_char;
    pub fn gimp_color_profile_get_space(profile: *mut GimpColorProfile, intent: GimpColorRenderingIntent, error: *mut *mut glib::GError) -> *const babl::Babl;
    pub fn gimp_color_profile_get_summary(profile: *mut GimpColorProfile) -> *const c_char;
    pub fn gimp_color_profile_is_cmyk(profile: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_color_profile_is_equal(profile1: *mut GimpColorProfile, profile2: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_color_profile_is_gray(profile: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_color_profile_is_linear(profile: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_color_profile_is_rgb(profile: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_color_profile_new_linear_from_color_profile(profile: *mut GimpColorProfile) -> *mut GimpColorProfile;
    pub fn gimp_color_profile_new_srgb_trc_from_color_profile(profile: *mut GimpColorProfile) -> *mut GimpColorProfile;
    pub fn gimp_color_profile_save_to_file(profile: *mut GimpColorProfile, file: *mut gio::GFile, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GimpColorTransform
    //=========================================================================
    pub fn gimp_color_transform_get_type() -> GType;
    pub fn gimp_color_transform_new(src_profile: *mut GimpColorProfile, src_format: *const babl::Babl, dest_profile: *mut GimpColorProfile, dest_format: *const babl::Babl, rendering_intent: GimpColorRenderingIntent, flags: GimpColorTransformFlags) -> *mut GimpColorTransform;
    pub fn gimp_color_transform_new_proofing(src_profile: *mut GimpColorProfile, src_format: *const babl::Babl, dest_profile: *mut GimpColorProfile, dest_format: *const babl::Babl, proof_profile: *mut GimpColorProfile, proof_intent: GimpColorRenderingIntent, display_intent: GimpColorRenderingIntent, flags: GimpColorTransformFlags) -> *mut GimpColorTransform;
    pub fn gimp_color_transform_can_gegl_copy(src_profile: *mut GimpColorProfile, dest_profile: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_color_transform_process_buffer(transform: *mut GimpColorTransform, src_buffer: *mut gegl::GeglBuffer, src_rect: *const gegl::GeglRectangle, dest_buffer: *mut gegl::GeglBuffer, dest_rect: *const gegl::GeglRectangle);
    pub fn gimp_color_transform_process_pixels(transform: *mut GimpColorTransform, src_format: *const babl::Babl, src_pixels: gconstpointer, dest_format: *const babl::Babl, dest_pixels: gpointer, length: size_t);

    //=========================================================================
    // GimpConfigPath
    //=========================================================================
    pub fn gimp_config_path_get_type() -> GType;
    pub fn gimp_config_path_expand(path: *const c_char, recode: gboolean, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn gimp_config_path_expand_to_files(path: *const c_char, error: *mut *mut glib::GError) -> *mut glib::GList;
    pub fn gimp_config_path_unexpand(path: *const c_char, recode: gboolean, error: *mut *mut glib::GError) -> *mut c_char;

    //=========================================================================
    // GimpDisplay
    //=========================================================================
    pub fn gimp_display_get_type() -> GType;
    pub fn gimp_display_new(image: *mut GimpImage) -> *mut GimpDisplay;
    pub fn gimp_display_get_by_id(display_id: i32) -> *mut GimpDisplay;
    pub fn gimp_display_id_is_valid(display_id: c_int) -> gboolean;
    pub fn gimp_display_name() -> *const c_char;
    pub fn gimp_display_delete(display: *mut GimpDisplay) -> gboolean;
    pub fn gimp_display_get_id(display: *mut GimpDisplay) -> i32;
    pub fn gimp_display_get_window_handle(display: *mut GimpDisplay) -> *mut glib::GBytes;
    pub fn gimp_display_is_valid(display: *mut GimpDisplay) -> gboolean;
    pub fn gimp_display_present(display: *mut GimpDisplay) -> gboolean;

    //=========================================================================
    // GimpDrawable
    //=========================================================================
    pub fn gimp_drawable_get_type() -> GType;
    pub fn gimp_drawable_get_by_id(drawable_id: i32) -> *mut GimpDrawable;
    pub fn gimp_drawable_append_filter(drawable: *mut GimpDrawable, filter: *mut GimpDrawableFilter);
    pub fn gimp_drawable_append_new_filter(drawable: *mut GimpDrawable, operation_name: *const c_char, name: *const c_char, mode: GimpLayerMode, opacity: c_double, ...) -> *mut GimpDrawableFilter;
    pub fn gimp_drawable_brightness_contrast(drawable: *mut GimpDrawable, brightness: c_double, contrast: c_double) -> gboolean;
    pub fn gimp_drawable_color_balance(drawable: *mut GimpDrawable, transfer_mode: GimpTransferMode, preserve_lum: gboolean, cyan_red: c_double, magenta_green: c_double, yellow_blue: c_double) -> gboolean;
    pub fn gimp_drawable_colorize_hsl(drawable: *mut GimpDrawable, hue: c_double, saturation: c_double, lightness: c_double) -> gboolean;
    pub fn gimp_drawable_curves_explicit(drawable: *mut GimpDrawable, channel: GimpHistogramChannel, num_values: size_t, values: *const c_double) -> gboolean;
    pub fn gimp_drawable_curves_spline(drawable: *mut GimpDrawable, channel: GimpHistogramChannel, num_points: size_t, points: *const c_double) -> gboolean;
    pub fn gimp_drawable_desaturate(drawable: *mut GimpDrawable, desaturate_mode: GimpDesaturateMode) -> gboolean;
    pub fn gimp_drawable_edit_bucket_fill(drawable: *mut GimpDrawable, fill_type: GimpFillType, x: c_double, y: c_double) -> gboolean;
    pub fn gimp_drawable_edit_clear(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_edit_fill(drawable: *mut GimpDrawable, fill_type: GimpFillType) -> gboolean;
    pub fn gimp_drawable_edit_gradient_fill(drawable: *mut GimpDrawable, gradient_type: GimpGradientType, offset: c_double, supersample: gboolean, supersample_max_depth: c_int, supersample_threshold: c_double, dither: gboolean, x1: c_double, y1: c_double, x2: c_double, y2: c_double) -> gboolean;
    pub fn gimp_drawable_edit_stroke_item(drawable: *mut GimpDrawable, item: *mut GimpItem) -> gboolean;
    pub fn gimp_drawable_edit_stroke_selection(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_equalize(drawable: *mut GimpDrawable, mask_only: gboolean) -> gboolean;
    pub fn gimp_drawable_extract_component(drawable: *mut GimpDrawable, component: c_int, invert: gboolean, linear: gboolean) -> gboolean;
    pub fn gimp_drawable_fill(drawable: *mut GimpDrawable, fill_type: GimpFillType) -> gboolean;
    pub fn gimp_drawable_foreground_extract(drawable: *mut GimpDrawable, mode: GimpForegroundExtractMode, mask: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_free_shadow(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_get_bpp(drawable: *mut GimpDrawable) -> c_int;
    pub fn gimp_drawable_get_buffer(drawable: *mut GimpDrawable) -> *mut gegl::GeglBuffer;
    pub fn gimp_drawable_get_filters(drawable: *mut GimpDrawable) -> *mut *mut GimpDrawableFilter;
    pub fn gimp_drawable_get_format(drawable: *mut GimpDrawable) -> *const babl::Babl;
    pub fn gimp_drawable_get_height(drawable: *mut GimpDrawable) -> c_int;
    pub fn gimp_drawable_get_offsets(drawable: *mut GimpDrawable, offset_x: *mut c_int, offset_y: *mut c_int) -> gboolean;
    pub fn gimp_drawable_get_pixel(drawable: *mut GimpDrawable, x_coord: c_int, y_coord: c_int) -> *mut gegl::GeglColor;
    pub fn gimp_drawable_get_shadow_buffer(drawable: *mut GimpDrawable) -> *mut gegl::GeglBuffer;
    pub fn gimp_drawable_get_sub_thumbnail(drawable: *mut GimpDrawable, src_x: c_int, src_y: c_int, src_width: c_int, src_height: c_int, dest_width: c_int, dest_height: c_int, alpha: GimpPixbufTransparency) -> *mut gdk_pixbuf::GdkPixbuf;
    pub fn gimp_drawable_get_sub_thumbnail_data(drawable: *mut GimpDrawable, src_x: c_int, src_y: c_int, src_width: c_int, src_height: c_int, dest_width: c_int, dest_height: c_int, actual_width: *mut c_int, actual_height: *mut c_int, bpp: *mut c_int) -> *mut glib::GBytes;
    pub fn gimp_drawable_get_thumbnail(drawable: *mut GimpDrawable, width: c_int, height: c_int, alpha: GimpPixbufTransparency) -> *mut gdk_pixbuf::GdkPixbuf;
    pub fn gimp_drawable_get_thumbnail_data(drawable: *mut GimpDrawable, width: c_int, height: c_int, actual_width: *mut c_int, actual_height: *mut c_int, bpp: *mut c_int) -> *mut glib::GBytes;
    pub fn gimp_drawable_get_thumbnail_format(drawable: *mut GimpDrawable) -> *const babl::Babl;
    pub fn gimp_drawable_get_width(drawable: *mut GimpDrawable) -> c_int;
    pub fn gimp_drawable_has_alpha(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_histogram(drawable: *mut GimpDrawable, channel: GimpHistogramChannel, start_range: c_double, end_range: c_double, mean: *mut c_double, std_dev: *mut c_double, median: *mut c_double, pixels: *mut c_double, count: *mut c_double, percentile: *mut c_double) -> gboolean;
    pub fn gimp_drawable_hue_saturation(drawable: *mut GimpDrawable, hue_range: GimpHueRange, hue_offset: c_double, lightness: c_double, saturation: c_double, overlap: c_double) -> gboolean;
    pub fn gimp_drawable_invert(drawable: *mut GimpDrawable, linear: gboolean) -> gboolean;
    pub fn gimp_drawable_is_gray(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_is_indexed(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_is_rgb(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_levels(drawable: *mut GimpDrawable, channel: GimpHistogramChannel, low_input: c_double, high_input: c_double, clamp_input: gboolean, gamma: c_double, low_output: c_double, high_output: c_double, clamp_output: gboolean) -> gboolean;
    pub fn gimp_drawable_levels_stretch(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_mask_bounds(drawable: *mut GimpDrawable, x1: *mut c_int, y1: *mut c_int, x2: *mut c_int, y2: *mut c_int) -> gboolean;
    pub fn gimp_drawable_mask_intersect(drawable: *mut GimpDrawable, x: *mut c_int, y: *mut c_int, width: *mut c_int, height: *mut c_int) -> gboolean;
    pub fn gimp_drawable_merge_filter(drawable: *mut GimpDrawable, filter: *mut GimpDrawableFilter);
    pub fn gimp_drawable_merge_filters(drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_drawable_merge_new_filter(drawable: *mut GimpDrawable, operation_name: *const c_char, name: *const c_char, mode: GimpLayerMode, opacity: c_double, ...);
    pub fn gimp_drawable_merge_shadow(drawable: *mut GimpDrawable, undo: gboolean) -> gboolean;
    pub fn gimp_drawable_offset(drawable: *mut GimpDrawable, wrap_around: gboolean, fill_type: GimpOffsetType, color: *mut gegl::GeglColor, offset_x: c_int, offset_y: c_int) -> gboolean;
    pub fn gimp_drawable_posterize(drawable: *mut GimpDrawable, levels: c_int) -> gboolean;
    pub fn gimp_drawable_set_pixel(drawable: *mut GimpDrawable, x_coord: c_int, y_coord: c_int, color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_drawable_shadows_highlights(drawable: *mut GimpDrawable, shadows: c_double, highlights: c_double, whitepoint: c_double, radius: c_double, compress: c_double, shadows_ccorrect: c_double, highlights_ccorrect: c_double) -> gboolean;
    pub fn gimp_drawable_threshold(drawable: *mut GimpDrawable, channel: GimpHistogramChannel, low_threshold: c_double, high_threshold: c_double) -> gboolean;
    pub fn gimp_drawable_type(drawable: *mut GimpDrawable) -> GimpImageType;
    pub fn gimp_drawable_type_with_alpha(drawable: *mut GimpDrawable) -> GimpImageType;
    pub fn gimp_drawable_update(drawable: *mut GimpDrawable, x: c_int, y: c_int, width: c_int, height: c_int) -> gboolean;

    //=========================================================================
    // GimpDrawableFilter
    //=========================================================================
    pub fn gimp_drawable_filter_get_type() -> GType;
    pub fn gimp_drawable_filter_new(drawable: *mut GimpDrawable, operation_name: *const c_char, name: *const c_char) -> *mut GimpDrawableFilter;
    pub fn gimp_drawable_filter_get_by_id(filter_id: i32) -> *mut GimpDrawableFilter;
    pub fn gimp_drawable_filter_id_is_valid(filter_id: c_int) -> gboolean;
    pub fn gimp_drawable_filter_delete(filter: *mut GimpDrawableFilter) -> gboolean;
    pub fn gimp_drawable_filter_get_blend_mode(filter: *mut GimpDrawableFilter) -> GimpLayerMode;
    pub fn gimp_drawable_filter_get_config(filter: *mut GimpDrawableFilter) -> *mut GimpDrawableFilterConfig;
    pub fn gimp_drawable_filter_get_id(filter: *mut GimpDrawableFilter) -> i32;
    pub fn gimp_drawable_filter_get_name(filter: *mut GimpDrawableFilter) -> *mut c_char;
    pub fn gimp_drawable_filter_get_opacity(filter: *mut GimpDrawableFilter) -> c_double;
    pub fn gimp_drawable_filter_get_operation_name(filter: *mut GimpDrawableFilter) -> *mut c_char;
    pub fn gimp_drawable_filter_get_visible(filter: *mut GimpDrawableFilter) -> gboolean;
    pub fn gimp_drawable_filter_is_valid(filter: *mut GimpDrawableFilter) -> gboolean;
    pub fn gimp_drawable_filter_set_aux_input(filter: *mut GimpDrawableFilter, input_pad_name: *const c_char, input: *mut GimpDrawable);
    pub fn gimp_drawable_filter_set_blend_mode(filter: *mut GimpDrawableFilter, mode: GimpLayerMode);
    pub fn gimp_drawable_filter_set_opacity(filter: *mut GimpDrawableFilter, opacity: c_double);
    pub fn gimp_drawable_filter_set_visible(filter: *mut GimpDrawableFilter, visible: gboolean) -> gboolean;
    pub fn gimp_drawable_filter_update(filter: *mut GimpDrawableFilter);

    //=========================================================================
    // GimpDrawableFilterConfig
    //=========================================================================
    pub fn gimp_drawable_filter_config_get_type() -> GType;

    //=========================================================================
    // GimpExportOptions
    //=========================================================================
    pub fn gimp_export_options_get_type() -> GType;
    pub fn gimp_export_options_get_image(options: *mut GimpExportOptions, image: *mut *mut GimpImage) -> GimpExportReturn;

    //=========================================================================
    // GimpExportProcedure
    //=========================================================================
    pub fn gimp_export_procedure_get_type() -> GType;
    pub fn gimp_export_procedure_new(plug_in: *mut GimpPlugIn, name: *const c_char, proc_type: GimpPDBProcType, export_metadata: gboolean, run_func: GimpRunExportFunc, run_data: gpointer, run_data_destroy: glib::GDestroyNotify) -> *mut GimpProcedure;
    pub fn gimp_export_procedure_get_support_comment(procedure: *mut GimpExportProcedure) -> gboolean;
    pub fn gimp_export_procedure_get_support_exif(procedure: *mut GimpExportProcedure) -> gboolean;
    pub fn gimp_export_procedure_get_support_iptc(procedure: *mut GimpExportProcedure) -> gboolean;
    pub fn gimp_export_procedure_get_support_profile(procedure: *mut GimpExportProcedure) -> gboolean;
    pub fn gimp_export_procedure_get_support_thumbnail(procedure: *mut GimpExportProcedure) -> gboolean;
    pub fn gimp_export_procedure_get_support_xmp(procedure: *mut GimpExportProcedure) -> gboolean;
    pub fn gimp_export_procedure_set_capabilities(procedure: *mut GimpExportProcedure, capabilities: GimpExportCapabilities, get_capabilities_func: GimpExportGetCapabilitiesFunc, get_capabilities_data: gpointer, get_capabilities_data_destroy: glib::GDestroyNotify);
    pub fn gimp_export_procedure_set_support_comment(procedure: *mut GimpExportProcedure, supports: gboolean);
    pub fn gimp_export_procedure_set_support_exif(procedure: *mut GimpExportProcedure, supports: gboolean);
    pub fn gimp_export_procedure_set_support_iptc(procedure: *mut GimpExportProcedure, supports: gboolean);
    pub fn gimp_export_procedure_set_support_profile(procedure: *mut GimpExportProcedure, supports: gboolean);
    pub fn gimp_export_procedure_set_support_thumbnail(procedure: *mut GimpExportProcedure, supports: gboolean);
    pub fn gimp_export_procedure_set_support_xmp(procedure: *mut GimpExportProcedure, supports: gboolean);

    //=========================================================================
    // GimpFileProcedure
    //=========================================================================
    pub fn gimp_file_procedure_get_type() -> GType;
    pub fn gimp_file_procedure_get_extensions(procedure: *mut GimpFileProcedure) -> *const c_char;
    pub fn gimp_file_procedure_get_format_name(procedure: *mut GimpFileProcedure) -> *const c_char;
    pub fn gimp_file_procedure_get_handles_remote(procedure: *mut GimpFileProcedure) -> gboolean;
    pub fn gimp_file_procedure_get_magics(procedure: *mut GimpFileProcedure) -> *const c_char;
    pub fn gimp_file_procedure_get_mime_types(procedure: *mut GimpFileProcedure) -> *const c_char;
    pub fn gimp_file_procedure_get_prefixes(procedure: *mut GimpFileProcedure) -> *const c_char;
    pub fn gimp_file_procedure_get_priority(procedure: *mut GimpFileProcedure) -> c_int;
    pub fn gimp_file_procedure_set_extensions(procedure: *mut GimpFileProcedure, extensions: *const c_char);
    pub fn gimp_file_procedure_set_format_name(procedure: *mut GimpFileProcedure, format_name: *const c_char);
    pub fn gimp_file_procedure_set_handles_remote(procedure: *mut GimpFileProcedure, handles_remote: gboolean);
    pub fn gimp_file_procedure_set_magics(procedure: *mut GimpFileProcedure, magics: *const c_char);
    pub fn gimp_file_procedure_set_mime_types(procedure: *mut GimpFileProcedure, mime_types: *const c_char);
    pub fn gimp_file_procedure_set_prefixes(procedure: *mut GimpFileProcedure, prefixes: *const c_char);
    pub fn gimp_file_procedure_set_priority(procedure: *mut GimpFileProcedure, priority: c_int);

    //=========================================================================
    // GimpFont
    //=========================================================================
    pub fn gimp_font_get_type() -> GType;
    pub fn gimp_font_get_by_name(name: *const c_char) -> *mut GimpFont;
    pub fn gimp_font_get_pango_font_description(font: *mut GimpFont) -> *mut pango::PangoFontDescription;

    //=========================================================================
    // GimpGradient
    //=========================================================================
    pub fn gimp_gradient_get_type() -> GType;
    pub fn gimp_gradient_new(name: *const c_char) -> *mut GimpGradient;
    pub fn gimp_gradient_get_by_name(name: *const c_char) -> *mut GimpGradient;
    pub fn gimp_gradient_get_custom_samples(gradient: *mut GimpGradient, num_samples: size_t, positions: *const c_double, reverse: gboolean) -> *mut *mut gegl::GeglColor;
    pub fn gimp_gradient_get_number_of_segments(gradient: *mut GimpGradient) -> c_int;
    pub fn gimp_gradient_get_uniform_samples(gradient: *mut GimpGradient, num_samples: c_int, reverse: gboolean) -> *mut *mut gegl::GeglColor;
    pub fn gimp_gradient_segment_get_blending_function(gradient: *mut GimpGradient, segment: c_int, blend_func: *mut GimpGradientSegmentType) -> gboolean;
    pub fn gimp_gradient_segment_get_coloring_type(gradient: *mut GimpGradient, segment: c_int, coloring_type: *mut GimpGradientSegmentColor) -> gboolean;
    pub fn gimp_gradient_segment_get_left_color(gradient: *mut GimpGradient, segment: c_int) -> *mut gegl::GeglColor;
    pub fn gimp_gradient_segment_get_left_pos(gradient: *mut GimpGradient, segment: c_int, pos: *mut c_double) -> gboolean;
    pub fn gimp_gradient_segment_get_middle_pos(gradient: *mut GimpGradient, segment: c_int, pos: *mut c_double) -> gboolean;
    pub fn gimp_gradient_segment_get_right_color(gradient: *mut GimpGradient, segment: c_int) -> *mut gegl::GeglColor;
    pub fn gimp_gradient_segment_get_right_pos(gradient: *mut GimpGradient, segment: c_int, pos: *mut c_double) -> gboolean;
    pub fn gimp_gradient_segment_range_blend_colors(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int) -> gboolean;
    pub fn gimp_gradient_segment_range_blend_opacity(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int) -> gboolean;
    pub fn gimp_gradient_segment_range_delete(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int) -> gboolean;
    pub fn gimp_gradient_segment_range_flip(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int) -> gboolean;
    pub fn gimp_gradient_segment_range_move(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int, delta: c_double, control_compress: gboolean) -> c_double;
    pub fn gimp_gradient_segment_range_redistribute_handles(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int) -> gboolean;
    pub fn gimp_gradient_segment_range_replicate(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int, replicate_times: c_int) -> gboolean;
    pub fn gimp_gradient_segment_range_set_blending_function(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int, blending_function: GimpGradientSegmentType) -> gboolean;
    pub fn gimp_gradient_segment_range_set_coloring_type(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int, coloring_type: GimpGradientSegmentColor) -> gboolean;
    pub fn gimp_gradient_segment_range_split_midpoint(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int) -> gboolean;
    pub fn gimp_gradient_segment_range_split_uniform(gradient: *mut GimpGradient, start_segment: c_int, end_segment: c_int, split_parts: c_int) -> gboolean;
    pub fn gimp_gradient_segment_set_left_color(gradient: *mut GimpGradient, segment: c_int, color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_gradient_segment_set_left_pos(gradient: *mut GimpGradient, segment: c_int, pos: c_double, final_pos: *mut c_double) -> gboolean;
    pub fn gimp_gradient_segment_set_middle_pos(gradient: *mut GimpGradient, segment: c_int, pos: c_double, final_pos: *mut c_double) -> gboolean;
    pub fn gimp_gradient_segment_set_right_color(gradient: *mut GimpGradient, segment: c_int, color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_gradient_segment_set_right_pos(gradient: *mut GimpGradient, segment: c_int, pos: c_double, final_pos: *mut c_double) -> gboolean;

    //=========================================================================
    // GimpGroupLayer
    //=========================================================================
    pub fn gimp_group_layer_get_type() -> GType;
    pub fn gimp_group_layer_new(image: *mut GimpImage, name: *const c_char) -> *mut GimpGroupLayer;
    pub fn gimp_group_layer_get_by_id(layer_id: i32) -> *mut GimpGroupLayer;
    pub fn gimp_group_layer_merge(group_layer: *mut GimpGroupLayer) -> *mut GimpLayer;

    //=========================================================================
    // GimpImage
    //=========================================================================
    pub fn gimp_image_get_type() -> GType;
    pub fn gimp_image_new(width: c_int, height: c_int, type_: GimpImageBaseType) -> *mut GimpImage;
    pub fn gimp_image_new_with_precision(width: c_int, height: c_int, type_: GimpImageBaseType, precision: GimpPrecision) -> *mut GimpImage;
    pub fn gimp_image_convert_set_dither_matrix(width: c_int, height: c_int, matrix: *mut glib::GBytes) -> gboolean;
    pub fn gimp_image_get_by_id(image_id: i32) -> *mut GimpImage;
    pub fn gimp_image_id_is_valid(image_id: c_int) -> gboolean;
    pub fn gimp_image_metadata_load_thumbnail(file: *mut gio::GFile, error: *mut *mut glib::GError) -> *mut GimpImage;
    pub fn gimp_image_add_hguide(image: *mut GimpImage, yposition: c_int) -> c_uint;
    pub fn gimp_image_add_sample_point(image: *mut GimpImage, position_x: c_int, position_y: c_int) -> c_uint;
    pub fn gimp_image_add_vguide(image: *mut GimpImage, xposition: c_int) -> c_uint;
    pub fn gimp_image_attach_parasite(image: *mut GimpImage, parasite: *const GimpParasite) -> gboolean;
    pub fn gimp_image_clean_all(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_convert_color_profile(image: *mut GimpImage, profile: *mut GimpColorProfile, intent: GimpColorRenderingIntent, bpc: gboolean) -> gboolean;
    pub fn gimp_image_convert_color_profile_from_file(image: *mut GimpImage, file: *mut gio::GFile, intent: GimpColorRenderingIntent, bpc: gboolean) -> gboolean;
    pub fn gimp_image_convert_grayscale(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_convert_indexed(image: *mut GimpImage, dither_type: GimpConvertDitherType, palette_type: GimpConvertPaletteType, num_cols: c_int, alpha_dither: gboolean, remove_unused: gboolean, palette: *const c_char) -> gboolean;
    pub fn gimp_image_convert_precision(image: *mut GimpImage, precision: GimpPrecision) -> gboolean;
    pub fn gimp_image_convert_rgb(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_crop(image: *mut GimpImage, new_width: c_int, new_height: c_int, offx: c_int, offy: c_int) -> gboolean;
    pub fn gimp_image_delete(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_delete_guide(image: *mut GimpImage, guide: c_uint) -> gboolean;
    pub fn gimp_image_delete_sample_point(image: *mut GimpImage, sample_point: c_uint) -> gboolean;
    pub fn gimp_image_detach_parasite(image: *mut GimpImage, name: *const c_char) -> gboolean;
    pub fn gimp_image_duplicate(image: *mut GimpImage) -> *mut GimpImage;
    pub fn gimp_image_export_path_to_file(image: *mut GimpImage, file: *mut gio::GFile, path: *mut GimpPath) -> gboolean;
    pub fn gimp_image_export_path_to_string(image: *mut GimpImage, path: *mut GimpPath) -> *mut c_char;
    pub fn gimp_image_find_next_guide(image: *mut GimpImage, guide: c_int) -> c_uint;
    pub fn gimp_image_find_next_sample_point(image: *mut GimpImage, sample_point: c_uint) -> c_uint;
    pub fn gimp_image_flatten(image: *mut GimpImage) -> *mut GimpLayer;
    pub fn gimp_image_flip(image: *mut GimpImage, flip_type: GimpOrientationType) -> gboolean;
    pub fn gimp_image_floating_sel_attached_to(image: *mut GimpImage) -> *mut GimpDrawable;
    pub fn gimp_image_freeze_channels(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_freeze_layers(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_freeze_paths(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_get_base_type(image: *mut GimpImage) -> GimpImageBaseType;
    pub fn gimp_image_get_channel_by_name(image: *mut GimpImage, name: *const c_char) -> *mut GimpChannel;
    pub fn gimp_image_get_channel_by_tattoo(image: *mut GimpImage, tattoo: c_uint) -> *mut GimpChannel;
    pub fn gimp_image_get_channels(image: *mut GimpImage) -> *mut *mut GimpChannel;
    pub fn gimp_image_get_color_profile(image: *mut GimpImage) -> *mut GimpColorProfile;
    pub fn gimp_image_get_component_active(image: *mut GimpImage, component: GimpChannelType) -> gboolean;
    pub fn gimp_image_get_component_visible(image: *mut GimpImage, component: GimpChannelType) -> gboolean;
    pub fn gimp_image_get_default_new_layer_mode(image: *mut GimpImage) -> GimpLayerMode;
    pub fn gimp_image_get_effective_color_profile(image: *mut GimpImage) -> *mut GimpColorProfile;
    pub fn gimp_image_get_exported_file(image: *mut GimpImage) -> *mut gio::GFile;
    pub fn gimp_image_get_file(image: *mut GimpImage) -> *mut gio::GFile;
    pub fn gimp_image_get_floating_sel(image: *mut GimpImage) -> *mut GimpLayer;
    pub fn gimp_image_get_guide_orientation(image: *mut GimpImage, guide: c_uint) -> GimpOrientationType;
    pub fn gimp_image_get_guide_position(image: *mut GimpImage, guide: c_uint) -> c_int;
    pub fn gimp_image_get_height(image: *mut GimpImage) -> c_int;
    pub fn gimp_image_get_id(image: *mut GimpImage) -> i32;
    pub fn gimp_image_get_imported_file(image: *mut GimpImage) -> *mut gio::GFile;
    pub fn gimp_image_get_item_position(image: *mut GimpImage, item: *mut GimpItem) -> c_int;
    pub fn gimp_image_get_layer_by_name(image: *mut GimpImage, name: *const c_char) -> *mut GimpLayer;
    pub fn gimp_image_get_layer_by_tattoo(image: *mut GimpImage, tattoo: c_uint) -> *mut GimpLayer;
    pub fn gimp_image_get_layers(image: *mut GimpImage) -> *mut *mut GimpLayer;
    pub fn gimp_image_get_metadata(image: *mut GimpImage) -> *mut GimpMetadata;
    pub fn gimp_image_get_name(image: *mut GimpImage) -> *mut c_char;
    pub fn gimp_image_get_palette(image: *mut GimpImage) -> *mut GimpPalette;
    pub fn gimp_image_get_parasite(image: *mut GimpImage, name: *const c_char) -> *mut GimpParasite;
    pub fn gimp_image_get_parasite_list(image: *mut GimpImage) -> *mut *mut c_char;
    pub fn gimp_image_get_path_by_name(image: *mut GimpImage, name: *const c_char) -> *mut GimpPath;
    pub fn gimp_image_get_path_by_tattoo(image: *mut GimpImage, tattoo: c_uint) -> *mut GimpPath;
    pub fn gimp_image_get_paths(image: *mut GimpImage) -> *mut *mut GimpPath;
    pub fn gimp_image_get_precision(image: *mut GimpImage) -> GimpPrecision;
    pub fn gimp_image_get_resolution(image: *mut GimpImage, xresolution: *mut c_double, yresolution: *mut c_double) -> gboolean;
    pub fn gimp_image_get_sample_point_position(image: *mut GimpImage, sample_point: c_uint, position_y: *mut c_int) -> c_int;
    pub fn gimp_image_get_selected_channels(image: *mut GimpImage) -> *mut *mut GimpChannel;
    pub fn gimp_image_get_selected_drawables(image: *mut GimpImage) -> *mut *mut GimpDrawable;
    pub fn gimp_image_get_selected_layers(image: *mut GimpImage) -> *mut *mut GimpLayer;
    pub fn gimp_image_get_selected_paths(image: *mut GimpImage) -> *mut *mut GimpPath;
    pub fn gimp_image_get_selection(image: *mut GimpImage) -> *mut GimpSelection;
    pub fn gimp_image_get_simulation_bpc(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_get_simulation_intent(image: *mut GimpImage) -> GimpColorRenderingIntent;
    pub fn gimp_image_get_simulation_profile(image: *mut GimpImage) -> *mut GimpColorProfile;
    pub fn gimp_image_get_tattoo_state(image: *mut GimpImage) -> c_uint;
    pub fn gimp_image_get_thumbnail(image: *mut GimpImage, width: c_int, height: c_int, alpha: GimpPixbufTransparency) -> *mut gdk_pixbuf::GdkPixbuf;
    pub fn gimp_image_get_thumbnail_data(image: *mut GimpImage, width: *mut c_int, height: *mut c_int, bpp: *mut c_int) -> *mut glib::GBytes;
    pub fn gimp_image_get_unit(image: *mut GimpImage) -> *mut GimpUnit;
    pub fn gimp_image_get_width(image: *mut GimpImage) -> c_int;
    pub fn gimp_image_get_xcf_file(image: *mut GimpImage) -> *mut gio::GFile;
    pub fn gimp_image_grid_get_background_color(image: *mut GimpImage) -> *mut gegl::GeglColor;
    pub fn gimp_image_grid_get_foreground_color(image: *mut GimpImage) -> *mut gegl::GeglColor;
    pub fn gimp_image_grid_get_offset(image: *mut GimpImage, xoffset: *mut c_double, yoffset: *mut c_double) -> gboolean;
    pub fn gimp_image_grid_get_spacing(image: *mut GimpImage, xspacing: *mut c_double, yspacing: *mut c_double) -> gboolean;
    pub fn gimp_image_grid_get_style(image: *mut GimpImage) -> GimpGridStyle;
    pub fn gimp_image_grid_set_background_color(image: *mut GimpImage, bgcolor: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_image_grid_set_foreground_color(image: *mut GimpImage, fgcolor: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_image_grid_set_offset(image: *mut GimpImage, xoffset: c_double, yoffset: c_double) -> gboolean;
    pub fn gimp_image_grid_set_spacing(image: *mut GimpImage, xspacing: c_double, yspacing: c_double) -> gboolean;
    pub fn gimp_image_grid_set_style(image: *mut GimpImage, style: GimpGridStyle) -> gboolean;
    pub fn gimp_image_import_paths_from_file(image: *mut GimpImage, file: *mut gio::GFile, merge: gboolean, scale: gboolean, paths: *mut *mut *mut GimpPath) -> gboolean;
    pub fn gimp_image_import_paths_from_string(image: *mut GimpImage, string: *const c_char, length: c_int, merge: gboolean, scale: gboolean, paths: *mut *mut *mut GimpPath) -> gboolean;
    pub fn gimp_image_insert_channel(image: *mut GimpImage, channel: *mut GimpChannel, parent: *mut GimpChannel, position: c_int) -> gboolean;
    pub fn gimp_image_insert_layer(image: *mut GimpImage, layer: *mut GimpLayer, parent: *mut GimpLayer, position: c_int) -> gboolean;
    pub fn gimp_image_insert_path(image: *mut GimpImage, path: *mut GimpPath, parent: *mut GimpPath, position: c_int) -> gboolean;
    pub fn gimp_image_is_dirty(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_is_valid(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_list_channels(image: *mut GimpImage) -> *mut glib::GList;
    pub fn gimp_image_list_layers(image: *mut GimpImage) -> *mut glib::GList;
    pub fn gimp_image_list_paths(image: *mut GimpImage) -> *mut glib::GList;
    pub fn gimp_image_list_selected_channels(image: *mut GimpImage) -> *mut glib::GList;
    pub fn gimp_image_list_selected_drawables(image: *mut GimpImage) -> *mut glib::GList;
    pub fn gimp_image_list_selected_layers(image: *mut GimpImage) -> *mut glib::GList;
    pub fn gimp_image_list_selected_paths(image: *mut GimpImage) -> *mut glib::GList;
    pub fn gimp_image_lower_item(image: *mut GimpImage, item: *mut GimpItem) -> gboolean;
    pub fn gimp_image_lower_item_to_bottom(image: *mut GimpImage, item: *mut GimpItem) -> gboolean;
    pub fn gimp_image_merge_down(image: *mut GimpImage, merge_layer: *mut GimpLayer, merge_type: GimpMergeType) -> *mut GimpLayer;
    pub fn gimp_image_merge_visible_layers(image: *mut GimpImage, merge_type: GimpMergeType) -> *mut GimpLayer;
    pub fn gimp_image_metadata_save_filter(image: *mut GimpImage, mime_type: *const c_char, metadata: *mut GimpMetadata, flags: GimpMetadataSaveFlags, file: *mut gio::GFile, error: *mut *mut glib::GError) -> *mut GimpMetadata;
    pub fn gimp_image_metadata_save_prepare(image: *mut GimpImage, mime_type: *const c_char, suggested_flags: *mut GimpMetadataSaveFlags) -> *mut GimpMetadata;
    pub fn gimp_image_pick_color(image: *mut GimpImage, drawables: *mut *const GimpDrawable, x: c_double, y: c_double, sample_merged: gboolean, sample_average: gboolean, average_radius: c_double, color: *mut *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_image_pick_correlate_layer(image: *mut GimpImage, x: c_int, y: c_int) -> *mut GimpLayer;
    pub fn gimp_image_policy_color_profile(image: *mut GimpImage, interactive: gboolean) -> gboolean;
    pub fn gimp_image_policy_rotate(image: *mut GimpImage, interactive: gboolean) -> gboolean;
    pub fn gimp_image_raise_item(image: *mut GimpImage, item: *mut GimpItem) -> gboolean;
    pub fn gimp_image_raise_item_to_top(image: *mut GimpImage, item: *mut GimpItem) -> gboolean;
    pub fn gimp_image_remove_channel(image: *mut GimpImage, channel: *mut GimpChannel) -> gboolean;
    pub fn gimp_image_remove_layer(image: *mut GimpImage, layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_image_remove_path(image: *mut GimpImage, path: *mut GimpPath) -> gboolean;
    pub fn gimp_image_reorder_item(image: *mut GimpImage, item: *mut GimpItem, parent: *mut GimpItem, position: c_int) -> gboolean;
    pub fn gimp_image_resize(image: *mut GimpImage, new_width: c_int, new_height: c_int, offx: c_int, offy: c_int) -> gboolean;
    pub fn gimp_image_resize_to_layers(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_rotate(image: *mut GimpImage, rotate_type: GimpRotationType) -> gboolean;
    pub fn gimp_image_scale(image: *mut GimpImage, new_width: c_int, new_height: c_int) -> gboolean;
    pub fn gimp_image_select_color(image: *mut GimpImage, operation: GimpChannelOps, drawable: *mut GimpDrawable, color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_image_select_contiguous_color(image: *mut GimpImage, operation: GimpChannelOps, drawable: *mut GimpDrawable, x: c_double, y: c_double) -> gboolean;
    pub fn gimp_image_select_ellipse(image: *mut GimpImage, operation: GimpChannelOps, x: c_double, y: c_double, width: c_double, height: c_double) -> gboolean;
    pub fn gimp_image_select_item(image: *mut GimpImage, operation: GimpChannelOps, item: *mut GimpItem) -> gboolean;
    pub fn gimp_image_select_polygon(image: *mut GimpImage, operation: GimpChannelOps, num_segs: size_t, segs: *const c_double) -> gboolean;
    pub fn gimp_image_select_rectangle(image: *mut GimpImage, operation: GimpChannelOps, x: c_double, y: c_double, width: c_double, height: c_double) -> gboolean;
    pub fn gimp_image_select_round_rectangle(image: *mut GimpImage, operation: GimpChannelOps, x: c_double, y: c_double, width: c_double, height: c_double, corner_radius_x: c_double, corner_radius_y: c_double) -> gboolean;
    pub fn gimp_image_set_color_profile(image: *mut GimpImage, profile: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_image_set_color_profile_from_file(image: *mut GimpImage, file: *mut gio::GFile) -> gboolean;
    pub fn gimp_image_set_component_active(image: *mut GimpImage, component: GimpChannelType, active: gboolean) -> gboolean;
    pub fn gimp_image_set_component_visible(image: *mut GimpImage, component: GimpChannelType, visible: gboolean) -> gboolean;
    pub fn gimp_image_set_file(image: *mut GimpImage, file: *mut gio::GFile) -> gboolean;
    pub fn gimp_image_set_metadata(image: *mut GimpImage, metadata: *mut GimpMetadata) -> gboolean;
    pub fn gimp_image_set_palette(image: *mut GimpImage, new_palette: *mut GimpPalette) -> *mut GimpPalette;
    pub fn gimp_image_set_resolution(image: *mut GimpImage, xresolution: c_double, yresolution: c_double) -> gboolean;
    pub fn gimp_image_set_selected_channels(image: *mut GimpImage, channels: *mut *const GimpChannel) -> gboolean;
    pub fn gimp_image_set_selected_layers(image: *mut GimpImage, layers: *mut *const GimpLayer) -> gboolean;
    pub fn gimp_image_set_selected_paths(image: *mut GimpImage, paths: *mut *const GimpPath) -> gboolean;
    pub fn gimp_image_set_simulation_bpc(image: *mut GimpImage, bpc: gboolean) -> gboolean;
    pub fn gimp_image_set_simulation_intent(image: *mut GimpImage, intent: GimpColorRenderingIntent) -> gboolean;
    pub fn gimp_image_set_simulation_profile(image: *mut GimpImage, profile: *mut GimpColorProfile) -> gboolean;
    pub fn gimp_image_set_simulation_profile_from_file(image: *mut GimpImage, file: *mut gio::GFile) -> gboolean;
    pub fn gimp_image_set_tattoo_state(image: *mut GimpImage, tattoo_state: c_uint) -> gboolean;
    pub fn gimp_image_set_unit(image: *mut GimpImage, unit: *mut GimpUnit) -> gboolean;
    pub fn gimp_image_take_selected_channels(image: *mut GimpImage, channels: *mut glib::GList) -> gboolean;
    pub fn gimp_image_take_selected_layers(image: *mut GimpImage, layers: *mut glib::GList) -> gboolean;
    pub fn gimp_image_take_selected_paths(image: *mut GimpImage, paths: *mut glib::GList) -> gboolean;
    pub fn gimp_image_thaw_channels(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_thaw_layers(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_thaw_paths(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_undo_disable(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_undo_enable(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_undo_freeze(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_undo_group_end(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_undo_group_start(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_undo_is_enabled(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_undo_thaw(image: *mut GimpImage) -> gboolean;
    pub fn gimp_image_unset_active_channel(image: *mut GimpImage) -> gboolean;

    //=========================================================================
    // GimpImageProcedure
    //=========================================================================
    pub fn gimp_image_procedure_get_type() -> GType;
    pub fn gimp_image_procedure_new(plug_in: *mut GimpPlugIn, name: *const c_char, proc_type: GimpPDBProcType, run_func: GimpRunImageFunc, run_data: gpointer, run_data_destroy: glib::GDestroyNotify) -> *mut GimpProcedure;

    //=========================================================================
    // GimpItem
    //=========================================================================
    pub fn gimp_item_get_type() -> GType;
    pub fn gimp_item_get_by_id(item_id: i32) -> *mut GimpItem;
    pub fn gimp_item_id_is_channel(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_drawable(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_group_layer(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_layer(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_layer_mask(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_path(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_selection(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_text_layer(item_id: c_int) -> gboolean;
    pub fn gimp_item_id_is_valid(item_id: c_int) -> gboolean;
    pub fn gimp_item_attach_parasite(item: *mut GimpItem, parasite: *const GimpParasite) -> gboolean;
    pub fn gimp_item_delete(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_detach_parasite(item: *mut GimpItem, name: *const c_char) -> gboolean;
    pub fn gimp_item_get_children(item: *mut GimpItem) -> *mut *mut GimpItem;
    pub fn gimp_item_get_color_tag(item: *mut GimpItem) -> GimpColorTag;
    pub fn gimp_item_get_expanded(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_get_id(item: *mut GimpItem) -> i32;
    pub fn gimp_item_get_image(item: *mut GimpItem) -> *mut GimpImage;
    pub fn gimp_item_get_lock_content(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_get_lock_position(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_get_lock_visibility(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_get_name(item: *mut GimpItem) -> *mut c_char;
    pub fn gimp_item_get_parasite(item: *mut GimpItem, name: *const c_char) -> *mut GimpParasite;
    pub fn gimp_item_get_parasite_list(item: *mut GimpItem) -> *mut *mut c_char;
    pub fn gimp_item_get_parent(item: *mut GimpItem) -> *mut GimpItem;
    pub fn gimp_item_get_tattoo(item: *mut GimpItem) -> c_uint;
    pub fn gimp_item_get_visible(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_channel(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_drawable(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_group(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_group_layer(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_layer(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_layer_mask(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_path(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_selection(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_text_layer(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_is_valid(item: *mut GimpItem) -> gboolean;
    pub fn gimp_item_list_children(item: *mut GimpItem) -> *mut glib::GList;
    pub fn gimp_item_set_color_tag(item: *mut GimpItem, color_tag: GimpColorTag) -> gboolean;
    pub fn gimp_item_set_expanded(item: *mut GimpItem, expanded: gboolean) -> gboolean;
    pub fn gimp_item_set_lock_content(item: *mut GimpItem, lock_content: gboolean) -> gboolean;
    pub fn gimp_item_set_lock_position(item: *mut GimpItem, lock_position: gboolean) -> gboolean;
    pub fn gimp_item_set_lock_visibility(item: *mut GimpItem, lock_visibility: gboolean) -> gboolean;
    pub fn gimp_item_set_name(item: *mut GimpItem, name: *const c_char) -> gboolean;
    pub fn gimp_item_set_tattoo(item: *mut GimpItem, tattoo: c_uint) -> gboolean;
    pub fn gimp_item_set_visible(item: *mut GimpItem, visible: gboolean) -> gboolean;
    pub fn gimp_item_transform_2d(item: *mut GimpItem, source_x: c_double, source_y: c_double, scale_x: c_double, scale_y: c_double, angle: c_double, dest_x: c_double, dest_y: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_flip(item: *mut GimpItem, x0: c_double, y0: c_double, x1: c_double, y1: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_flip_simple(item: *mut GimpItem, flip_type: GimpOrientationType, auto_center: gboolean, axis: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_matrix(item: *mut GimpItem, coeff_0_0: c_double, coeff_0_1: c_double, coeff_0_2: c_double, coeff_1_0: c_double, coeff_1_1: c_double, coeff_1_2: c_double, coeff_2_0: c_double, coeff_2_1: c_double, coeff_2_2: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_perspective(item: *mut GimpItem, x0: c_double, y0: c_double, x1: c_double, y1: c_double, x2: c_double, y2: c_double, x3: c_double, y3: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_rotate(item: *mut GimpItem, angle: c_double, auto_center: gboolean, center_x: c_double, center_y: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_rotate_simple(item: *mut GimpItem, rotate_type: GimpRotationType, auto_center: gboolean, center_x: c_double, center_y: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_scale(item: *mut GimpItem, x0: c_double, y0: c_double, x1: c_double, y1: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_shear(item: *mut GimpItem, shear_type: GimpOrientationType, magnitude: c_double) -> *mut GimpItem;
    pub fn gimp_item_transform_translate(item: *mut GimpItem, off_x: c_double, off_y: c_double) -> *mut GimpItem;

    //=========================================================================
    // GimpLayer
    //=========================================================================
    pub fn gimp_layer_get_type() -> GType;
    pub fn gimp_layer_new(image: *mut GimpImage, name: *const c_char, width: c_int, height: c_int, type_: GimpImageType, opacity: c_double, mode: GimpLayerMode) -> *mut GimpLayer;
    pub fn gimp_layer_new_from_drawable(drawable: *mut GimpDrawable, dest_image: *mut GimpImage) -> *mut GimpLayer;
    pub fn gimp_layer_new_from_pixbuf(image: *mut GimpImage, name: *const c_char, pixbuf: *mut gdk_pixbuf::GdkPixbuf, opacity: c_double, mode: GimpLayerMode, progress_start: c_double, progress_end: c_double) -> *mut GimpLayer;
    pub fn gimp_layer_new_from_surface(image: *mut GimpImage, name: *const c_char, surface: *mut cairo::cairo_surface_t, progress_start: c_double, progress_end: c_double) -> *mut GimpLayer;
    pub fn gimp_layer_new_from_visible(image: *mut GimpImage, dest_image: *mut GimpImage, name: *const c_char) -> *mut GimpLayer;
    pub fn gimp_layer_from_mask(mask: *mut GimpLayerMask) -> *mut GimpLayer;
    pub fn gimp_layer_get_by_id(layer_id: i32) -> *mut GimpLayer;
    pub fn gimp_layer_add_alpha(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_add_mask(layer: *mut GimpLayer, mask: *mut GimpLayerMask) -> gboolean;
    pub fn gimp_layer_copy(layer: *mut GimpLayer) -> *mut GimpLayer;
    pub fn gimp_layer_create_mask(layer: *mut GimpLayer, mask_type: GimpAddMaskType) -> *mut GimpLayerMask;
    pub fn gimp_layer_flatten(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_get_apply_mask(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_get_blend_space(layer: *mut GimpLayer) -> GimpLayerColorSpace;
    pub fn gimp_layer_get_composite_mode(layer: *mut GimpLayer) -> GimpLayerCompositeMode;
    pub fn gimp_layer_get_composite_space(layer: *mut GimpLayer) -> GimpLayerColorSpace;
    pub fn gimp_layer_get_edit_mask(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_get_lock_alpha(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_get_mask(layer: *mut GimpLayer) -> *mut GimpLayerMask;
    pub fn gimp_layer_get_mode(layer: *mut GimpLayer) -> GimpLayerMode;
    pub fn gimp_layer_get_opacity(layer: *mut GimpLayer) -> c_double;
    pub fn gimp_layer_get_show_mask(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_is_floating_sel(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_remove_mask(layer: *mut GimpLayer, mode: GimpMaskApplyMode) -> gboolean;
    pub fn gimp_layer_resize(layer: *mut GimpLayer, new_width: c_int, new_height: c_int, offx: c_int, offy: c_int) -> gboolean;
    pub fn gimp_layer_resize_to_image_size(layer: *mut GimpLayer) -> gboolean;
    pub fn gimp_layer_scale(layer: *mut GimpLayer, new_width: c_int, new_height: c_int, local_origin: gboolean) -> gboolean;
    pub fn gimp_layer_set_apply_mask(layer: *mut GimpLayer, apply_mask: gboolean) -> gboolean;
    pub fn gimp_layer_set_blend_space(layer: *mut GimpLayer, blend_space: GimpLayerColorSpace) -> gboolean;
    pub fn gimp_layer_set_composite_mode(layer: *mut GimpLayer, composite_mode: GimpLayerCompositeMode) -> gboolean;
    pub fn gimp_layer_set_composite_space(layer: *mut GimpLayer, composite_space: GimpLayerColorSpace) -> gboolean;
    pub fn gimp_layer_set_edit_mask(layer: *mut GimpLayer, edit_mask: gboolean) -> gboolean;
    pub fn gimp_layer_set_lock_alpha(layer: *mut GimpLayer, lock_alpha: gboolean) -> gboolean;
    pub fn gimp_layer_set_mode(layer: *mut GimpLayer, mode: GimpLayerMode) -> gboolean;
    pub fn gimp_layer_set_offsets(layer: *mut GimpLayer, offx: c_int, offy: c_int) -> gboolean;
    pub fn gimp_layer_set_opacity(layer: *mut GimpLayer, opacity: c_double) -> gboolean;
    pub fn gimp_layer_set_show_mask(layer: *mut GimpLayer, show_mask: gboolean) -> gboolean;

    //=========================================================================
    // GimpLayerMask
    //=========================================================================
    pub fn gimp_layer_mask_get_type() -> GType;
    pub fn gimp_layer_mask_get_by_id(layer_mask_id: i32) -> *mut GimpLayerMask;

    //=========================================================================
    // GimpLoadProcedure
    //=========================================================================
    pub fn gimp_load_procedure_get_type() -> GType;
    pub fn gimp_load_procedure_new(plug_in: *mut GimpPlugIn, name: *const c_char, proc_type: GimpPDBProcType, run_func: GimpRunLoadFunc, run_data: gpointer, run_data_destroy: glib::GDestroyNotify) -> *mut GimpProcedure;
    pub fn gimp_load_procedure_get_handles_raw(procedure: *mut GimpLoadProcedure) -> gboolean;
    pub fn gimp_load_procedure_get_thumbnail_loader(procedure: *mut GimpLoadProcedure) -> *const c_char;
    pub fn gimp_load_procedure_set_handles_raw(procedure: *mut GimpLoadProcedure, handles_raw: gboolean);
    pub fn gimp_load_procedure_set_thumbnail_loader(procedure: *mut GimpLoadProcedure, thumbnail_proc: *const c_char);

    //=========================================================================
    // GimpMemsize
    //=========================================================================
    pub fn gimp_memsize_get_type() -> GType;
    pub fn gimp_memsize_deserialize(string: *const c_char, memsize: *mut u64) -> gboolean;
    pub fn gimp_memsize_serialize(memsize: u64) -> *mut c_char;

    //=========================================================================
    // GimpMetadata
    //=========================================================================
    pub fn gimp_metadata_get_type() -> GType;
    pub fn gimp_metadata_new() -> *mut GimpMetadata;
    pub fn gimp_metadata_deserialize(metadata_xml: *const c_char) -> *mut GimpMetadata;
    pub fn gimp_metadata_get_guid() -> *mut c_char;
    pub fn gimp_metadata_is_tag_supported(tag: *const c_char, mime_type: *const c_char) -> gboolean;
    pub fn gimp_metadata_load_from_file(file: *mut gio::GFile, error: *mut *mut glib::GError) -> *mut GimpMetadata;
    pub fn gimp_metadata_add_xmp_history(metadata: *mut GimpMetadata, state_status: *mut c_char);
    pub fn gimp_metadata_duplicate(metadata: *mut GimpMetadata) -> *mut GimpMetadata;
    pub fn gimp_metadata_get_colorspace(metadata: *mut GimpMetadata) -> GimpMetadataColorspace;
    pub fn gimp_metadata_get_resolution(metadata: *mut GimpMetadata, xres: *mut c_double, yres: *mut c_double, unit: *mut *mut GimpUnit) -> gboolean;
    pub fn gimp_metadata_save_to_file(metadata: *mut GimpMetadata, file: *mut gio::GFile, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_metadata_serialize(metadata: *mut GimpMetadata) -> *mut c_char;
    pub fn gimp_metadata_set_bits_per_sample(metadata: *mut GimpMetadata, bits_per_sample: c_int);
    pub fn gimp_metadata_set_colorspace(metadata: *mut GimpMetadata, colorspace: GimpMetadataColorspace);
    pub fn gimp_metadata_set_from_exif(metadata: *mut GimpMetadata, exif_data: *const u8, exif_data_length: c_int, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_metadata_set_from_iptc(metadata: *mut GimpMetadata, iptc_data: *const u8, iptc_data_length: c_int, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_metadata_set_from_xmp(metadata: *mut GimpMetadata, xmp_data: *const u8, xmp_data_length: c_int, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_metadata_set_pixel_size(metadata: *mut GimpMetadata, width: c_int, height: c_int);
    pub fn gimp_metadata_set_resolution(metadata: *mut GimpMetadata, xres: c_double, yres: c_double, unit: *mut GimpUnit);

    //=========================================================================
    // GimpModule
    //=========================================================================
    pub fn gimp_module_get_type() -> GType;
    pub fn gimp_module_new(file: *mut gio::GFile, auto_load: gboolean, verbose: gboolean) -> *mut GimpModule;
    pub fn gimp_module_error_quark() -> glib::GQuark;
    pub fn gimp_module_query(module: *mut gobject::GTypeModule) -> *const GimpModuleInfo;
    pub fn gimp_module_register(module: *mut gobject::GTypeModule) -> gboolean;
    pub fn gimp_module_get_auto_load(module: *mut GimpModule) -> gboolean;
    pub fn gimp_module_get_file(module: *mut GimpModule) -> *mut gio::GFile;
    pub fn gimp_module_get_info(module: *mut GimpModule) -> *const GimpModuleInfo;
    pub fn gimp_module_get_last_error(module: *mut GimpModule) -> *const c_char;
    pub fn gimp_module_get_state(module: *mut GimpModule) -> GimpModuleState;
    pub fn gimp_module_is_loaded(module: *mut GimpModule) -> gboolean;
    pub fn gimp_module_is_on_disk(module: *mut GimpModule) -> gboolean;
    pub fn gimp_module_query_module(module: *mut GimpModule) -> gboolean;
    pub fn gimp_module_set_auto_load(module: *mut GimpModule, auto_load: gboolean);

    //=========================================================================
    // GimpModuleDB
    //=========================================================================
    pub fn gimp_module_db_get_type() -> GType;
    pub fn gimp_module_db_new(verbose: gboolean) -> *mut GimpModuleDB;
    pub fn gimp_module_db_get_load_inhibit(db: *mut GimpModuleDB) -> *const c_char;
    pub fn gimp_module_db_get_verbose(db: *mut GimpModuleDB) -> gboolean;
    pub fn gimp_module_db_load(db: *mut GimpModuleDB, module_path: *const c_char);
    pub fn gimp_module_db_refresh(db: *mut GimpModuleDB, module_path: *const c_char);
    pub fn gimp_module_db_set_load_inhibit(db: *mut GimpModuleDB, load_inhibit: *const c_char);
    pub fn gimp_module_db_set_verbose(db: *mut GimpModuleDB, verbose: gboolean);

    //=========================================================================
    // GimpPDB
    //=========================================================================
    pub fn gimp_pdb_get_type() -> GType;
    pub fn gimp_pdb_dump_to_file(pdb: *mut GimpPDB, file: *mut gio::GFile) -> gboolean;
    pub fn gimp_pdb_get_last_error(pdb: *mut GimpPDB) -> *const c_char;
    pub fn gimp_pdb_get_last_status(pdb: *mut GimpPDB) -> GimpPDBStatusType;
    pub fn gimp_pdb_lookup_procedure(pdb: *mut GimpPDB, procedure_name: *const c_char) -> *mut GimpProcedure;
    pub fn gimp_pdb_procedure_exists(pdb: *mut GimpPDB, procedure_name: *const c_char) -> gboolean;
    pub fn gimp_pdb_query_procedures(pdb: *mut GimpPDB, name: *const c_char, blurb: *const c_char, help: *const c_char, help_id: *const c_char, authors: *const c_char, copyright: *const c_char, date: *const c_char, proc_type: *const c_char) -> *mut *mut c_char;
    pub fn gimp_pdb_temp_procedure_name(pdb: *mut GimpPDB) -> *mut c_char;

    //=========================================================================
    // GimpPalette
    //=========================================================================
    pub fn gimp_palette_get_type() -> GType;
    pub fn gimp_palette_new(name: *const c_char) -> *mut GimpPalette;
    pub fn gimp_palette_get_by_name(name: *const c_char) -> *mut GimpPalette;
    pub fn gimp_palette_add_entry(palette: *mut GimpPalette, entry_name: *const c_char, color: *mut gegl::GeglColor, entry_num: *mut c_int) -> gboolean;
    pub fn gimp_palette_delete_entry(palette: *mut GimpPalette, entry_num: c_int) -> gboolean;
    pub fn gimp_palette_get_color_count(palette: *mut GimpPalette) -> c_int;
    pub fn gimp_palette_get_colormap(palette: *mut GimpPalette, format: *const babl::Babl, num_colors: *mut c_int, num_bytes: *mut size_t) -> *mut u8;
    pub fn gimp_palette_get_colors(palette: *mut GimpPalette) -> *mut *mut gegl::GeglColor;
    pub fn gimp_palette_get_columns(palette: *mut GimpPalette) -> c_int;
    pub fn gimp_palette_get_entry_color(palette: *mut GimpPalette, entry_num: c_int) -> *mut gegl::GeglColor;
    pub fn gimp_palette_get_entry_name(palette: *mut GimpPalette, entry_num: c_int, entry_name: *mut *mut c_char) -> gboolean;
    pub fn gimp_palette_set_colormap(palette: *mut GimpPalette, format: *const babl::Babl, colormap: *mut u8, num_bytes: size_t) -> gboolean;
    pub fn gimp_palette_set_columns(palette: *mut GimpPalette, columns: c_int) -> gboolean;
    pub fn gimp_palette_set_entry_color(palette: *mut GimpPalette, entry_num: c_int, color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_palette_set_entry_name(palette: *mut GimpPalette, entry_num: c_int, entry_name: *const c_char) -> gboolean;

    //=========================================================================
    // GimpParamArray
    //=========================================================================
    pub fn gimp_param_array_get_type() -> GType;

    //=========================================================================
    // GimpParamBrush
    //=========================================================================
    pub fn gimp_param_brush_get_type() -> GType;

    //=========================================================================
    // GimpParamChannel
    //=========================================================================
    pub fn gimp_param_channel_get_type() -> GType;

    //=========================================================================
    // GimpParamChoice
    //=========================================================================
    pub fn gimp_param_choice_get_type() -> GType;

    //=========================================================================
    // GimpParamColor
    //=========================================================================
    pub fn gimp_param_color_get_type() -> GType;

    //=========================================================================
    // GimpParamConfigPath
    //=========================================================================
    pub fn gimp_param_config_path_get_type() -> GType;

    //=========================================================================
    // GimpParamCoreObjectArray
    //=========================================================================
    pub fn gimp_param_core_object_array_get_type() -> GType;

    //=========================================================================
    // GimpParamDisplay
    //=========================================================================
    pub fn gimp_param_display_get_type() -> GType;

    //=========================================================================
    // GimpParamDoubleArray
    //=========================================================================
    pub fn gimp_param_double_array_get_type() -> GType;

    //=========================================================================
    // GimpParamDrawable
    //=========================================================================
    pub fn gimp_param_drawable_get_type() -> GType;

    //=========================================================================
    // GimpParamDrawableFilter
    //=========================================================================
    pub fn gimp_param_drawable_filter_get_type() -> GType;

    //=========================================================================
    // GimpParamExportOptions
    //=========================================================================
    pub fn gimp_param_export_options_get_type() -> GType;

    //=========================================================================
    // GimpParamFont
    //=========================================================================
    pub fn gimp_param_font_get_type() -> GType;

    //=========================================================================
    // GimpParamGradient
    //=========================================================================
    pub fn gimp_param_gradient_get_type() -> GType;

    //=========================================================================
    // GimpParamGroupLayer
    //=========================================================================
    pub fn gimp_param_group_layer_get_type() -> GType;

    //=========================================================================
    // GimpParamImage
    //=========================================================================
    pub fn gimp_param_image_get_type() -> GType;

    //=========================================================================
    // GimpParamInt32Array
    //=========================================================================
    pub fn gimp_param_int32_array_get_type() -> GType;

    //=========================================================================
    // GimpParamItem
    //=========================================================================
    pub fn gimp_param_item_get_type() -> GType;

    //=========================================================================
    // GimpParamLayer
    //=========================================================================
    pub fn gimp_param_layer_get_type() -> GType;

    //=========================================================================
    // GimpParamLayerMask
    //=========================================================================
    pub fn gimp_param_layer_mask_get_type() -> GType;

    //=========================================================================
    // GimpParamMatrix2
    //=========================================================================
    pub fn gimp_param_matrix2_get_type() -> GType;

    //=========================================================================
    // GimpParamMatrix3
    //=========================================================================
    pub fn gimp_param_matrix3_get_type() -> GType;

    //=========================================================================
    // GimpParamMemsize
    //=========================================================================
    pub fn gimp_param_memsize_get_type() -> GType;

    //=========================================================================
    // GimpParamObject
    //=========================================================================
    pub fn gimp_param_object_get_type() -> GType;

    //=========================================================================
    // GimpParamPalette
    //=========================================================================
    pub fn gimp_param_palette_get_type() -> GType;

    //=========================================================================
    // GimpParamParasite
    //=========================================================================
    pub fn gimp_param_parasite_get_type() -> GType;

    //=========================================================================
    // GimpParamPath
    //=========================================================================
    pub fn gimp_param_path_get_type() -> GType;

    //=========================================================================
    // GimpParamPattern
    //=========================================================================
    pub fn gimp_param_pattern_get_type() -> GType;

    //=========================================================================
    // GimpParamResource
    //=========================================================================
    pub fn gimp_param_resource_get_type() -> GType;

    //=========================================================================
    // GimpParamSelection
    //=========================================================================
    pub fn gimp_param_selection_get_type() -> GType;

    //=========================================================================
    // GimpParamTextLayer
    //=========================================================================
    pub fn gimp_param_text_layer_get_type() -> GType;

    //=========================================================================
    // GimpParamUnit
    //=========================================================================
    pub fn gimp_param_unit_get_type() -> GType;

    //=========================================================================
    // GimpParamValueArray
    //=========================================================================
    pub fn gimp_param_value_array_get_type() -> GType;

    //=========================================================================
    // GimpPath
    //=========================================================================
    pub fn gimp_path_get_type() -> GType;
    pub fn gimp_path_new(image: *mut GimpImage, name: *const c_char) -> *mut GimpPath;
    pub fn gimp_path_new_from_text_layer(image: *mut GimpImage, layer: *mut GimpLayer) -> *mut GimpPath;
    pub fn gimp_path_free(path: *mut glib::GList);
    pub fn gimp_path_get_by_id(path_id: i32) -> *mut GimpPath;
    pub fn gimp_path_get_user_writable_dir(path: *mut glib::GList) -> *mut c_char;
    pub fn gimp_path_parse(path: *const c_char, max_paths: c_int, check: gboolean, check_failed: *mut *mut glib::GList) -> *mut glib::GList;
    pub fn gimp_path_to_str(path: *mut glib::GList) -> *mut c_char;
    pub fn gimp_path_bezier_stroke_conicto(path: *mut GimpPath, stroke_id: c_int, x0: c_double, y0: c_double, x1: c_double, y1: c_double) -> gboolean;
    pub fn gimp_path_bezier_stroke_cubicto(path: *mut GimpPath, stroke_id: c_int, x0: c_double, y0: c_double, x1: c_double, y1: c_double, x2: c_double, y2: c_double) -> gboolean;
    pub fn gimp_path_bezier_stroke_lineto(path: *mut GimpPath, stroke_id: c_int, x0: c_double, y0: c_double) -> gboolean;
    pub fn gimp_path_bezier_stroke_new_ellipse(path: *mut GimpPath, x0: c_double, y0: c_double, radius_x: c_double, radius_y: c_double, angle: c_double) -> c_int;
    pub fn gimp_path_bezier_stroke_new_moveto(path: *mut GimpPath, x0: c_double, y0: c_double) -> c_int;
    pub fn gimp_path_copy(path: *mut GimpPath) -> *mut GimpPath;
    pub fn gimp_path_get_strokes(path: *mut GimpPath, num_strokes: *mut size_t) -> *mut i32;
    pub fn gimp_path_remove_stroke(path: *mut GimpPath, stroke_id: c_int) -> gboolean;
    pub fn gimp_path_stroke_close(path: *mut GimpPath, stroke_id: c_int) -> gboolean;
    pub fn gimp_path_stroke_flip(path: *mut GimpPath, stroke_id: c_int, flip_type: GimpOrientationType, axis: c_double) -> gboolean;
    pub fn gimp_path_stroke_flip_free(path: *mut GimpPath, stroke_id: c_int, x1: c_double, y1: c_double, x2: c_double, y2: c_double) -> gboolean;
    pub fn gimp_path_stroke_get_length(path: *mut GimpPath, stroke_id: c_int, precision: c_double) -> c_double;
    pub fn gimp_path_stroke_get_point_at_dist(path: *mut GimpPath, stroke_id: c_int, dist: c_double, precision: c_double, x_point: *mut c_double, y_point: *mut c_double, slope: *mut c_double, valid: *mut gboolean) -> gboolean;
    pub fn gimp_path_stroke_get_points(path: *mut GimpPath, stroke_id: c_int, num_points: *mut size_t, controlpoints: *mut *mut c_double, closed: *mut gboolean) -> GimpPathStrokeType;
    pub fn gimp_path_stroke_interpolate(path: *mut GimpPath, stroke_id: c_int, precision: c_double, num_coords: *mut size_t, closed: *mut gboolean) -> *mut c_double;
    pub fn gimp_path_stroke_new_from_points(path: *mut GimpPath, type_: GimpPathStrokeType, num_points: size_t, controlpoints: *const c_double, closed: gboolean) -> c_int;
    pub fn gimp_path_stroke_reverse(path: *mut GimpPath, stroke_id: c_int) -> gboolean;
    pub fn gimp_path_stroke_rotate(path: *mut GimpPath, stroke_id: c_int, center_x: c_double, center_y: c_double, angle: c_double) -> gboolean;
    pub fn gimp_path_stroke_scale(path: *mut GimpPath, stroke_id: c_int, scale_x: c_double, scale_y: c_double) -> gboolean;
    pub fn gimp_path_stroke_translate(path: *mut GimpPath, stroke_id: c_int, off_x: c_double, off_y: c_double) -> gboolean;

    //=========================================================================
    // GimpPattern
    //=========================================================================
    pub fn gimp_pattern_get_type() -> GType;
    pub fn gimp_pattern_get_by_name(name: *const c_char) -> *mut GimpPattern;
    pub fn gimp_pattern_get_buffer(pattern: *mut GimpPattern, max_width: c_int, max_height: c_int, format: *const babl::Babl) -> *mut gegl::GeglBuffer;
    pub fn gimp_pattern_get_info(pattern: *mut GimpPattern, width: *mut c_int, height: *mut c_int, bpp: *mut c_int) -> gboolean;

    //=========================================================================
    // GimpPlugIn
    //=========================================================================
    pub fn gimp_plug_in_get_type() -> GType;
    pub fn gimp_plug_in_directory() -> *const c_char;
    pub fn gimp_plug_in_directory_file(first_element: *const c_char, ...) -> *mut gio::GFile;
    pub fn gimp_plug_in_error_quark() -> glib::GQuark;
    pub fn gimp_plug_in_add_menu_branch(plug_in: *mut GimpPlugIn, menu_path: *const c_char, menu_label: *const c_char);
    pub fn gimp_plug_in_add_temp_procedure(plug_in: *mut GimpPlugIn, procedure: *mut GimpProcedure);
    pub fn gimp_plug_in_get_pdb_error_handler(plug_in: *mut GimpPlugIn) -> GimpPDBErrorHandler;
    pub fn gimp_plug_in_get_temp_procedure(plug_in: *mut GimpPlugIn, procedure_name: *const c_char) -> *mut GimpProcedure;
    pub fn gimp_plug_in_get_temp_procedures(plug_in: *mut GimpPlugIn) -> *mut glib::GList;
    pub fn gimp_plug_in_persistent_enable(plug_in: *mut GimpPlugIn);
    pub fn gimp_plug_in_persistent_process(plug_in: *mut GimpPlugIn, timeout: c_uint);
    pub fn gimp_plug_in_remove_temp_procedure(plug_in: *mut GimpPlugIn, procedure_name: *const c_char);
    pub fn gimp_plug_in_set_help_domain(plug_in: *mut GimpPlugIn, domain_name: *const c_char, domain_uri: *mut gio::GFile);
    pub fn gimp_plug_in_set_pdb_error_handler(plug_in: *mut GimpPlugIn, handler: GimpPDBErrorHandler);

    //=========================================================================
    // GimpProcedure
    //=========================================================================
    pub fn gimp_procedure_get_type() -> GType;
    pub fn gimp_procedure_new(plug_in: *mut GimpPlugIn, name: *const c_char, proc_type: GimpPDBProcType, run_func: GimpRunFunc, run_data: gpointer, run_data_destroy: glib::GDestroyNotify) -> *mut GimpProcedure;
    pub fn gimp_procedure_add_boolean_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, value: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_boolean_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, value: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_boolean_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, value: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_brush_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpBrush, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_brush_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *mut GimpBrush, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_brush_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_bytes_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_bytes_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_bytes_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_channel_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_channel_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_channel_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_choice_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, choice: *mut GimpChoice, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_choice_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, choice: *mut GimpChoice, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_choice_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, choice: *mut GimpChoice, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_color_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, value: *mut gegl::GeglColor, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_color_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, value: *mut gegl::GeglColor, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_color_from_string_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_color_from_string_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_color_from_string_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_color_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, value: *mut gegl::GeglColor, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_core_object_array_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, object_type: GType, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_core_object_array_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, object_type: GType, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_core_object_array_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, object_type: GType, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_display_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_display_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_display_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_double_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_double, max: c_double, value: c_double, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_double_array_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_double_array_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_double_array_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_double_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_double, max: c_double, value: c_double, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_double_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_double, max: c_double, value: c_double, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_drawable_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_drawable_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_drawable_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_enum_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, enum_type: GType, value: c_int, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_enum_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, enum_type: GType, value: c_int, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_enum_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, enum_type: GType, value: c_int, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_file_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_file_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_file_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_font_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpFont, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_font_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *mut GimpFont, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_font_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_gradient_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpGradient, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_gradient_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *mut GimpGradient, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_gradient_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_group_layer_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_group_layer_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_group_layer_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_image_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_image_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_image_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_int32_array_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_int32_array_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_int32_array_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_int_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_int, max: c_int, value: c_int, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_int_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_int, max: c_int, value: c_int, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_int_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_int, max: c_int, value: c_int, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_item_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_item_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_item_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_layer_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_layer_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_layer_mask_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_layer_mask_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_layer_mask_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_layer_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_menu_path(procedure: *mut GimpProcedure, menu_path: *const c_char);
    pub fn gimp_procedure_add_palette_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpPalette, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_palette_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *mut GimpPalette, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_palette_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_param_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, param_type: GType, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_param_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, param_type: GType, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_param_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, param_type: GType, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_parasite_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_parasite_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_parasite_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_path_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_path_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_path_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_pattern_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpPattern, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_pattern_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *mut GimpPattern, default_to_context: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_pattern_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_resource_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpResource, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_resource_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *mut GimpResource, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_resource_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_selection_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_selection_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_selection_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_string_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_string_array_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_string_array_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_string_array_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_string_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_string_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, value: *const c_char, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_text_layer_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_text_layer_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_text_layer_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_uint_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_uint, max: c_uint, value: c_uint, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_uint_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_uint, max: c_uint, value: c_uint, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_uint_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, min: c_uint, max: c_uint, value: c_uint, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_unit_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, show_pixels: gboolean, show_percent: gboolean, value: *mut GimpUnit, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_unit_aux_argument(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, show_pixels: gboolean, show_percent: gboolean, value: *mut GimpUnit, flags: gobject::GParamFlags);
    pub fn gimp_procedure_add_unit_return_value(procedure: *mut GimpProcedure, name: *const c_char, nick: *const c_char, blurb: *const c_char, show_pixels: gboolean, show_percent: gboolean, value: *mut GimpUnit, flags: gobject::GParamFlags);
    pub fn gimp_procedure_create_config(procedure: *mut GimpProcedure) -> *mut GimpProcedureConfig;
    pub fn gimp_procedure_find_argument(procedure: *mut GimpProcedure, name: *const c_char) -> *mut gobject::GParamSpec;
    pub fn gimp_procedure_find_aux_argument(procedure: *mut GimpProcedure, name: *const c_char) -> *mut gobject::GParamSpec;
    pub fn gimp_procedure_find_return_value(procedure: *mut GimpProcedure, name: *const c_char) -> *mut gobject::GParamSpec;
    pub fn gimp_procedure_get_argument_sync(procedure: *mut GimpProcedure, arg_name: *const c_char) -> GimpArgumentSync;
    pub fn gimp_procedure_get_arguments(procedure: *mut GimpProcedure, n_arguments: *mut c_int) -> *mut *mut gobject::GParamSpec;
    pub fn gimp_procedure_get_authors(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_aux_arguments(procedure: *mut GimpProcedure, n_arguments: *mut c_int) -> *mut *mut gobject::GParamSpec;
    pub fn gimp_procedure_get_blurb(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_copyright(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_date(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_help(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_help_id(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_icon_file(procedure: *mut GimpProcedure) -> *mut gio::GFile;
    pub fn gimp_procedure_get_icon_name(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_icon_pixbuf(procedure: *mut GimpProcedure) -> *mut gdk_pixbuf::GdkPixbuf;
    pub fn gimp_procedure_get_icon_type(procedure: *mut GimpProcedure) -> GimpIconType;
    pub fn gimp_procedure_get_image_types(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_menu_label(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_menu_paths(procedure: *mut GimpProcedure) -> *mut glib::GList;
    pub fn gimp_procedure_get_name(procedure: *mut GimpProcedure) -> *const c_char;
    pub fn gimp_procedure_get_plug_in(procedure: *mut GimpProcedure) -> *mut GimpPlugIn;
    pub fn gimp_procedure_get_proc_type(procedure: *mut GimpProcedure) -> GimpPDBProcType;
    pub fn gimp_procedure_get_return_values(procedure: *mut GimpProcedure, n_return_values: *mut c_int) -> *mut *mut gobject::GParamSpec;
    pub fn gimp_procedure_get_sensitivity_mask(procedure: *mut GimpProcedure) -> c_int;
    pub fn gimp_procedure_new_return_values(procedure: *mut GimpProcedure, status: GimpPDBStatusType, error: *mut glib::GError) -> *mut GimpValueArray;
    pub fn gimp_procedure_persistent_ready(procedure: *mut GimpProcedure);
    pub fn gimp_procedure_run(procedure: *mut GimpProcedure, first_arg_name: *const c_char, ...) -> *mut GimpValueArray;
    pub fn gimp_procedure_run_config(procedure: *mut GimpProcedure, config: *mut GimpProcedureConfig) -> *mut GimpValueArray;
    //pub fn gimp_procedure_run_valist(procedure: *mut GimpProcedure, first_arg_name: *const c_char, args: /*Unimplemented*/va_list) -> *mut GimpValueArray;
    pub fn gimp_procedure_set_argument_sync(procedure: *mut GimpProcedure, arg_name: *const c_char, sync: GimpArgumentSync);
    pub fn gimp_procedure_set_attribution(procedure: *mut GimpProcedure, authors: *const c_char, copyright: *const c_char, date: *const c_char);
    pub fn gimp_procedure_set_documentation(procedure: *mut GimpProcedure, blurb: *const c_char, help: *const c_char, help_id: *const c_char);
    pub fn gimp_procedure_set_icon_file(procedure: *mut GimpProcedure, file: *mut gio::GFile);
    pub fn gimp_procedure_set_icon_name(procedure: *mut GimpProcedure, icon_name: *const c_char);
    pub fn gimp_procedure_set_icon_pixbuf(procedure: *mut GimpProcedure, pixbuf: *mut gdk_pixbuf::GdkPixbuf);
    pub fn gimp_procedure_set_image_types(procedure: *mut GimpProcedure, image_types: *const c_char);
    pub fn gimp_procedure_set_menu_label(procedure: *mut GimpProcedure, menu_label: *const c_char);
    pub fn gimp_procedure_set_sensitivity_mask(procedure: *mut GimpProcedure, sensitivity_mask: c_int);

    //=========================================================================
    // GimpProcedureConfig
    //=========================================================================
    pub fn gimp_procedure_config_get_type() -> GType;
    pub fn gimp_procedure_config_get_choice_id(config: *mut GimpProcedureConfig, property_name: *const c_char) -> c_int;
    pub fn gimp_procedure_config_get_color_array(config: *mut GimpProcedureConfig, property_name: *const c_char) -> *mut *mut gegl::GeglColor;
    pub fn gimp_procedure_config_get_core_object_array(config: *mut GimpProcedureConfig, property_name: *const c_char) -> *mut *mut gobject::GObject;
    pub fn gimp_procedure_config_get_procedure(config: *mut GimpProcedureConfig) -> *mut GimpProcedure;
    pub fn gimp_procedure_config_save_metadata(config: *mut GimpProcedureConfig, exported_image: *mut GimpImage, file: *mut gio::GFile);
    pub fn gimp_procedure_config_set_color_array(config: *mut GimpProcedureConfig, property_name: *const c_char, colors: *mut *mut gegl::GeglColor, n_colors: size_t);
    pub fn gimp_procedure_config_set_core_object_array(config: *mut GimpProcedureConfig, property_name: *const c_char, objects: *mut *mut gobject::GObject, n_objects: size_t);

    //=========================================================================
    // GimpResource
    //=========================================================================
    pub fn gimp_resource_get_type() -> GType;
    pub fn gimp_resource_get_by_id(resource_id: i32) -> *mut GimpResource;
    pub fn gimp_resource_get_by_name(resource_type: GType, resource_name: *const c_char) -> *mut GimpResource;
    pub fn gimp_resource_id_is_brush(resource_id: c_int) -> gboolean;
    pub fn gimp_resource_id_is_font(resource_id: c_int) -> gboolean;
    pub fn gimp_resource_id_is_gradient(resource_id: c_int) -> gboolean;
    pub fn gimp_resource_id_is_palette(resource_id: c_int) -> gboolean;
    pub fn gimp_resource_id_is_pattern(resource_id: c_int) -> gboolean;
    pub fn gimp_resource_id_is_valid(resource_id: c_int) -> gboolean;
    pub fn gimp_resource_delete(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_duplicate(resource: *mut GimpResource) -> *mut GimpResource;
    pub fn gimp_resource_get_id(resource: *mut GimpResource) -> i32;
    pub fn gimp_resource_get_name(resource: *mut GimpResource) -> *mut c_char;
    pub fn gimp_resource_is_brush(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_is_editable(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_is_font(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_is_gradient(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_is_palette(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_is_pattern(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_is_valid(resource: *mut GimpResource) -> gboolean;
    pub fn gimp_resource_rename(resource: *mut GimpResource, new_name: *const c_char) -> gboolean;

    //=========================================================================
    // GimpSelection
    //=========================================================================
    pub fn gimp_selection_get_type() -> GType;
    pub fn gimp_selection_all(image: *mut GimpImage) -> gboolean;
    pub fn gimp_selection_border(image: *mut GimpImage, radius: c_int) -> gboolean;
    pub fn gimp_selection_bounds(image: *mut GimpImage, non_empty: *mut gboolean, x1: *mut c_int, y1: *mut c_int, x2: *mut c_int, y2: *mut c_int) -> gboolean;
    pub fn gimp_selection_feather(image: *mut GimpImage, radius: c_double) -> gboolean;
    pub fn gimp_selection_float(image: *mut GimpImage, drawables: *mut *mut GimpDrawable, offx: c_int, offy: c_int) -> *mut GimpLayer;
    pub fn gimp_selection_flood(image: *mut GimpImage) -> gboolean;
    pub fn gimp_selection_get_by_id(selection_id: i32) -> *mut GimpSelection;
    pub fn gimp_selection_grow(image: *mut GimpImage, steps: c_int) -> gboolean;
    pub fn gimp_selection_invert(image: *mut GimpImage) -> gboolean;
    pub fn gimp_selection_is_empty(image: *mut GimpImage) -> gboolean;
    pub fn gimp_selection_none(image: *mut GimpImage) -> gboolean;
    pub fn gimp_selection_save(image: *mut GimpImage) -> *mut GimpChannel;
    pub fn gimp_selection_sharpen(image: *mut GimpImage) -> gboolean;
    pub fn gimp_selection_shrink(image: *mut GimpImage, steps: c_int) -> gboolean;
    pub fn gimp_selection_translate(image: *mut GimpImage, offx: c_int, offy: c_int) -> gboolean;
    pub fn gimp_selection_value(image: *mut GimpImage, x: c_int, y: c_int) -> c_int;

    //=========================================================================
    // GimpTextLayer
    //=========================================================================
    pub fn gimp_text_layer_get_type() -> GType;
    pub fn gimp_text_layer_new(image: *mut GimpImage, text: *const c_char, font: *mut GimpFont, size: c_double, unit: *mut GimpUnit) -> *mut GimpTextLayer;
    pub fn gimp_text_layer_get_by_id(layer_id: i32) -> *mut GimpTextLayer;
    pub fn gimp_text_layer_get_antialias(layer: *mut GimpTextLayer) -> gboolean;
    pub fn gimp_text_layer_get_base_direction(layer: *mut GimpTextLayer) -> GimpTextDirection;
    pub fn gimp_text_layer_get_color(layer: *mut GimpTextLayer) -> *mut gegl::GeglColor;
    pub fn gimp_text_layer_get_font(layer: *mut GimpTextLayer) -> *mut GimpFont;
    pub fn gimp_text_layer_get_font_size(layer: *mut GimpTextLayer, unit: *mut *mut GimpUnit) -> c_double;
    pub fn gimp_text_layer_get_hint_style(layer: *mut GimpTextLayer) -> GimpTextHintStyle;
    pub fn gimp_text_layer_get_indent(layer: *mut GimpTextLayer) -> c_double;
    pub fn gimp_text_layer_get_justification(layer: *mut GimpTextLayer) -> GimpTextJustification;
    pub fn gimp_text_layer_get_kerning(layer: *mut GimpTextLayer) -> gboolean;
    pub fn gimp_text_layer_get_language(layer: *mut GimpTextLayer) -> *mut c_char;
    pub fn gimp_text_layer_get_letter_spacing(layer: *mut GimpTextLayer) -> c_double;
    pub fn gimp_text_layer_get_line_spacing(layer: *mut GimpTextLayer) -> c_double;
    pub fn gimp_text_layer_get_markup(layer: *mut GimpTextLayer) -> *mut c_char;
    pub fn gimp_text_layer_get_text(layer: *mut GimpTextLayer) -> *mut c_char;
    pub fn gimp_text_layer_resize(layer: *mut GimpTextLayer, width: c_double, height: c_double) -> gboolean;
    pub fn gimp_text_layer_set_antialias(layer: *mut GimpTextLayer, antialias: gboolean) -> gboolean;
    pub fn gimp_text_layer_set_base_direction(layer: *mut GimpTextLayer, direction: GimpTextDirection) -> gboolean;
    pub fn gimp_text_layer_set_color(layer: *mut GimpTextLayer, color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_text_layer_set_font(layer: *mut GimpTextLayer, font: *mut GimpFont) -> gboolean;
    pub fn gimp_text_layer_set_font_size(layer: *mut GimpTextLayer, font_size: c_double, unit: *mut GimpUnit) -> gboolean;
    pub fn gimp_text_layer_set_hint_style(layer: *mut GimpTextLayer, style: GimpTextHintStyle) -> gboolean;
    pub fn gimp_text_layer_set_indent(layer: *mut GimpTextLayer, indent: c_double) -> gboolean;
    pub fn gimp_text_layer_set_justification(layer: *mut GimpTextLayer, justify: GimpTextJustification) -> gboolean;
    pub fn gimp_text_layer_set_kerning(layer: *mut GimpTextLayer, kerning: gboolean) -> gboolean;
    pub fn gimp_text_layer_set_language(layer: *mut GimpTextLayer, language: *const c_char) -> gboolean;
    pub fn gimp_text_layer_set_letter_spacing(layer: *mut GimpTextLayer, letter_spacing: c_double) -> gboolean;
    pub fn gimp_text_layer_set_line_spacing(layer: *mut GimpTextLayer, line_spacing: c_double) -> gboolean;
    pub fn gimp_text_layer_set_markup(layer: *mut GimpTextLayer, markup: *const c_char) -> gboolean;
    pub fn gimp_text_layer_set_text(layer: *mut GimpTextLayer, text: *const c_char) -> gboolean;

    //=========================================================================
    // GimpThumbnailProcedure
    //=========================================================================
    pub fn gimp_thumbnail_procedure_get_type() -> GType;
    pub fn gimp_thumbnail_procedure_new(plug_in: *mut GimpPlugIn, name: *const c_char, proc_type: GimpPDBProcType, run_func: GimpRunThumbnailFunc, run_data: gpointer, run_data_destroy: glib::GDestroyNotify) -> *mut GimpProcedure;

    //=========================================================================
    // GimpUnit
    //=========================================================================
    pub fn gimp_unit_get_type() -> GType;
    pub fn gimp_unit_new(name: *const c_char, factor: c_double, digits: c_int, symbol: *const c_char, abbreviation: *const c_char) -> *mut GimpUnit;
    pub fn gimp_unit_format_string(format: *const c_char, unit: *mut GimpUnit) -> *mut c_char;
    pub fn gimp_unit_get_by_id(unit_id: c_int) -> *mut GimpUnit;
    pub fn gimp_unit_inch() -> *mut GimpUnit;
    pub fn gimp_unit_mm() -> *mut GimpUnit;
    pub fn gimp_unit_percent() -> *mut GimpUnit;
    pub fn gimp_unit_pica() -> *mut GimpUnit;
    pub fn gimp_unit_pixel() -> *mut GimpUnit;
    pub fn gimp_unit_point() -> *mut GimpUnit;
    pub fn gimp_unit_get_abbreviation(unit: *mut GimpUnit) -> *const c_char;
    pub fn gimp_unit_get_deletion_flag(unit: *mut GimpUnit) -> gboolean;
    pub fn gimp_unit_get_digits(unit: *mut GimpUnit) -> c_int;
    pub fn gimp_unit_get_factor(unit: *mut GimpUnit) -> c_double;
    pub fn gimp_unit_get_id(unit: *mut GimpUnit) -> i32;
    pub fn gimp_unit_get_name(unit: *mut GimpUnit) -> *const c_char;
    pub fn gimp_unit_get_scaled_digits(unit: *mut GimpUnit, resolution: c_double) -> c_int;
    pub fn gimp_unit_get_symbol(unit: *mut GimpUnit) -> *const c_char;
    pub fn gimp_unit_is_built_in(unit: *mut GimpUnit) -> gboolean;
    pub fn gimp_unit_is_metric(unit: *mut GimpUnit) -> gboolean;
    pub fn gimp_unit_set_deletion_flag(unit: *mut GimpUnit, deletion_flag: gboolean);

    //=========================================================================
    // GimpVectorLoadProcedure
    //=========================================================================
    pub fn gimp_vector_load_procedure_get_type() -> GType;
    pub fn gimp_vector_load_procedure_new(plug_in: *mut GimpPlugIn, name: *const c_char, proc_type: GimpPDBProcType, extract_func: GimpExtractVectorFunc, extract_data: gpointer, extract_data_destroy: glib::GDestroyNotify, run_func: GimpRunVectorLoadFunc, run_data: gpointer, run_data_destroy: glib::GDestroyNotify) -> *mut GimpProcedure;
    pub fn gimp_vector_load_procedure_extract_dimensions(procedure: *mut GimpVectorLoadProcedure, file: *mut gio::GFile, data: *mut GimpVectorLoadData, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // GimpColorManaged
    //=========================================================================
    pub fn gimp_color_managed_get_type() -> GType;
    pub fn gimp_color_managed_get_color_profile(managed: *mut GimpColorManaged) -> *mut GimpColorProfile;
    pub fn gimp_color_managed_get_icc_profile(managed: *mut GimpColorManaged, len: *mut size_t) -> *const u8;
    pub fn gimp_color_managed_get_simulation_bpc(managed: *mut GimpColorManaged) -> gboolean;
    pub fn gimp_color_managed_get_simulation_intent(managed: *mut GimpColorManaged) -> GimpColorRenderingIntent;
    pub fn gimp_color_managed_get_simulation_profile(managed: *mut GimpColorManaged) -> *mut GimpColorProfile;
    pub fn gimp_color_managed_profile_changed(managed: *mut GimpColorManaged);
    pub fn gimp_color_managed_simulation_bpc_changed(managed: *mut GimpColorManaged);
    pub fn gimp_color_managed_simulation_intent_changed(managed: *mut GimpColorManaged);
    pub fn gimp_color_managed_simulation_profile_changed(managed: *mut GimpColorManaged);

    //=========================================================================
    // GimpConfigInterface
    //=========================================================================
    pub fn gimp_config_get_type() -> GType;
    pub fn gimp_config_build_data_path(name: *const c_char) -> *mut c_char;
    pub fn gimp_config_build_plug_in_path(name: *const c_char) -> *mut c_char;
    pub fn gimp_config_build_system_path(name: *const c_char) -> *mut c_char;
    pub fn gimp_config_build_writable_path(name: *const c_char) -> *mut c_char;
    pub fn gimp_config_deserialize_return(scanner: *mut glib::GScanner, expected_token: glib::GTokenType, nest_level: c_int) -> gboolean;
    pub fn gimp_config_diff(a: *mut gobject::GObject, b: *mut gobject::GObject, flags: gobject::GParamFlags) -> *mut glib::GList;
    pub fn gimp_config_error_quark() -> glib::GQuark;
    pub fn gimp_config_param_spec_duplicate(pspec: *mut gobject::GParamSpec) -> *mut gobject::GParamSpec;
    pub fn gimp_config_reset_properties(object: *mut gobject::GObject);
    pub fn gimp_config_reset_property(object: *mut gobject::GObject, property_name: *const c_char);
    pub fn gimp_config_serialize_value(value: *const gobject::GValue, str: *mut glib::GString, escaped: gboolean) -> gboolean;
    pub fn gimp_config_string_append_escaped(string: *mut glib::GString, val: *const c_char);
    pub fn gimp_config_sync(src: *mut gobject::GObject, dest: *mut gobject::GObject, flags: gobject::GParamFlags) -> gboolean;
    pub fn gimp_config_type_register(parent_type: GType, type_name: *const c_char, pspecs: *mut *mut gobject::GParamSpec, n_pspecs: c_int) -> GType;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gimp_adaptive_supersample_area(x1: c_int, y1: c_int, x2: c_int, y2: c_int, max_depth: c_int, threshold: c_double, render_func: GimpRenderFunc, render_data: gpointer, put_pixel_func: GimpPutPixelFunc, put_pixel_data: gpointer, progress_func: GimpProgressFunc, progress_data: gpointer) -> c_ulong;
    pub fn gimp_airbrush(drawable: *mut GimpDrawable, pressure: c_double, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_airbrush_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_any_to_utf8(str: *const c_char, len: ssize_t, warning_format: *const c_char, ...) -> *mut c_char;
    pub fn gimp_attach_parasite(parasite: *const GimpParasite) -> gboolean;
    pub fn gimp_babl_format_get_type() -> GType;
    pub fn gimp_bilinear(x: c_double, y: c_double, values: *mut [c_double; 4]) -> c_double;
    pub fn gimp_bilinear_16(x: c_double, y: c_double, values: *mut [u16; 4]) -> u16;
    pub fn gimp_bilinear_32(x: c_double, y: c_double, values: *mut [u32; 4]) -> u32;
    pub fn gimp_bilinear_8(x: c_double, y: c_double, values: *mut [c_uchar; 4]) -> c_uchar;
    pub fn gimp_bilinear_rgb(x: c_double, y: c_double, values: *mut [c_double; 16], has_alpha: gboolean, retvalues: *mut [c_double; 4]);
    pub fn gimp_bind_text_domain(domain_name: *const c_char, dir_name: *const c_char);
    pub fn gimp_brushes_close_popup(brush_callback: *const c_char) -> gboolean;
    pub fn gimp_brushes_get_list(filter: *const c_char) -> *mut *mut GimpBrush;
    pub fn gimp_brushes_popup(brush_callback: *const c_char, popup_title: *const c_char, initial_brush: *mut GimpBrush, parent_window: *mut glib::GBytes) -> gboolean;
    pub fn gimp_brushes_refresh() -> gboolean;
    pub fn gimp_brushes_set_popup(brush_callback: *const c_char, brush: *mut GimpBrush) -> gboolean;
    pub fn gimp_buffer_delete(buffer_name: *const c_char) -> gboolean;
    pub fn gimp_buffer_get_bytes(buffer_name: *const c_char) -> c_int;
    pub fn gimp_buffer_get_height(buffer_name: *const c_char) -> c_int;
    pub fn gimp_buffer_get_image_type(buffer_name: *const c_char) -> GimpImageType;
    pub fn gimp_buffer_get_width(buffer_name: *const c_char) -> c_int;
    pub fn gimp_buffer_rename(buffer_name: *const c_char, new_name: *const c_char) -> *mut c_char;
    pub fn gimp_buffers_get_name_list(filter: *const c_char) -> *mut *mut c_char;
    pub fn gimp_cache_directory() -> *const c_char;
    pub fn gimp_cairo_checkerboard_create(cr: *mut cairo::cairo_t, size: c_int, light: *const gegl::GeglColor, dark: *const gegl::GeglColor) -> *mut cairo::cairo_pattern_t;
    pub fn gimp_cairo_surface_create_buffer(surface: *mut cairo::cairo_surface_t, format: *const babl::Babl) -> *mut gegl::GeglBuffer;
    pub fn gimp_cairo_surface_get_format(surface: *mut cairo::cairo_surface_t) -> *const babl::Babl;
    pub fn gimp_canonicalize_identifier(identifier: *const c_char) -> *mut c_char;
    pub fn gimp_check_custom_color1() -> *const gegl::GeglColor;
    pub fn gimp_check_custom_color2() -> *const gegl::GeglColor;
    pub fn gimp_check_size() -> GimpCheckSize;
    pub fn gimp_check_type() -> GimpCheckType;
    pub fn gimp_checks_get_colors(type_: GimpCheckType, color1: *mut *mut gegl::GeglColor, color2: *mut *mut gegl::GeglColor);
    pub fn gimp_clone(drawable: *mut GimpDrawable, src_drawable: *mut GimpDrawable, clone_type: GimpCloneType, src_x: c_double, src_y: c_double, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_clone_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_color_array_copy(array: GimpColorArray) -> GimpColorArray;
    pub fn gimp_color_array_free(array: GimpColorArray);
    pub fn gimp_color_array_get_length(array: GimpColorArray) -> c_int;
    pub fn gimp_color_array_get_type() -> GType;
    pub fn gimp_color_is_out_of_gamut(color: *mut gegl::GeglColor, space: *const babl::Babl) -> gboolean;
    pub fn gimp_color_is_out_of_self_gamut(color: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_color_is_perceptually_identical(color1: *mut gegl::GeglColor, color2: *mut gegl::GeglColor) -> gboolean;
    //pub fn gimp_color_list_names(colors: /*Metadata mismatch*/*mut [c:type mismatch GimpColorArray != GeglColor of Color]) -> *mut *const c_char;
    pub fn gimp_color_parse_css(css: *const c_char) -> *mut gegl::GeglColor;
    pub fn gimp_color_parse_css_substring(css: *const c_char, len: c_int) -> *mut gegl::GeglColor;
    pub fn gimp_color_parse_hex(hex: *const c_char) -> *mut gegl::GeglColor;
    pub fn gimp_color_parse_hex_substring(hex: *const c_char, len: c_int) -> *mut gegl::GeglColor;
    pub fn gimp_color_parse_name(name: *const c_char) -> *mut gegl::GeglColor;
    pub fn gimp_color_parse_name_substring(name: *const c_char, len: c_int) -> *mut gegl::GeglColor;
    pub fn gimp_color_set_alpha(color: *mut gegl::GeglColor, alpha: c_double);
    pub fn gimp_context_are_dynamics_enabled() -> gboolean;
    pub fn gimp_context_enable_dynamics(enable: gboolean) -> gboolean;
    pub fn gimp_context_get_antialias() -> gboolean;
    pub fn gimp_context_get_background() -> *mut gegl::GeglColor;
    pub fn gimp_context_get_brush() -> *mut GimpBrush;
    pub fn gimp_context_get_brush_angle() -> c_double;
    pub fn gimp_context_get_brush_aspect_ratio() -> c_double;
    pub fn gimp_context_get_brush_force() -> c_double;
    pub fn gimp_context_get_brush_hardness() -> c_double;
    pub fn gimp_context_get_brush_size() -> c_double;
    pub fn gimp_context_get_brush_spacing() -> c_double;
    pub fn gimp_context_get_diagonal_neighbors() -> gboolean;
    pub fn gimp_context_get_distance_metric() -> gegl::GeglDistanceMetric;
    pub fn gimp_context_get_dynamics_name() -> *mut c_char;
    pub fn gimp_context_get_emulate_brush_dynamics() -> gboolean;
    pub fn gimp_context_get_feather() -> gboolean;
    pub fn gimp_context_get_feather_radius(feather_radius_x: *mut c_double, feather_radius_y: *mut c_double) -> gboolean;
    pub fn gimp_context_get_font() -> *mut GimpFont;
    pub fn gimp_context_get_foreground() -> *mut gegl::GeglColor;
    pub fn gimp_context_get_gradient() -> *mut GimpGradient;
    pub fn gimp_context_get_gradient_blend_color_space() -> GimpGradientBlendColorSpace;
    pub fn gimp_context_get_gradient_repeat_mode() -> GimpRepeatMode;
    pub fn gimp_context_get_gradient_reverse() -> gboolean;
    pub fn gimp_context_get_ink_angle() -> c_double;
    pub fn gimp_context_get_ink_blob_angle() -> c_double;
    pub fn gimp_context_get_ink_blob_aspect_ratio() -> c_double;
    pub fn gimp_context_get_ink_blob_type() -> GimpInkBlobType;
    pub fn gimp_context_get_ink_size() -> c_double;
    pub fn gimp_context_get_ink_size_sensitivity() -> c_double;
    pub fn gimp_context_get_ink_speed_sensitivity() -> c_double;
    pub fn gimp_context_get_ink_tilt_sensitivity() -> c_double;
    pub fn gimp_context_get_interpolation() -> GimpInterpolationType;
    pub fn gimp_context_get_line_cap_style() -> GimpCapStyle;
    pub fn gimp_context_get_line_dash_offset() -> c_double;
    pub fn gimp_context_get_line_dash_pattern(num_dashes: *mut size_t, dashes: *mut *mut c_double) -> gboolean;
    pub fn gimp_context_get_line_join_style() -> GimpJoinStyle;
    pub fn gimp_context_get_line_miter_limit() -> c_double;
    pub fn gimp_context_get_line_width() -> c_double;
    pub fn gimp_context_get_line_width_unit() -> *mut GimpUnit;
    pub fn gimp_context_get_mypaint_brush() -> *mut c_char;
    pub fn gimp_context_get_opacity() -> c_double;
    pub fn gimp_context_get_paint_method() -> *mut c_char;
    pub fn gimp_context_get_paint_mode() -> GimpLayerMode;
    pub fn gimp_context_get_palette() -> *mut GimpPalette;
    pub fn gimp_context_get_pattern() -> *mut GimpPattern;
    pub fn gimp_context_get_sample_criterion() -> GimpSelectCriterion;
    pub fn gimp_context_get_sample_merged() -> gboolean;
    pub fn gimp_context_get_sample_threshold() -> c_double;
    pub fn gimp_context_get_sample_threshold_int() -> c_int;
    pub fn gimp_context_get_sample_transparent() -> gboolean;
    pub fn gimp_context_get_stroke_method() -> GimpStrokeMethod;
    pub fn gimp_context_get_transform_direction() -> GimpTransformDirection;
    pub fn gimp_context_get_transform_resize() -> GimpTransformResize;
    pub fn gimp_context_list_paint_methods(paint_methods: *mut *mut *mut c_char) -> gboolean;
    pub fn gimp_context_pop() -> gboolean;
    pub fn gimp_context_push() -> gboolean;
    pub fn gimp_context_set_antialias(antialias: gboolean) -> gboolean;
    pub fn gimp_context_set_background(background: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_context_set_brush(brush: *mut GimpBrush) -> gboolean;
    pub fn gimp_context_set_brush_angle(angle: c_double) -> gboolean;
    pub fn gimp_context_set_brush_aspect_ratio(aspect: c_double) -> gboolean;
    pub fn gimp_context_set_brush_default_hardness() -> gboolean;
    pub fn gimp_context_set_brush_default_size() -> gboolean;
    pub fn gimp_context_set_brush_default_spacing() -> gboolean;
    pub fn gimp_context_set_brush_force(force: c_double) -> gboolean;
    pub fn gimp_context_set_brush_hardness(hardness: c_double) -> gboolean;
    pub fn gimp_context_set_brush_size(size: c_double) -> gboolean;
    pub fn gimp_context_set_brush_spacing(spacing: c_double) -> gboolean;
    pub fn gimp_context_set_default_colors() -> gboolean;
    pub fn gimp_context_set_defaults() -> gboolean;
    pub fn gimp_context_set_diagonal_neighbors(diagonal_neighbors: gboolean) -> gboolean;
    pub fn gimp_context_set_distance_metric(metric: gegl::GeglDistanceMetric) -> gboolean;
    pub fn gimp_context_set_dynamics_name(name: *const c_char) -> gboolean;
    pub fn gimp_context_set_emulate_brush_dynamics(emulate_dynamics: gboolean) -> gboolean;
    pub fn gimp_context_set_feather(feather: gboolean) -> gboolean;
    pub fn gimp_context_set_feather_radius(feather_radius_x: c_double, feather_radius_y: c_double) -> gboolean;
    pub fn gimp_context_set_font(font: *mut GimpFont) -> gboolean;
    pub fn gimp_context_set_foreground(foreground: *mut gegl::GeglColor) -> gboolean;
    pub fn gimp_context_set_gradient(gradient: *mut GimpGradient) -> gboolean;
    pub fn gimp_context_set_gradient_blend_color_space(blend_color_space: GimpGradientBlendColorSpace) -> gboolean;
    pub fn gimp_context_set_gradient_fg_bg_hsv_ccw() -> gboolean;
    pub fn gimp_context_set_gradient_fg_bg_hsv_cw() -> gboolean;
    pub fn gimp_context_set_gradient_fg_bg_rgb() -> gboolean;
    pub fn gimp_context_set_gradient_fg_transparent() -> gboolean;
    pub fn gimp_context_set_gradient_repeat_mode(repeat_mode: GimpRepeatMode) -> gboolean;
    pub fn gimp_context_set_gradient_reverse(reverse: gboolean) -> gboolean;
    pub fn gimp_context_set_ink_angle(angle: c_double) -> gboolean;
    pub fn gimp_context_set_ink_blob_angle(angle: c_double) -> gboolean;
    pub fn gimp_context_set_ink_blob_aspect_ratio(aspect: c_double) -> gboolean;
    pub fn gimp_context_set_ink_blob_type(type_: GimpInkBlobType) -> gboolean;
    pub fn gimp_context_set_ink_size(size: c_double) -> gboolean;
    pub fn gimp_context_set_ink_size_sensitivity(size: c_double) -> gboolean;
    pub fn gimp_context_set_ink_speed_sensitivity(speed: c_double) -> gboolean;
    pub fn gimp_context_set_ink_tilt_sensitivity(tilt: c_double) -> gboolean;
    pub fn gimp_context_set_interpolation(interpolation: GimpInterpolationType) -> gboolean;
    pub fn gimp_context_set_line_cap_style(cap_style: GimpCapStyle) -> gboolean;
    pub fn gimp_context_set_line_dash_offset(dash_offset: c_double) -> gboolean;
    pub fn gimp_context_set_line_dash_pattern(num_dashes: size_t, dashes: *const c_double) -> gboolean;
    pub fn gimp_context_set_line_join_style(join_style: GimpJoinStyle) -> gboolean;
    pub fn gimp_context_set_line_miter_limit(miter_limit: c_double) -> gboolean;
    pub fn gimp_context_set_line_width(line_width: c_double) -> gboolean;
    pub fn gimp_context_set_line_width_unit(line_width_unit: *mut GimpUnit) -> gboolean;
    pub fn gimp_context_set_mypaint_brush(name: *const c_char) -> gboolean;
    pub fn gimp_context_set_opacity(opacity: c_double) -> gboolean;
    pub fn gimp_context_set_paint_method(name: *const c_char) -> gboolean;
    pub fn gimp_context_set_paint_mode(paint_mode: GimpLayerMode) -> gboolean;
    pub fn gimp_context_set_palette(palette: *mut GimpPalette) -> gboolean;
    pub fn gimp_context_set_pattern(pattern: *mut GimpPattern) -> gboolean;
    pub fn gimp_context_set_sample_criterion(sample_criterion: GimpSelectCriterion) -> gboolean;
    pub fn gimp_context_set_sample_merged(sample_merged: gboolean) -> gboolean;
    pub fn gimp_context_set_sample_threshold(sample_threshold: c_double) -> gboolean;
    pub fn gimp_context_set_sample_threshold_int(sample_threshold: c_int) -> gboolean;
    pub fn gimp_context_set_sample_transparent(sample_transparent: gboolean) -> gboolean;
    pub fn gimp_context_set_stroke_method(stroke_method: GimpStrokeMethod) -> gboolean;
    pub fn gimp_context_set_transform_direction(transform_direction: GimpTransformDirection) -> gboolean;
    pub fn gimp_context_set_transform_resize(transform_resize: GimpTransformResize) -> gboolean;
    pub fn gimp_context_swap_colors() -> gboolean;
    pub fn gimp_convolve(drawable: *mut GimpDrawable, pressure: c_double, convolve_type: GimpConvolveType, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_convolve_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_core_object_array_get_length(array: *mut *mut gobject::GObject) -> size_t;
    pub fn gimp_core_object_array_get_type() -> GType;
    //pub fn gimp_cpu_accel_get_support() -> /*Ignored*/GimpCpuAccelFlags;
    pub fn gimp_data_directory() -> *const c_char;
    pub fn gimp_data_directory_file(first_element: *const c_char, ...) -> *mut gio::GFile;
    pub fn gimp_debug_timer_end() -> c_double;
    pub fn gimp_debug_timer_start() -> gboolean;
    pub fn gimp_default_display() -> *mut GimpDisplay;
    pub fn gimp_detach_parasite(name: *const c_char) -> gboolean;
    pub fn gimp_directory() -> *const c_char;
    pub fn gimp_directory_file(first_element: *const c_char, ...) -> *mut gio::GFile;
    pub fn gimp_displays_flush() -> gboolean;
    pub fn gimp_displays_reconnect(old_image: *mut GimpImage, new_image: *mut GimpImage) -> gboolean;
    pub fn gimp_dodgeburn(drawable: *mut GimpDrawable, exposure: c_double, dodgeburn_type: GimpDodgeBurnType, dodgeburn_mode: GimpTransferMode, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_dodgeburn_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_drawables_close_popup(callback: *const c_char) -> gboolean;
    pub fn gimp_drawables_popup(callback: *const c_char, popup_title: *const c_char, drawable_type: *const c_char, initial_drawable: *mut GimpDrawable, parent_window: *mut glib::GBytes) -> gboolean;
    pub fn gimp_drawables_set_popup(callback: *const c_char, drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_dynamics_get_name_list(filter: *const c_char) -> *mut *mut c_char;
    pub fn gimp_dynamics_refresh() -> gboolean;
    pub fn gimp_edit_copy(drawables: *mut *const GimpDrawable) -> gboolean;
    pub fn gimp_edit_copy_visible(image: *mut GimpImage) -> gboolean;
    pub fn gimp_edit_cut(drawables: *mut *const GimpDrawable) -> gboolean;
    pub fn gimp_edit_named_copy(drawables: *mut *const GimpDrawable, buffer_name: *const c_char) -> *mut c_char;
    pub fn gimp_edit_named_copy_visible(image: *mut GimpImage, buffer_name: *const c_char) -> *mut c_char;
    pub fn gimp_edit_named_cut(drawables: *mut *const GimpDrawable, buffer_name: *const c_char) -> *mut c_char;
    pub fn gimp_edit_named_paste(drawable: *mut GimpDrawable, buffer_name: *const c_char, paste_into: gboolean) -> *mut GimpLayer;
    pub fn gimp_edit_named_paste_as_new_image(buffer_name: *const c_char) -> *mut GimpImage;
    pub fn gimp_edit_paste(drawable: *mut GimpDrawable, paste_into: gboolean) -> *mut *mut GimpDrawable;
    pub fn gimp_edit_paste_as_new_image() -> *mut GimpImage;
    pub fn gimp_enum_get_desc(enum_class: *mut gobject::GEnumClass, value: c_int) -> *const GimpEnumDesc;
    pub fn gimp_enum_get_value(enum_type: GType, value: c_int, value_name: *mut *const c_char, value_nick: *mut *const c_char, value_desc: *mut *const c_char, value_help: *mut *const c_char) -> gboolean;
    pub fn gimp_enum_get_value_descriptions(enum_type: GType) -> *const GimpEnumDesc;
    pub fn gimp_enum_set_value_descriptions(enum_type: GType, descriptions: *const GimpEnumDesc);
    pub fn gimp_enum_value_get_abbrev(enum_class: *mut gobject::GEnumClass, enum_value: *const gobject::GEnumValue) -> *const c_char;
    pub fn gimp_enum_value_get_desc(enum_class: *mut gobject::GEnumClass, enum_value: *const gobject::GEnumValue) -> *const c_char;
    pub fn gimp_enum_value_get_help(enum_class: *mut gobject::GEnumClass, enum_value: *const gobject::GEnumValue) -> *const c_char;
    pub fn gimp_enums_get_type_names(n_type_names: *mut c_int) -> *mut *const c_char;
    pub fn gimp_enums_init();
    pub fn gimp_eraser(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double, hardness: GimpBrushApplicationMode, method: GimpPaintApplicationMode) -> gboolean;
    pub fn gimp_eraser_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_escape_uline(str: *const c_char) -> *mut c_char;
    pub fn gimp_export_color_profile() -> gboolean;
    pub fn gimp_export_comment() -> gboolean;
    pub fn gimp_export_exif() -> gboolean;
    pub fn gimp_export_iptc() -> gboolean;
    pub fn gimp_export_thumbnail() -> gboolean;
    pub fn gimp_export_xmp() -> gboolean;
    pub fn gimp_file_get_config_path(file: *mut gio::GFile, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn gimp_file_get_utf8_name(file: *mut gio::GFile) -> *const c_char;
    pub fn gimp_file_has_extension(file: *mut gio::GFile, extension: *const c_char) -> gboolean;
    pub fn gimp_file_load(run_mode: GimpRunMode, file: *mut gio::GFile) -> *mut GimpImage;
    pub fn gimp_file_load_layer(run_mode: GimpRunMode, image: *mut GimpImage, file: *mut gio::GFile) -> *mut GimpLayer;
    pub fn gimp_file_load_layers(run_mode: GimpRunMode, image: *mut GimpImage, file: *mut gio::GFile) -> *mut *mut GimpLayer;
    pub fn gimp_file_new_for_config_path(path: *const c_char, error: *mut *mut glib::GError) -> *mut gio::GFile;
    pub fn gimp_file_save(run_mode: GimpRunMode, image: *mut GimpImage, file: *mut gio::GFile, options: *mut GimpExportOptions) -> gboolean;
    pub fn gimp_file_save_thumbnail(image: *mut GimpImage, file: *mut gio::GFile) -> gboolean;
    pub fn gimp_file_show_in_file_manager(file: *mut gio::GFile, error: *mut *mut glib::GError) -> gboolean;
    pub fn gimp_filename_to_utf8(filename: *const c_char) -> *const c_char;
    pub fn gimp_flags_get_first_desc(flags_class: *mut gobject::GFlagsClass, value: c_uint) -> *const GimpFlagsDesc;
    pub fn gimp_flags_get_first_value(flags_type: GType, value: c_uint, value_name: *mut *const c_char, value_nick: *mut *const c_char, value_desc: *mut *const c_char, value_help: *mut *const c_char) -> gboolean;
    pub fn gimp_flags_get_value_descriptions(flags_type: GType) -> *const GimpFlagsDesc;
    pub fn gimp_flags_set_value_descriptions(flags_type: GType, descriptions: *const GimpFlagsDesc);
    pub fn gimp_flags_value_get_abbrev(flags_class: *mut gobject::GFlagsClass, flags_value: *const gobject::GFlagsValue) -> *const c_char;
    pub fn gimp_flags_value_get_desc(flags_class: *mut gobject::GFlagsClass, flags_value: *const gobject::GFlagsValue) -> *const c_char;
    pub fn gimp_flags_value_get_help(flags_class: *mut gobject::GFlagsClass, flags_value: *const gobject::GFlagsValue) -> *const c_char;
    pub fn gimp_floating_sel_anchor(floating_sel: *mut GimpLayer) -> gboolean;
    pub fn gimp_floating_sel_attach(layer: *mut GimpLayer, drawable: *mut GimpDrawable) -> gboolean;
    pub fn gimp_floating_sel_remove(floating_sel: *mut GimpLayer) -> gboolean;
    pub fn gimp_floating_sel_to_layer(floating_sel: *mut GimpLayer) -> gboolean;
    pub fn gimp_fonts_close_popup(font_callback: *const c_char) -> gboolean;
    pub fn gimp_fonts_get_list(filter: *const c_char) -> *mut *mut GimpFont;
    pub fn gimp_fonts_popup(font_callback: *const c_char, popup_title: *const c_char, initial_font: *mut GimpFont, parent_window: *mut glib::GBytes) -> gboolean;
    pub fn gimp_fonts_refresh() -> gboolean;
    pub fn gimp_fonts_set_popup(font_callback: *const c_char, font: *mut GimpFont) -> gboolean;
    pub fn gimp_get_color_configuration() -> *mut GimpColorConfig;
    pub fn gimp_get_default_comment() -> *mut c_char;
    pub fn gimp_get_default_unit() -> *mut GimpUnit;
    pub fn gimp_get_images() -> *mut *mut GimpImage;
    pub fn gimp_get_module_load_inhibit() -> *mut c_char;
    pub fn gimp_get_monitor_resolution(xres: *mut c_double, yres: *mut c_double) -> gboolean;
    pub fn gimp_get_num_processors() -> c_int;
    pub fn gimp_get_parasite(name: *const c_char) -> *mut GimpParasite;
    pub fn gimp_get_parasite_list() -> *mut *mut c_char;
    pub fn gimp_get_pdb() -> *mut GimpPDB;
    pub fn gimp_get_plug_in() -> *mut GimpPlugIn;
    pub fn gimp_get_progname() -> *const c_char;
    pub fn gimp_getpid() -> c_int;
    pub fn gimp_gimprc_query(token: *const c_char) -> *mut c_char;
    pub fn gimp_gimprc_set(token: *const c_char, value: *const c_char) -> gboolean;
    pub fn gimp_gradients_close_popup(gradient_callback: *const c_char) -> gboolean;
    pub fn gimp_gradients_get_list(filter: *const c_char) -> *mut *mut GimpGradient;
    pub fn gimp_gradients_popup(gradient_callback: *const c_char, popup_title: *const c_char, initial_gradient: *mut GimpGradient, parent_window: *mut glib::GBytes) -> gboolean;
    pub fn gimp_gradients_refresh() -> gboolean;
    pub fn gimp_gradients_set_popup(gradient_callback: *const c_char, gradient: *mut GimpGradient) -> gboolean;
    pub fn gimp_heal(drawable: *mut GimpDrawable, src_drawable: *mut GimpDrawable, src_x: c_double, src_y: c_double, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_heal_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_help(help_domain: *const c_char, help_id: *const c_char) -> gboolean;
    pub fn gimp_icon_theme_dir() -> *const c_char;
    pub fn gimp_installation_directory() -> *const c_char;
    pub fn gimp_installation_directory_file(first_element: *const c_char, ...) -> *mut gio::GFile;
    pub fn gimp_is_canonical_identifier(identifier: *const c_char) -> gboolean;
    pub fn gimp_list_images() -> *mut glib::GList;
    pub fn gimp_locale_directory() -> *const c_char;
    pub fn gimp_locale_directory_file(first_element: *const c_char, ...) -> *mut gio::GFile;
    pub fn gimp_main(plug_in_type: GType, argc: c_int, argv: *mut *mut c_char) -> c_int;
    pub fn gimp_message(message: *const c_char) -> gboolean;
    pub fn gimp_message_get_handler() -> GimpMessageHandlerType;
    pub fn gimp_message_set_handler(handler: GimpMessageHandlerType) -> gboolean;
    pub fn gimp_monitor_number() -> c_int;
    pub fn gimp_paintbrush(drawable: *mut GimpDrawable, fade_out: c_double, num_strokes: size_t, strokes: *const c_double, method: GimpPaintApplicationMode, gradient_length: c_double) -> gboolean;
    pub fn gimp_paintbrush_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_palettes_close_popup(palette_callback: *const c_char) -> gboolean;
    pub fn gimp_palettes_get_list(filter: *const c_char) -> *mut *mut GimpPalette;
    pub fn gimp_palettes_popup(palette_callback: *const c_char, popup_title: *const c_char, initial_palette: *mut GimpPalette, parent_window: *mut glib::GBytes) -> gboolean;
    pub fn gimp_palettes_refresh() -> gboolean;
    pub fn gimp_palettes_set_popup(palette_callback: *const c_char, palette: *mut GimpPalette) -> gboolean;
    pub fn gimp_param_spec_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_brush(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpBrush, default_to_context: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_channel(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_choice(name: *const c_char, nick: *const c_char, blurb: *const c_char, choice: *mut GimpChoice, default_value: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_color(name: *const c_char, nick: *const c_char, blurb: *const c_char, has_alpha: gboolean, default_color: *mut gegl::GeglColor, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_config_path(name: *const c_char, nick: *const c_char, blurb: *const c_char, type_: GimpConfigPathType, default_value: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_config_path_type(pspec: *mut gobject::GParamSpec) -> GimpConfigPathType;
    pub fn gimp_param_spec_core_object_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, object_type: GType, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_display(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_double_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_drawable(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_drawable_filter(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_export_options(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_font(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpFont, default_to_context: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_gradient(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpGradient, default_to_context: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_group_layer(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_image(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_int32_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_item(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_layer(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_layer_mask(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_matrix2(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *const GimpMatrix2, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_matrix3(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_value: *const GimpMatrix3, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_memsize(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: u64, maximum: u64, default_value: u64, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_palette(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpPalette, default_to_context: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_parasite(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_path(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_pattern(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, default_value: *mut GimpPattern, default_to_context: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_resource(name: *const c_char, nick: *const c_char, blurb: *const c_char, resource_type: GType, none_ok: gboolean, default_value: *mut GimpResource, default_to_context: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_selection(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_text_layer(name: *const c_char, nick: *const c_char, blurb: *const c_char, none_ok: gboolean, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_unit(name: *const c_char, nick: *const c_char, blurb: *const c_char, allow_pixel: gboolean, allow_percent: gboolean, default_value: *mut GimpUnit, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_param_spec_value_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, element_spec: *mut gobject::GParamSpec, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gimp_patterns_close_popup(pattern_callback: *const c_char) -> gboolean;
    pub fn gimp_patterns_get_list(filter: *const c_char) -> *mut *mut GimpPattern;
    pub fn gimp_patterns_popup(pattern_callback: *const c_char, popup_title: *const c_char, initial_pattern: *mut GimpPattern, parent_window: *mut glib::GBytes) -> gboolean;
    pub fn gimp_patterns_refresh() -> gboolean;
    pub fn gimp_patterns_set_popup(pattern_callback: *const c_char, pattern: *mut GimpPattern) -> gboolean;
    pub fn gimp_pencil(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_pixbuf_create_buffer(pixbuf: *mut gdk_pixbuf::GdkPixbuf) -> *mut gegl::GeglBuffer;
    pub fn gimp_pixbuf_get_format(pixbuf: *mut gdk_pixbuf::GdkPixbuf) -> *const babl::Babl;
    pub fn gimp_pixbuf_get_icc_profile(pixbuf: *mut gdk_pixbuf::GdkPixbuf, length: *mut size_t) -> *mut u8;
    pub fn gimp_pixels_to_units(pixels: c_double, unit: *mut GimpUnit, resolution: c_double) -> c_double;
    pub fn gimp_pixpipe_params_build(params: *mut GimpPixPipeParams) -> *mut c_char;
    pub fn gimp_pixpipe_params_free(params: *mut GimpPixPipeParams);
    pub fn gimp_pixpipe_params_init(params: *mut GimpPixPipeParams);
    pub fn gimp_pixpipe_params_parse(parameters: *const c_char, params: *mut GimpPixPipeParams);
    pub fn gimp_progress_cancel(progress_callback: *const c_char) -> gboolean;
    pub fn gimp_progress_end() -> gboolean;
    pub fn gimp_progress_get_window_handle() -> *mut glib::GBytes;
    pub fn gimp_progress_init(message: *const c_char) -> gboolean;
    pub fn gimp_progress_init_printf(format: *const c_char, ...) -> gboolean;
    pub fn gimp_progress_install_vtable(vtable: *const GimpProgressVtable, user_data: gpointer, user_data_destroy: glib::GDestroyNotify) -> *const c_char;
    pub fn gimp_progress_pulse() -> gboolean;
    pub fn gimp_progress_set_text(message: *const c_char) -> gboolean;
    pub fn gimp_progress_set_text_printf(format: *const c_char, ...) -> gboolean;
    pub fn gimp_progress_uninstall(progress_callback: *const c_char);
    pub fn gimp_progress_update(percentage: c_double) -> gboolean;
    pub fn gimp_quit();
    pub fn gimp_range_estimate_settings(lower: c_double, upper: c_double, step: *mut c_double, page: *mut c_double, digits: *mut c_int);
    pub fn gimp_rectangle_intersect(x1: c_int, y1: c_int, width1: c_int, height1: c_int, x2: c_int, y2: c_int, width2: c_int, height2: c_int, dest_x: *mut c_int, dest_y: *mut c_int, dest_width: *mut c_int, dest_height: *mut c_int) -> gboolean;
    pub fn gimp_rectangle_union(x1: c_int, y1: c_int, width1: c_int, height1: c_int, x2: c_int, y2: c_int, width2: c_int, height2: c_int, dest_x: *mut c_int, dest_y: *mut c_int, dest_width: *mut c_int, dest_height: *mut c_int);
    pub fn gimp_show_help_button() -> gboolean;
    pub fn gimp_smudge(drawable: *mut GimpDrawable, pressure: c_double, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_smudge_default(drawable: *mut GimpDrawable, num_strokes: size_t, strokes: *const c_double) -> gboolean;
    pub fn gimp_stack_trace_available(optimal: gboolean) -> gboolean;
    pub fn gimp_stack_trace_print(prog_name: *const c_char, stream: gpointer, trace: *mut *mut c_char) -> gboolean;
    pub fn gimp_stack_trace_query(prog_name: *const c_char);
    pub fn gimp_strip_uline(str: *const c_char) -> *mut c_char;
    pub fn gimp_sysconf_directory() -> *const c_char;
    pub fn gimp_sysconf_directory_file(first_element: *const c_char, ...) -> *mut gio::GFile;
    pub fn gimp_temp_directory() -> *const c_char;
    pub fn gimp_temp_file(extension: *const c_char) -> *mut gio::GFile;
    pub fn gimp_text_font(image: *mut GimpImage, drawable: *mut GimpDrawable, x: c_double, y: c_double, text: *const c_char, border: c_int, antialias: gboolean, size: c_double, font: *mut GimpFont) -> *mut GimpLayer;
    pub fn gimp_text_get_extents_font(text: *const c_char, size: c_double, font: *mut GimpFont, width: *mut c_int, height: *mut c_int, ascent: *mut c_int, descent: *mut c_int) -> gboolean;
    pub fn gimp_tile_height() -> c_uint;
    pub fn gimp_tile_width() -> c_uint;
    pub fn gimp_type_get_translation_context(type_: GType) -> *const c_char;
    pub fn gimp_type_get_translation_domain(type_: GType) -> *const c_char;
    pub fn gimp_type_set_translation_context(type_: GType, context: *const c_char);
    pub fn gimp_type_set_translation_domain(type_: GType, domain: *const c_char);
    pub fn gimp_units_to_pixels(value: c_double, unit: *mut GimpUnit, resolution: c_double) -> c_double;
    pub fn gimp_units_to_points(value: c_double, unit: *mut GimpUnit, resolution: c_double) -> c_double;
    pub fn gimp_user_time() -> u32;
    pub fn gimp_utf8_strtrim(str: *const c_char, max_chars: c_int) -> *mut c_char;
    pub fn gimp_value_dup_double_array(value: *const gobject::GValue, length: *mut size_t) -> *mut c_double;
    pub fn gimp_value_dup_int32_array(value: *const gobject::GValue, length: *mut size_t) -> *mut i32;
    pub fn gimp_value_get_double_array(value: *const gobject::GValue, length: *mut size_t) -> *const c_double;
    pub fn gimp_value_get_int32_array(value: *const gobject::GValue, length: *mut size_t) -> *const i32;
    pub fn gimp_value_set_double_array(value: *mut gobject::GValue, data: *const c_double, length: size_t);
    pub fn gimp_value_set_int32_array(value: *mut gobject::GValue, data: *const i32, length: size_t);
    pub fn gimp_value_set_static_double_array(value: *mut gobject::GValue, data: *const c_double, length: size_t);
    pub fn gimp_value_set_static_int32_array(value: *mut gobject::GValue, data: *const i32, length: size_t);
    pub fn gimp_value_take_double_array(value: *mut gobject::GValue, data: *mut c_double, length: size_t);
    pub fn gimp_value_take_int32_array(value: *mut gobject::GValue, data: *mut i32, length: size_t);
    pub fn gimp_vector_2d_to_3d(sx: c_int, sy: c_int, w: c_int, h: c_int, x: c_int, y: c_int, vp: *const GimpVector3, p: *mut GimpVector3);
    pub fn gimp_vector_2d_to_3d_val(sx: c_int, sy: c_int, w: c_int, h: c_int, x: c_int, y: c_int, vp: GimpVector3, p: GimpVector3) -> GimpVector3;
    pub fn gimp_vector_3d_to_2d(sx: c_int, sy: c_int, w: c_int, h: c_int, x: *mut c_double, y: *mut c_double, vp: *const GimpVector3, p: *const GimpVector3);
    pub fn gimp_version() -> *mut c_char;
    pub fn gimp_wm_class() -> *const c_char;

}
